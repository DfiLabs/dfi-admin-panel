<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Monitor</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="logo">
                <img src="assets/images/dfi-labs-logo.png" alt="DFI Labs" class="logo-image">
                <div class="logo-text">
                    <span class="logo-main">Strategy Monitor</span>
                    <span class="logo-subtitle">DFI Labs</span>
                </div>
            </div>
            <div class="header-info">
                <div class="status-indicator">
                    <div class="status-dot active"></div>
                    <span>Live</span>
                </div>
                <span id="current-time">Loading...</span>
            </div>
        </div>
    </header>

    <main class="main">
        <div class="container">
            <div class="dashboard-header">
                <h1>Live Portfolio Dashboard</h1>
                <p>Real-time cryptocurrency strategy monitoring & performance tracking</p>
                <div style="margin-top:8px">
                    <label for="strategy-select" style="font-weight:600;margin-right:8px;color:#6b7280">Strategy</label>
                    <select id="strategy-select" style="padding:10px 14px;border:1px solid #e5e7eb;border-radius:10px;background:#fff;color:#111827">
                        <option value="/signal-dashboard/data/">Descartes Unravel</option>
                        <option value="/signal-dashboard/descartes-beta/data/">Descartes Beta</option>
                        <option value="/signal-dashboard/descartes-ridge-unravel/data/">Descartes Ridge Unravel</option>
                    </select>
                </div>
            </div>

            <!-- Delta Donut Chart -->
            <div class="delta-donut-section">
                <div class="delta-donut-card">
                    <div class="delta-header">
                        <h3>Portfolio Exposure</h3>
                        <div class="delta-status">
                            <span class="delta-label">NET EXPOSURE</span>
                            <span class="delta-value" id="delta-value">Loading...</span>
                        </div>
                    </div>
                    <div class="delta-progress-container">
                        <div class="delta-progress-bar">
                            <div class="delta-progress-fill" id="delta-progress-fill"></div>
                            <div class="delta-progress-indicator" id="delta-progress-indicator"></div>
                        </div>
                        <div class="delta-progress-labels">
                            <span class="delta-label-left">SHORT</span>
                            <span class="delta-label-right">LONG</span>
                        </div>
                        <div class="delta-progress-value">
                            <span id="delta-percentage">0%</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Core Metrics Row 1 (5 cards) -->
            <div class="summary-cards">
                <div class="card primary-metric" data-formula-key="portfolio-value">
                    <h3>Portfolio Value</h3>
                    <div class="value" id="portfolio-value">Loading...</div>
                    <div class="subtitle">as of <span id="portfolio-time">Loading...</span></div>
                </div>
                <div class="card" data-formula-key="daily-pnl">
                    <h3>Daily P&L</h3>
                    <div class="value" id="daily-pnl">Loading...</div>
                    <div class="percentage" id="daily-pnl-percent"></div>
                </div>
                <div class="card" data-formula-key="total-pnl">
                    <h3>Total P&L Since Inception</h3>
                    <div class="value" id="total-pnl">Loading...</div>
                    <div class="percentage" id="total-pnl-percent"></div>
                </div>
                <div class="card" data-formula-key="positions">
                    <h3>Positions</h3>
                    <div class="value" id="total-positions-count">Loading...</div>
                    <div class="subtitle">Total Open Positions</div>
                </div>
                <div class="card" data-formula-key="avg-daily-return">
                    <h3>Average Daily Return</h3>
                    <div class="value" id="avg-daily-return">Loading...</div>
                    <div class="subtitle" id="avg-daily-return-meta"></div>
                </div>
            </div>

            <!-- Core Metrics Row 2 (5 cards) -->
            <div class="summary-cards">
                <div class="card long-position" data-formula-key="long-positions">
                    <h3>Long Positions</h3>
                    <div class="value" id="long-notional">Loading...</div>
                    <div class="percentage" id="long-pnl-percent"></div>
                    <div class="subtitle" id="long-count">0 positions</div>
                </div>
                <div class="card short-position" data-formula-key="short-positions">
                    <h3>Short Positions</h3>
                    <div class="value" id="short-notional">Loading...</div>
                    <div class="percentage" id="short-pnl-percent"></div>
                    <div class="subtitle" id="short-count">0 positions</div>
                </div>
                <div class="card" data-formula-key="avg-pnl-per-trade">
                    <h3>Avg P&L per Trade</h3>
                    <div class="value" id="avg-pnl-per-trade">Loading...</div>
                    <div class="subtitle" id="avg-pnl-trade-meta"></div>
                </div>
                <div class="card" data-formula-key="vol-ann">
                    <h3>Volatility (Ann.)</h3>
                    <div class="value" id="vol-ann">Loading...</div>
                    <div class="subtitle" id="vol-ann-meta"></div>
                </div>
                <div class="card" data-formula-key="sharpe-ann">
                    <h3>Sharpe (Ann.)</h3>
                    <div class="value" id="sharpe-ann">Loading...</div>
                    <div class="subtitle" id="sharpe-ann-meta"></div>
                </div>
            </div>

            <!-- Formula Modal -->
            <div id="formula-modal" class="formula-modal hidden" onclick="hideFormula()">
                <div class="formula-content" onclick="event.stopPropagation()">
                    <div class="formula-title" id="formula-title">Formula</div>
                    <div class="formula-text" id="formula-text">Loading...</div>
                    <div style="margin-top:12px; text-align:right">
                        <button class="formula-close" onclick="hideFormula()">Close</button>
                    </div>
                </div>
            </div>

            <!-- Portfolio Value Chart with Time Scales -->
            <div class="chart-section">
                <div class="chart-header">
                    <h2>Portfolio Performance</h2>
                    <button id="csv-toggle" class="csv-toggle" title="Show CSV source and load time">📊</button>
                    <div class="download-widget">
                        <button id="download-btn" class="download-button" title="Download Daily % Returns">Download</button>
                        <div id="download-popover" class="download-popover" hidden>
                            <div class="dw-header">
                                <span class="dw-title">Download data</span>
                                <button id="dw-x" class="dw-x" aria-label="Close">×</button>
                            </div>
                            <div class="dw-row">
                                <label class="dw-label">Range</label>
                                <div class="dw-range">
                                    <input type="date" id="dw-start" />
                                    <span class="dw-sep">to</span>
                                    <input type="date" id="dw-end" />
                                </div>
                            </div>
                            <div class="dw-row dw-presets">
                                <button type="button" data-preset="7">7D</button>
                                <button type="button" data-preset="30" class="active">30D</button>
                                <button type="button" data-preset="90">90D</button>
                                <button type="button" data-preset="all">All</button>
                            </div>
                            <div class="dw-row">
                                <label class="dw-label">Series</label>
                                <select id="dw-series">
                                    <option value="daily_returns" selected>Daily % Return</option>
                                    <option value="daily_pv">Daily Portfolio Value</option>
                                </select>
                            </div>
                            <div class="dw-row">
                                <label class="dw-label">Format</label>
                                <select id="dw-format">
                                    <option value="csv" selected>CSV</option>
                                    <option value="json">JSON</option>
                                </select>
                            </div>
                            <div class="dw-row dw-note">UTC • Strategy-aware</div>
                            <div class="dw-row dw-actions">
                                <button id="dw-download" class="primary" type="button">Download</button>
                                <button id="dw-close" class="secondary" type="button">Close</button>
                            </div>
                        </div>
                    </div>
                    <div class="csv-info" id="csv-info" title="" hidden>
                        <span class="csv-indicator">📊</span>
                        <span class="csv-filename" id="csv-filename">Loading...</span>
                    </div>
                </div>
                <div class="chart-controls">
                    <button class="time-button active" onclick="loadChartData('1D')">1D</button>
                    <button class="time-button" onclick="loadChartData('7D')">7D</button>
                    <button class="time-button" onclick="loadChartData('1M')">1M</button>
                    <button class="refresh-button" onclick="createSnapshot()" title="Force Update Now">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="23 4 23 10 17 10"></polyline>
                            <polyline points="1 20 1 14 7 14"></polyline>
                            <path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>
                        </svg>
                    </button>
                </div>
                <div class="chart-container">
                    <canvas id="portfolio-chart"></canvas>
                </div>
            </div>

            <!-- Risk Metrics Cards (Corr vs BTC, Hit Rate, Max Drawdown) -->
            <div id="risk-cards-row" class="summary-cards">
                <div class="card" data-formula-key="risk-corr">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <h3>Corr vs BTC</h3>
                        <div>
                            <button type="button" class="time-button risk-toggle active" data-tf="90D">90D</button>
                            <button type="button" class="time-button risk-toggle" data-tf="SI">SI</button>
                        </div>
                    </div>
                    <div class="value" id="risk-corr">Loading...</div>
                </div>
                <div class="card" data-formula-key="risk-hit">
                    <h3>Hit Rate</h3>
                    <div class="value" id="risk-hit">Loading...</div>
                </div>
                <div class="card" data-formula-key="risk-mdd">
                    <h3>Max Drawdown</h3>
                    <div class="value" id="risk-mdd">Loading...</div>
                </div>
            </div>

            <!-- Top Performers -->
            <div class="top-performers">
                <div class="top-performers-card longs">
                    <h4>Top Long Performers</h4>
                    <div id="top-long-performers">
                        <div class="loading">Loading top long performers...</div>
                    </div>
                </div>
                <div class="top-performers-card shorts">
                    <h4>Top Short Performers</h4>
                    <div id="top-short-performers">
                        <div class="loading">Loading top short performers...</div>
                    </div>
                </div>
            </div>

            <!-- Positions Table -->
            <div class="positions-section">
                <h2>Long Positions</h2>
                <div class="positions-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Side</th>
                                <th class="sortable" data-table="long" data-key="weight">Weight %</th>
                                <th class="sortable" data-table="long" data-key="notional">Notional $</th>
                                <th>Entry Price</th>
                                <th>Mark Price</th>
                                <th class="sortable" data-table="long" data-key="pnl">Daily P&L $</th>
                                <th class="sortable" data-table="long" data-key="pnlPct">Daily P&L %</th>
                            </tr>
                        </thead>
                        <tbody id="long-positions">
                            <tr><td colspan="8" class="loading">Loading long positions...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="positions-section">
                <h2>Short Positions</h2>
                <div class="positions-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Side</th>
                                <th class="sortable" data-table="short" data-key="weight">Weight %</th>
                                <th class="sortable" data-table="short" data-key="notional">Notional $</th>
                                <th>Entry Price</th>
                                <th>Mark Price</th>
                                <th class="sortable" data-table="short" data-key="pnl">Daily P&L $</th>
                                <th class="sortable" data-table="short" data-key="pnlPct">Daily P&L %</th>
                            </tr>
                        </thead>
                        <tbody id="short-positions">
                            <tr><td colspan="8" class="loading">Loading short positions...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </main>
    <script>
        // Core state - single source of truth
        let DATA_PREFIX = localStorage.getItem('DATA_PREFIX') || '/signal-dashboard/data/';
        let currentSnapshot = {
            timestamp: null,
            portfolioValue: 1000000, // Start with $1M
            dailyPnL: 0,
            s3DailyPnL: null,
            s3TotalPnL: null,
            positions: [],
            baselinePrices: {},
            currentPrices: {}
        };

        const initialCapital = 1000000;
        // Global fallback for legacy code paths that may reference `referenceCapital`
        // Ensures no ReferenceError even if an older cached snippet uses the symbol
        // Local scopes can still shadow this with their own `const referenceCapital`
        var referenceCapital = initialCapital;
        if (typeof window !== 'undefined') {
            window.referenceCapital = initialCapital;
        }
        let currentPVPre = null; // Will be loaded from pre_execution.json
        let portfolioChart = null;

        // Update time display
        function updateTime() {
            const now = new Date();
            const utcTime = now.toISOString().substr(11, 8);
            const parisTime = new Date(now.getTime() + (2 * 60 * 60 * 1000)).toISOString().substr(11, 8);
            document.getElementById('current-time').textContent = `${utcTime} / ${parisTime} UTC / Paris`;
        }

        // Track current CSV to detect changes
        let currentCSVFilename = null;
        let currentCSVUploadedUtc = null;
        
        // Load current positions from latest.json (single source of truth)
        async function loadDailyCSV() {
            try {
                // Primary source: latest.json (authoritative for both strategies)
                const latestRes = await fetch(`${DATA_PREFIX}latest.json?cb=${Date.now()}`, { cache: 'no-store' });
                if (!latestRes.ok) {
                    console.log('⚠️ latest.json not found, falling back to pre_execution.json');
                }
                let csvFilename = null;
                let uploadedUtc = null;
                if (latestRes.ok) {
                    const latestText = await latestRes.text();
                    try {
                        const latest = JSON.parse(latestText.trim());
                        csvFilename = latest.filename || latest.csv_filename || latest.file || latest.csv;
                        uploadedUtc = latest.updated_utc || latest.updated || latest.timestamp_utc || null;
                    } catch (e) {
                        console.warn('⚠️ Could not parse latest.json, text=', latestText);
                    }
                }
                
                // Fallback: pre_execution.json if latest.json missing
                if (!csvFilename) {
                    try {
                        const preResponse = await fetch(`${DATA_PREFIX}pre_execution.json?cb=${Date.now()}`, { cache: 'no-store' });
                        if (preResponse.ok) {
                            const preText = await preResponse.text();
                            const preData = JSON.parse(preText.trim());
                            csvFilename = preData.csv_filename || preData.filename || null;
                            uploadedUtc = preData.timestamp_utc || preData.executed_at_utc || preData.pv_pre_time || uploadedUtc;
                        }
                    } catch (e) {
                        console.log('❌ Could not load from pre_execution.json fallback:', e);
                    }
                }
                
                if (!csvFilename) {
                    throw new Error('No CSV filename found in latest.json or pre_execution.json');
                }
                
                // Check if CSV has changed
                if (csvFilename === currentCSVFilename) {
                    console.log('CSV unchanged, skipping reload');
                    return false; // No change
                }
                
                console.log(`New CSV detected from latest.json: ${csvFilename} (was: ${currentCSVFilename})`);
                currentCSVFilename = csvFilename;
                currentCSVUploadedUtc = uploadedUtc;
                updateCSVFilename(csvFilename, uploadedUtc);
                
                // Load positions from the CSV file
                const portfolioResponse = await fetch(`${DATA_PREFIX}${csvFilename}`);
                const portfolioCsv = await portfolioResponse.text();
                const portfolioLines = portfolioCsv.split('\n');
                const portfolioHeaders = portfolioLines[0].split(',');
                
                const positions = [];
                for (let i = 1; i < portfolioLines.length; i++) {
                    if (portfolioLines[i].trim()) {
                        const values = portfolioLines[i].split(',');
                        const position = {};
                        portfolioHeaders.forEach((header, index) => {
                            position[header.trim()] = values[index] ? values[index].trim() : '';
                        });
                        positions.push(position);
                    }
                }
                
                console.log(`Loaded ${positions.length} positions from ${csvFilename}`);
                
                // Set baseline prices (current market prices at CSV execution)
                const baselinePrices = await fetchBaselinePrices(positions);
                
                // Update current snapshot
                currentSnapshot.positions = positions;
                currentSnapshot.baselinePrices = baselinePrices;
                console.log('🔍 DEBUG: Loaded positions count:', positions.length);
                console.log('🔍 DEBUG: First 3 positions:', positions.slice(0, 3));
                currentSnapshot.dailyPnL = 0; // Reset daily P&L
                
                console.log('Daily CSV loaded, baseline set, Daily P&L reset to 0');
                return true; // CSV changed
                
            } catch (error) {
                console.error('Error loading daily CSV:', error);
                return false;
            }
        }

        // Load baseline prices from daily_baseline.json
        async function fetchBaselinePrices(positions) {
            try {
                const response = await fetch(`${DATA_PREFIX}daily_baseline.json`, { cache: 'no-store' });
                const baseline = await response.json();
                return baseline.prices || {};
            } catch (error) {
                console.error('Error loading baseline prices:', error);
                return {};
            }
        }
        
        // Load PV_pre from pre_execution.json for accurate percentage calculations
        async function loadPVPre() {
            try {
                console.log('🔍 Loading PV_pre from pre_execution.json...');
                const response = await fetch(`${DATA_PREFIX}pre_execution.json`);
                if (response.ok) {
                    const data = await response.json();
                    const pvPre = parseFloat(data.pv_pre);
                    if (pvPre && pvPre > 0) {
                        currentPVPre = pvPre;
                        console.log(`📊 Loaded PV_pre: $${pvPre.toFixed(2)}`);
                        return pvPre;
                    } else {
                        console.log('⚠️ Invalid PV_pre in pre_execution.json, using initial capital');
                        return initialCapital;
                    }
                } else {
                    console.log('⚠️ No pre_execution.json available, using initial capital');
                    return initialCapital;
                }
            } catch (error) {
                console.error('Error loading PV_pre:', error);
                return initialCapital; // Fallback to initial capital
            }
        }

        // Load synchronized calculation snapshot for consistency
        async function fetchSynchronizedSnapshot() {
            try {
                console.log('🔍 Loading synchronized calculation snapshot...');
                const response = await fetch(`${DATA_PREFIX}calculation_snapshot.json`);
                if (response.ok) {
                    const snapshot = await response.json();
                    console.log('📊 Using synchronized snapshot for consistency');
                    return snapshot;
                }
            } catch (error) {
                console.log('⚠️ Synchronized snapshot not available, using individual sources');
            }
            return null;
        }

        // Load current mark prices from S3 latest_prices.json
        async function fetchCurrentPrices(positions) {
            try {
                console.log('🔍 Loading current prices from S3 latest_prices.json...');
                const cacheBuster = new Date().getTime();
                const response = await fetch(`${DATA_PREFIX}latest_prices.json?cb=${cacheBuster}`, {
                    cache: 'no-store'
                });
                if (!response.ok) return {};
                const data = await response.json();
                const prices = data.prices || {};
                const currentPrices = {};
                const symbols = positions.map(p => (p.ticker || p.ric || p.internal_code).replace('_', ''));
                symbols.forEach(symbol => {
                    const price = prices[symbol];
                    currentPrices[symbol] = (price !== undefined && price !== null) ? parseFloat(price) : null;
                });
                console.log(`📊 Loaded ${Object.keys(currentPrices).length}/${symbols.length} prices from S3`);
                return currentPrices;
            } catch (error) {
                console.error('Error loading current prices from S3:', error);
                return {};
            }
        }

        // Create new snapshot using S3 data as single source of truth
        async function createSnapshot() {
            console.log('🔄 Creating new snapshot...', new Date().toISOString());
            console.log('📊 Using S3 logs as single source of truth for all calculations');
            
            // Load latest S3 data first
            try {
                // Add cache-busting parameter to force fresh data
                const cacheBuster = new Date().getTime();
                const response = await fetch(`${DATA_PREFIX}portfolio_value_log.jsonl?cb=${cacheBuster}`, {
                    cache: 'no-store'
                });
                if (response.ok) {
                    const text = await response.text();
                    const lines = text.trim().split('\n').filter(line => line.trim());
                    if (lines.length > 0) {
                        const latestEntry = JSON.parse(lines[lines.length - 1]);
                        
                        console.log('📊 Latest S3 entry:', latestEntry);
                        
                        // Use S3 data as authoritative source
                        currentSnapshot.timestamp = new Date(latestEntry.timestamp);
                        currentSnapshot.portfolioValue = latestEntry.portfolio_value;
                        currentSnapshot.dailyPnL = latestEntry.daily_pnl;
                        currentSnapshot.s3DailyPnL = latestEntry.daily_pnl;
                        currentSnapshot.s3TotalPnL = latestEntry.total_pnl;
                        
                        // Use audit data for Long/Short breakdown
                        if (latestEntry.audit) {
                            currentSnapshot.longPnL = latestEntry.audit.long_pnl;
                            currentSnapshot.shortPnL = latestEntry.audit.short_pnl;
                            console.log('📊 S3 Long P&L:', latestEntry.audit.long_pnl);
                            console.log('📊 S3 Short P&L:', latestEntry.audit.short_pnl);
                            console.log('📊 S3 Validation:', latestEntry.audit.validation_long_plus_short);
                        }
                        
                        // Ensure mark prices are available for the table/UI
                        if (currentSnapshot.positions && currentSnapshot.positions.length > 0) {
                            try {
                                currentSnapshot.currentPrices = await fetchCurrentPrices(currentSnapshot.positions);
                            } catch (e) {
                                console.log('⚠️ Failed to load current prices for table rendering:', e);
                            }
                        }

                        // Update UI with S3 data (plus fresh marks if loaded)
                        updateUI();
                        return;
                    }
                }
            } catch (error) {
                console.log('⚠️ Could not load S3 data, falling back to calculation');
            }
            
            // If we have S3 data, don't do additional calculations - just update UI
            if (currentSnapshot.longPnL !== undefined && currentSnapshot.shortPnL !== undefined) {
                console.log('📊 S3 data loaded successfully, skipping calculations');
                updateUI();
                return;
            }
            
            console.log('🔍 DEBUG: currentSnapshot.positions.length =', currentSnapshot.positions.length);
            console.log('🔍 DEBUG: currentSnapshot.baselinePrices keys =', Object.keys(currentSnapshot.baselinePrices || {}));
            console.log('🔍 DEBUG: currentSnapshot.currentPrices keys =', Object.keys(currentSnapshot.currentPrices || {}));
            
            if (currentSnapshot.positions.length === 0) {
                console.log('❌ No positions loaded yet');
                return;
            }
            
            // Load current prices from S3
            const currentPrices = await fetchCurrentPrices(currentSnapshot.positions);
            console.log('🔍 DEBUG: Fetched currentPrices keys =', Object.keys(currentPrices || {}));
            
            // Calculate Daily P&L (vs baseline)
            let dailyPnL = 0;
            let calculatedPositions = 0;
            console.log('🔍 Calculating Daily P&L...');
            
            currentSnapshot.positions.forEach((position, index) => {
                const symbol = (position.ticker || position.ric || position.internal_code).replace('_', '');
                const baselinePrice = currentSnapshot.baselinePrices[symbol];
                const currentPrice = currentPrices[symbol];
                const notional = parseFloat(position.target_notional || 0);
                const side = parseFloat(position.target_contracts) > 0 ? 1 : -1;
                
                console.log(`🔍 DEBUG Position ${index}: ${symbol}`, {
                    baselinePrice,
                    currentPrice,
                    notional,
                    side,
                    hasBaseline: !!baselinePrice,
                    hasCurrent: !!currentPrice,
                    target_contracts: position.target_contracts,
                    target_notional: position.target_notional
                });
                
                if (baselinePrice && currentPrice) {
                    const contracts = parseFloat(position.target_contracts);
                    const notional = parseFloat(position.target_notional || 0);
                    // FIXED: Use same calculation as table: percentage change * notional
                    const pnl = side * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    console.log(`🔍 CALCULATION FIX: ${symbol} = ${side} * (${currentPrice} - ${baselinePrice}) / ${baselinePrice} * ${Math.abs(notional)} = ${pnl.toFixed(2)}`);
                    dailyPnL += pnl;
                    calculatedPositions++;
                    
                    console.log(`🔍 ${symbol}: baseline=${baselinePrice}, current=${currentPrice}, side=${side}, notional=${Math.abs(notional)}, contracts=${contracts}, pnl=${pnl.toFixed(2)}`);
                    
                    // Log all positions, not just first 3
                    if (calculatedPositions <= 5) {
                        const priceDiff = currentPrice - baselinePrice;
                        const priceChangePercent = priceDiff / baselinePrice;
                        const calculatedPnl = side * priceChangePercent * Math.abs(notional);
                        
                        console.log(`🔍 FULL DEBUG ${symbol}:`, {
                            baselinePrice,
                            currentPrice,
                            priceDiff,
                            priceChangePercent: (priceChangePercent * 100).toFixed(4) + '%',
                            side,
                            notional: Math.abs(notional),
                            calculatedPnl: calculatedPnl.toFixed(2),
                            actualPnl: pnl.toFixed(2),
                            match: Math.abs(calculatedPnl - pnl) < 0.01
                        });
                    }
                } else {
                    console.log(`⚠️ Missing data for ${symbol}: baseline=${!!baselinePrice}, current=${!!currentPrice}`);
                }
            });
            
            console.log(`📊 Calculated ${calculatedPositions} positions, total P&L: ${dailyPnL.toFixed(2)}`);
            console.log('🔍 DEBUG: Final dailyPnL =', dailyPnL);
            console.log('🔍 DEBUG: calculatedPositions =', calculatedPositions);
            
            // Update snapshot
            currentSnapshot.timestamp = new Date();
            currentSnapshot.currentPrices = currentPrices;
            currentSnapshot.dailyPnL = dailyPnL;
            
            console.log('🔍 DEBUG: Updated currentSnapshot.dailyPnL =', currentSnapshot.dailyPnL);
            
            // Only set portfolio value if we don't have S3 data yet
            // If we have S3 data, keep the real portfolio value from S3 logs
            if (!currentSnapshot.portfolioValue || currentSnapshot.portfolioValue === initialCapital) {
                currentSnapshot.portfolioValue = initialCapital + dailyPnL;
                console.log('📊 Using calculated Portfolio Value (no S3 data yet)');
            } else {
                console.log(`📊 Keeping S3 Portfolio Value: $${currentSnapshot.portfolioValue.toFixed(2)}`);
            }
            
            // Update UI with this snapshot
            updateUI();
            
            // Log PV for chart
            logPortfolioValue();
        }

        // --- BTC CSV fetch and strategy daily returns alignment ---
        async function fetchBtcDailyReturnsFromS3(){
            try {
                const r = await fetch('/signal-dashboard/benchmarks/btc_daily_returns.csv?cb=' + Date.now(), { cache:'no-store' });
                if (!r.ok) return [];
                const text = await r.text();
                const lines = text.trim().split('\n');
                const hdr = lines.shift().split(',').map(h=>h.trim().toLowerCase());
                const di = hdr.indexOf('date');
                const pi = hdr.indexOf('performance');
                return lines.filter(Boolean).map(line=>{
                    const parts = line.split(',');
                    return { Date: parts[di], Performance: parseFloat(parts[pi]) };
                }).filter(x=>x.Date && Number.isFinite(x.Performance));
            } catch(e){ console.error('btc fetch fail', e); return []; }
        }

        function computeDailyReturnsFromPVJsonlText(jsonlText){
            const lines = (jsonlText||'').trim().split('\n').filter(Boolean);
            const data = lines.map(l=>{ try { return JSON.parse(l); } catch(e){ return null; } }).filter(Boolean);
            const byDay = new Map();
            data.forEach(pt=>{
                const ts = pt.timestamp || pt.time || pt.t; if (!ts) return;
                const d = new Date(ts); const day = d.toISOString().slice(0,10);
                const arr = byDay.get(day) || []; arr.push(pt); byDay.set(day, arr);
            });
            const out = [];
            for (const [day, arr] of byDay.entries()){
                const sorted = arr.slice().sort((a,b)=>new Date(a.timestamp)-new Date(b.timestamp));
                const first = sorted[0]; const last = sorted[sorted.length-1];
                const pv0 = first.portfolio_value || first.portfolioValue;
                const pv1 = last.portfolio_value || last.portfolioValue;
                if (typeof pv0 === 'number' && pv0>0 && typeof pv1 === 'number'){
                    const perf = (pv1 - pv0) / pv0 * 100; // percent
                    out.push({ Date: day, Performance: Number(perf.toFixed(2)) });
                }
            }
            return out.sort((a,b)=> a.Date.localeCompare(b.Date));
        }

        // --- Metrics math helpers ---
        function pearson(x, y){
            const n = Math.min(x.length, y.length);
            if (n === 0) return NaN;
            let sx=0, sy=0, sxx=0, syy=0, sxy=0;
            for (let i=0;i<n;i++){ const a=x[i], b=y[i]; sx+=a; sy+=b; sxx+=a*a; syy+=b*b; sxy+=a*b; }
            const mx = sx/n, my = sy/n;
            const cov = sxy/n - mx*my;
            const vx = sxx/n - mx*mx;
            const vy = syy/n - my*my;
            const denom = Math.sqrt(vx*vy);
            return denom>0 ? (cov/denom) : NaN;
        }
        function hitRate(returnsPct){
            if (!returnsPct || returnsPct.length===0) return 0;
            const wins = returnsPct.filter(v=> v>0).length;
            return wins / returnsPct.length * 100;
        }
        function maxDrawdown(returnsPct){
            const r = (returnsPct||[]).map(v=> v/100);
            let peak = 1, trough = 1, mdd = 0, eq = 1;
            for (const rr of r){
                eq *= (1+rr);
                if (eq>peak){ peak = eq; trough = eq; }
                if (eq<trough){ trough = eq; }
                const dd = (trough/peak - 1);
                if (dd < mdd) mdd = dd;
            }
            return mdd*100;
        }

        async function updateRiskCards(scope){
            try {
                // Strategy daily from PV log (strategy-aware via DATA_PREFIX)
                const res = await fetch(`${DATA_PREFIX}portfolio_value_log.jsonl?cb=${Date.now()}`, { cache: 'no-store' });
                if (!res.ok){
                    ['risk-corr','risk-hit','risk-mdd'].forEach(id=>{ const el = document.getElementById(id); if (el) el.textContent = 'N/A'; });
                    return;
                }
                const pvText = await res.text();
                const stratDaily = computeDailyReturnsFromPVJsonlText(pvText).map(x=>({ Date:x.Date, Performance:x.Performance }));

                // BTC benchmark (single path)
                const btcDaily = await fetchBtcDailyReturnsFromS3();
                const byDate = new Map(btcDaily.map(r=> [r.Date, r.Performance]));
                let joined = stratDaily.filter(r=> byDate.has(r.Date)).map(r=> ({ d:r.Date, s:r.Performance, b:byDate.get(r.Date) }));
                if (scope === '90D' && joined.length>90) joined = joined.slice(-90);

                const s = joined.map(x=> x.s);
                const b = joined.map(x=> x.b);
                const corr = pearson(s, b);
                const hr = hitRate(s);
                const mdd = maxDrawdown(s);
                const fmt = (v, dp=2)=> (Number.isFinite(v)? v.toFixed(dp) : 'N/A');
                const corrEl = document.getElementById('risk-corr'); if (corrEl) corrEl.textContent = (Number.isFinite(corr)? fmt(corr,2) : 'N/A');
                const hitEl = document.getElementById('risk-hit'); if (hitEl) hitEl.textContent = `${fmt(hr,1)}%`;
                const mddEl = document.getElementById('risk-mdd'); if (mddEl) mddEl.textContent = `${fmt(mdd,2)}%`;
            } catch (e){
                console.error('risk cards error', e);
            }
        }

        // Update UI with current snapshot
        function updateUI() {
            const snapshot = currentSnapshot;
            console.log('🔍 DEBUG: updateUI called');
            console.log('🔍 DEBUG: currentSnapshot =', currentSnapshot);
            console.log('🔍 DEBUG: currentSnapshot.dailyPnL =', currentSnapshot?.dailyPnL);
            console.log('🔍 DEBUG: currentSnapshot.portfolioValue =', currentSnapshot?.portfolioValue);
            
            console.log('🔄 Updating UI with snapshot:', {
                timestamp: snapshot.timestamp?.toISOString(),
                portfolioValue: snapshot.portfolioValue,
                dailyPnL: snapshot.dailyPnL,
                currentPricesCount: Object.keys(snapshot.currentPrices || {}).length
            });
            console.log('🔄 UI Update timestamp:', new Date().toISOString());
            
            // Portfolio Value
            document.getElementById('portfolio-value').textContent = formatCurrency(snapshot.portfolioValue);
            const timeStr = snapshot.timestamp ? snapshot.timestamp.toISOString().substr(11, 8) + ' UTC' : 'Loading...';
            document.getElementById('portfolio-time').textContent = timeStr;
            
            // Add a visual indicator that updates are happening
            const timeElement = document.getElementById('portfolio-time');
            timeElement.style.backgroundColor = '#28a745';
            timeElement.style.color = 'white';
            timeElement.style.padding = '2px 6px';
            timeElement.style.borderRadius = '3px';
            setTimeout(() => {
                timeElement.style.backgroundColor = '';
                timeElement.style.color = '';
                timeElement.style.padding = '';
                timeElement.style.borderRadius = '';
            }, 1000);
            
            // Use PV_pre for percentage calculations if available, otherwise use initialCapital
            const referenceCapital = currentPVPre || initialCapital;

            // Prefer S3 daily P&L (same cadence as Total from S3). Fallback to live per-tick calc only if S3 not available
            const cardDaily = (snapshot.s3DailyPnL !== null && snapshot.s3DailyPnL !== undefined)
                ? snapshot.s3DailyPnL
                : (typeof snapshot.dailyPnL === 'number' ? snapshot.dailyPnL : 0);
            const cardTotal = (snapshot.s3TotalPnL !== null && snapshot.s3TotalPnL !== undefined)
                ? snapshot.s3TotalPnL
                : (snapshot.portfolioValue - initialCapital);

            console.log('🔍 DEBUG: Setting Daily P&L to:', cardDaily);
            console.log('🔍 DEBUG: Calculated Daily P&L:', snapshot.dailyPnL);
            console.log('🔍 DEBUG: S3 Daily P&L:', snapshot.s3DailyPnL);
            console.log('🔍 DEBUG: Using reference capital for %:', referenceCapital);
            document.getElementById('daily-pnl').textContent = formatCurrency(cardDaily);
            document.getElementById('daily-pnl').className = `value ${cardDaily >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('daily-pnl-percent').textContent = `(${formatPercentage((cardDaily / referenceCapital) * 100)})`;
            document.getElementById('daily-pnl-percent').className = `percentage ${cardDaily >= 0 ? 'positive' : 'negative'}`;

            // Total P&L Since Inception (prefer S3 last record)
            document.getElementById('total-pnl').textContent = formatCurrency(cardTotal);
            document.getElementById('total-pnl').className = `value ${cardTotal >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('total-pnl-percent').textContent = `(${formatPercentage((cardTotal / referenceCapital) * 100)})`;
            document.getElementById('total-pnl-percent').className = `percentage ${cardTotal >= 0 ? 'positive' : 'negative'}`;
            
            // Update risk cards if present (use last selected scope or default 90D)
            const hasRisk = document.getElementById('risk-cards-row');
            if (hasRisk) {
                const active = document.querySelector('.risk-toggle.active');
                const scope = active ? active.getAttribute('data-tf') : '90D';
                updateRiskCards(scope);
            }

            // Use S3 Long/Short P&L if available, otherwise calculate
            let longPnL, shortPnL, longCount, shortCount, longNotional, shortNotional;
            
            if (snapshot.longPnL !== undefined && snapshot.shortPnL !== undefined) {
                // Use S3 audit data (authoritative)
                longPnL = snapshot.longPnL;
                shortPnL = snapshot.shortPnL;
                console.log('📊 Using S3 Long/Short P&L values');
                
                // Calculate notionals and counts from positions
                const longShortMetrics = calculateLongShortMetrics(snapshot.positions);
                longNotional = longShortMetrics.longNotional;
                shortNotional = longShortMetrics.shortNotional;
                longCount = longShortMetrics.longCount;
                shortCount = longShortMetrics.shortCount;
            } else {
                // Fallback to calculation
                const longShortMetrics = calculateLongShortMetrics(snapshot.positions);
                longPnL = longShortMetrics.longPnL;
                shortPnL = longShortMetrics.shortPnL;
                longNotional = longShortMetrics.longNotional;
                shortNotional = longShortMetrics.shortNotional;
                longCount = longShortMetrics.longCount;
                shortCount = longShortMetrics.shortCount;
                console.log('📊 Using calculated Long/Short P&L values');
            }
            
            // Validation: Long + Short P&L should equal Daily P&L
            const longShortTotal = longPnL + shortPnL;
            console.log('🔍 VALIDATION: Long+Short P&L =', longShortTotal.toFixed(2), 'vs Daily P&L =', snapshot.dailyPnL.toFixed(2), 'Diff =', (longShortTotal - snapshot.dailyPnL).toFixed(2));
            console.log('🔍 VALIDATION: Card Daily =', (cardDaily ?? 0).toFixed(2), 'vs Rows Daily =', snapshot.dailyPnL.toFixed(2), 'Diff =', ((cardDaily ?? 0) - snapshot.dailyPnL).toFixed(2));
            
            // Long Positions
            document.getElementById('long-notional').textContent = formatCurrency(longNotional);
            document.getElementById('long-pnl-percent').textContent = `(${formatCurrency(longPnL)})`;
            document.getElementById('long-pnl-percent').className = `percentage ${longPnL >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('long-count').textContent = `${longCount} positions`;
            
            // Short Positions
            document.getElementById('short-notional').textContent = formatCurrency(shortNotional);
            document.getElementById('short-pnl-percent').textContent = `(${formatCurrency(shortPnL)})`;
            document.getElementById('short-pnl-percent').className = `percentage ${shortPnL >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('short-count').textContent = `${shortCount} positions`;
            
            // Update total positions count (count only non-zero contracts)
            const totalPositions = (longCount || 0) + (shortCount || 0);
            document.getElementById('total-positions-count').textContent = totalPositions.toString();
            
            // Update delta progress bar
            createDeltaProgressBar();
            
            // Update top performers
            updateTopPerformers();
            
            // Update table
            updatePositionsTable(referenceCapital);

            // Update Avg P&L per Trade (positions-based, S3-driven)
            try {
                const positionsCount = parseInt(document.getElementById('total-positions-count').textContent || '0', 10) || 0;
                const pnlForAvg = (typeof cardDaily === 'number') ? cardDaily : 0;
                const avgPerTrade = positionsCount > 0 ? (pnlForAvg / positionsCount) : null;
                const avgEl = document.getElementById('avg-pnl-per-trade');
                const avgMetaEl = document.getElementById('avg-pnl-trade-meta');
                if (avgEl) avgEl.textContent = (avgPerTrade !== null) ? formatCurrency(avgPerTrade) : 'N/A';
                if (avgMetaEl) avgMetaEl.textContent = `${positionsCount} position${positionsCount === 1 ? '' : 's'}`;
            } catch (e) {
                console.log('⚠️ Failed to update Avg P&L per Trade:', e);
            }
        }

        // Update positions table
        function updatePositionsTable(referenceCapital) {
            const snapshot = currentSnapshot;
            if (snapshot.positions.length === 0) return;
            
            const longPositions = snapshot.positions.filter(p => parseFloat(p.target_contracts) > 0);
            const shortPositions = snapshot.positions.filter(p => parseFloat(p.target_contracts) < 0);
            
            populatePositionTable('long-positions', longPositions, snapshot, referenceCapital);
            populatePositionTable('short-positions', shortPositions, snapshot, referenceCapital);
        }

        function populatePositionTable(tableId, positions, snapshot, referenceCapital) {
            console.log('🔍 populatePositionTable called with refCap fix, positions:', positions.length);
            const tbody = document.getElementById(tableId);
            tbody.innerHTML = '';

            // Use fixed reference capital of $1,000,000 for calculations
            const refCap = initialCapital;
            console.log('🔍 Using fixed refCap:', refCap);
            
            // Sort logic
            const tableSortState = window.tableSortState || (window.tableSortState = { long: {key:null,dir:1}, short: {key:null,dir:1} });
            const tableKind = (tableId === 'long-positions') ? 'long' : (tableId === 'short-positions') ? 'short' : null;
            if (tableKind && tableSortState[tableKind].key) {
                const { key, dir } = tableSortState[tableKind];
                positions = positions.slice().sort((a,b)=>{
                    const getDerived = (p) => {
                        const symbol = p.ticker || p.ric || p.internal_code || 'N/A';
                        const bin = symbol.replace('_','');
                        const baselinePrice = snapshot.baselinePrices[bin];
                        const currentPrice = snapshot.currentPrices[bin];
                        const notional = Math.abs(parseFloat(p.target_notional || 0));
                        const weight = notional / refCap * 100;
                        let pnl = 0, pnlPct = 0;
                        if (baselinePrice && currentPrice) {
                            const sideMult = parseFloat(p.target_contracts) > 0 ? 1 : -1;
                            pnl = sideMult * (currentPrice - baselinePrice) / baselinePrice * notional;
                            pnlPct = sideMult * (currentPrice - baselinePrice) / baselinePrice * 100;
                        }
                        return { weight, notional, pnl, pnlPct };
                    };
                    const ad = getDerived(a), bd = getDerived(b);
                    const va = ad[key];
                    const vb = bd[key];
                    return (va === vb ? 0 : (va > vb ? 1 : -1)) * dir;
                });
            }
            
            positions.forEach(position => {
                const symbol = position.ticker || position.ric || position.internal_code || 'N/A';
                const binanceSymbol = symbol.replace('_', '');
                // Removed entry-based metrics by request
                const entryPrice = snapshot.baselinePrices[binanceSymbol];
                const baselinePrice = snapshot.baselinePrices[binanceSymbol];
                const currentPrice = snapshot.currentPrices[binanceSymbol];
                const notional = parseFloat(position.target_notional || 0);
                const side = parseFloat(position.target_contracts) > 0 ? 'LONG' : 'SHORT';
                const weight = (Math.abs(notional) / refCap) * 100;
                
                // Daily P&L (vs baseline)
                let dailyPnl = 0;
                let dailyPnlPercent = 0;
                // Since-entry removed
                
                if (baselinePrice && currentPrice) {
                    const sideMultiplier = parseFloat(position.target_contracts) > 0 ? 1 : -1;
                    dailyPnl = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    dailyPnlPercent = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * 100;
                }

                // no-op
                
                const row = document.createElement('tr');
                row.className = 'position-row';
                
                // Add winning position highlight
                if (dailyPnl > 0) {
                    row.classList.add('winning');
                }
                
                // Add top performer highlight (top 3 by absolute P&L)
                const isTopPerformer = checkIfTopPerformer(symbol, dailyPnl, side);
                if (isTopPerformer) {
                    row.classList.add('top-performer');
                }
                
                row.innerHTML = `
                    <td class="symbol" data-symbol="${symbol}">${symbol}</td>
                    <td class="${side === 'LONG' ? 'side-long' : 'side-short'}">${side}</td>
                    <td>${weight.toFixed(2)}%</td>
                    <td>${formatCurrency(Math.abs(notional))}</td>
                    <td>${entryPrice ? formatCurrency(entryPrice) : '-'}</td>
                    <td>${currentPrice ? formatCurrency(currentPrice) : 'Loading...'}</td>
                    <td class="${dailyPnl >= 0 ? 'positive' : 'negative'}">${formatCurrency(dailyPnl)}</td>
                    <td class="${dailyPnlPercent >= 0 ? 'positive' : 'negative'}">${dailyPnlPercent.toFixed(2)}%</td>
                `;
                tbody.appendChild(row);
            });
        }

        // PV logging to S3 for persistence
        let pvLogs = [];
        
        async function logPortfolioValue() {
            const logEntry = {
                timestamp: currentSnapshot.timestamp.toISOString(),
                portfolioValue: currentSnapshot.portfolioValue,
                dailyPnL: currentSnapshot.dailyPnL
            };
            
            console.log('📊 Logging PV:', logEntry);
            
            // Store in browser memory for immediate chart update
            pvLogs.push(logEntry);
            
            // Keep only last 24 hours in memory
            const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
            pvLogs = pvLogs.filter(log => new Date(log.timestamp) > oneDayAgo);
            
            console.log(`📈 PV Logs: ${pvLogs.length} entries, latest: ${logEntry.portfolioValue}`);
            // Don't update chart here - let the S3 data stay visible
            // updateChart();
        }

        // Load historical PV data from S3 portfolio_value_log.jsonl
        async function loadHistoricalPVData(timeframe) {
            try {
                const cacheBuster = new Date().getTime();
                const response = await fetch(`${DATA_PREFIX}portfolio_value_log.jsonl?cb=${cacheBuster}`, {
                    cache: 'no-store'
                });
                if (!response.ok) {
                    console.log('No S3 PV data available yet');
                    return [];
                }
                
                const text = await response.text();
                console.log('📄 Raw S3 text length:', text.length);
                
                const lines = text.trim().split('\n').filter(line => line.trim());
                console.log('📄 S3 lines count:', lines.length);
                
                const data = lines.map(line => {
                    try {
                        return JSON.parse(line.trim());
                    } catch (e) {
                        console.error('❌ Error parsing line:', line);
                        return null;
                    }
                }).filter(item => item !== null);
                
                console.log(`📊 Loaded ${data.length} PV points from S3`);
                console.log('📊 First data point:', data[0]);
                console.log('📊 Last data point:', data[data.length - 1]);

                // Update cards from last S3 record
                try {
                    const last = data[data.length - 1] || {};
                    if (last && typeof last.portfolio_value === 'number') {
                        currentSnapshot.portfolioValue = last.portfolio_value;
                    }
                    currentSnapshot.s3DailyPnL = (typeof last.daily_pnl === 'number') ? last.daily_pnl : null;
                    currentSnapshot.s3TotalPnL = (typeof last.total_pnl === 'number') ? last.total_pnl : null;
                } catch (e) {
                    console.warn('⚠️ Failed to update cards from S3 last record', e);
                }
                
                // Filter by timeframe - be more aggressive about filtering
                const now = new Date();
                let cutoffDate;
                switch(timeframe) {
                    case '1D':
                        cutoffDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                        break;
                    case '7D':
                        cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        break;
                    case '1M':
                        cutoffDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        break;
                    default:
                        cutoffDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                }
                
                const filteredData = data.filter(log => {
                    const logDate = new Date(log.timestamp);
                    return logDate >= cutoffDate && logDate <= now;
                });
                
                console.log(`📊 Filtered to ${filteredData.length} points for ${timeframe} timeframe`);
                console.log(`📊 Cutoff date: ${cutoffDate.toISOString()}`);
                console.log(`📊 Now: ${now.toISOString()}`);
                console.log(`📊 Data range: ${filteredData[0]?.timestamp} to ${filteredData[filteredData.length-1]?.timestamp}`);
                
                // Return filtered data sorted by timestamp
                return filteredData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
            } catch (error) {
                console.error('Error loading historical PV data:', error);
                return [];
            }
        }
        
        // Load chart data for different timeframes
        async function loadChartData(timeframe) {
            // Update button states
            document.querySelectorAll('.time-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[onclick="loadChartData('${timeframe}')"]`).classList.add('active');
            
            // Load historical data
            const historicalData = await loadHistoricalPVData(timeframe);
            
            // Use historical data directly (it's already the full dataset from S3)
            updateChart(historicalData, timeframe);
        }
        
        // Update chart with data
        function updateChart(data = pvLogs, timeframe = '1D') {
            // Always show chart, even with no data
            if (data.length === 0) {
                console.log('📊 No data available, showing empty chart');
                data = [{
                    timestamp: new Date().toISOString(),
                    portfolioValue: initialCapital,
                    daily_pnl: 0,
                    total_pnl: 0
                }];
            }
            
            console.log(`📊 Updating chart with ${data.length} data points`);
            
            const ctx = document.getElementById('portfolio-chart').getContext('2d');
            
            // Properly destroy existing chart
            if (portfolioChart) {
                portfolioChart.destroy();
                portfolioChart = null;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            try {
                // Create beautiful gradients
                const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
                gradient.addColorStop(0, 'rgba(102, 126, 234, 0.4)');
                gradient.addColorStop(0.5, 'rgba(102, 126, 234, 0.15)');
                gradient.addColorStop(1, 'rgba(102, 126, 234, 0.05)');

                // Create border gradient
                const borderGradient = ctx.createLinearGradient(0, 0, ctx.canvas.width, 0);
                borderGradient.addColorStop(0, 'rgba(102, 126, 234, 1)');
                borderGradient.addColorStop(0.5, 'rgba(118, 75, 162, 0.8)');
                borderGradient.addColorStop(1, 'rgba(102, 126, 234, 1)');
            
            portfolioChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Portfolio Value',
                            data: data.map(log => ({
                                x: new Date(log.timestamp),
                                y: log.portfolio_value || log.portfolioValue
                            })),
                            borderColor: borderGradient,
                            backgroundColor: gradient,
                            borderWidth: 3,
                            tension: 0.4,
                            fill: true,
                            pointRadius: 0,
                            pointHoverRadius: 8,
                            pointHoverBackgroundColor: 'rgba(255, 255, 255, 0.9)',
                            pointHoverBorderColor: 'rgba(102, 126, 234, 1)',
                            pointHoverBorderWidth: 3,
                            pointBackgroundColor: 'rgba(102, 126, 234, 0.8)',
                            pointBorderColor: 'rgba(255, 255, 255, 1)',
                            pointBorderWidth: 2,
                            shadowOffsetX: 0,
                            shadowOffsetY: 4,
                            shadowBlur: 12,
                            shadowColor: 'rgba(102, 126, 234, 0.3)'
                    }]
                },
                options: {
                    responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    usePointStyle: true,
                                    pointStyle: 'circle',
                                    padding: 20,
                                    font: {
                                        family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                        size: 13,
                                        weight: '600'
                                    },
                                    color: '#374151',
                                    boxWidth: 12,
                                    boxHeight: 12
                                }
                            },
                            tooltip: {
                                enabled: true,
                                backgroundColor: 'rgba(255, 255, 255, 0.98)',
                                titleColor: '#1f2937',
                                bodyColor: '#4b5563',
                                borderColor: 'rgba(102, 126, 234, 0.2)',
                                borderWidth: 1,
                                cornerRadius: 12,
                                displayColors: false,
                                titleFont: {
                                    family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                    size: 13,
                                    weight: '600'
                                },
                                bodyFont: {
                                    family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                    size: 12,
                                    weight: '500'
                                },
                                padding: 12,
                                caretSize: 6,
                                caretPadding: 8,
                                callbacks: {
                                    title: function(context) {
                                        const date = new Date(context[0].label);
                                        return date.toLocaleString('en-US', {
                                            weekday: 'short',
                                            month: 'short',
                                            day: 'numeric',
                                            hour: '2-digit',
                                            minute: '2-digit'
                                        });
                                    },
                                    label: function(context) {
                                        return `Portfolio: ${formatCurrency(context.parsed.y)}`;
                                    }
                                }
                            }
                        },
                    scales: {
                            x: {
                                type: 'time',
                                time: {
                                    displayFormats: (() => {
                                        switch(timeframe) {
                                            case '1D':
                                                return {
                                                    hour: 'HH:mm',
                                                    day: 'MMM dd'
                                                };
                                            case '7D':
                                                return {
                                                    day: 'MMM dd',
                                                    week: 'MMM dd'
                                                };
                                            case '1M':
                                                return {
                                                    day: 'MMM dd',
                                                    week: 'MMM dd',
                                                    month: 'MMM yyyy'
                                                };
                                            default:
                                                return {
                                                    hour: 'HH:mm',
                                                    day: 'MMM dd'
                                                };
                                        }
                                    })(),
                                    tooltipFormat: 'MMM dd HH:mm',
                                    unit: (() => {
                                        switch(timeframe) {
                                            case '1D': return 'hour';
                                            case '7D': return 'day';
                                            case '1M': return 'day';
                                            default: return 'hour';
                                        }
                                    })()
                                },
                                grid: {
                                    display: true,
                                    color: 'rgba(226, 232, 240, 0.6)',
                                    lineWidth: 1,
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#6b7280',
                                    font: {
                                        family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                        size: 11,
                                        weight: '500'
                                    },
                                    maxRotation: 45,
                                    minRotation: 0,
                                    padding: 8,
                                    maxTicksLimit: (() => {
                                        switch(timeframe) {
                                            case '1D': return 12;
                                            case '7D': return 7;
                                            case '1M': return 15;
                                            default: return 12;
                                        }
                                    })()
                                },
                                // Set explicit time boundaries based on timeframe
                                min: (() => {
                                    const now = new Date();
                                    switch(timeframe) {
                                        case '1D': 
                                            return new Date(now.getTime() - 24 * 60 * 60 * 1000);
                                        case '7D': 
                                            return new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                                        case '1M': 
                                            return new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                                        default: 
                                            return new Date(now.getTime() - 24 * 60 * 60 * 1000);
                                    }
                                })(),
                                max: new Date(),
                                border: {
                                    display: false
                                }
                            },
                        y: {
                            beginAtZero: false,
                                grid: {
                                    display: true,
                                    color: 'rgba(226, 232, 240, 0.6)',
                                    lineWidth: 1,
                                    drawBorder: false
                                },
                            ticks: {
                                    color: '#6b7280',
                                    font: {
                                        family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                        size: 11,
                                        weight: '500',
                                        variant: 'tabular-nums'
                                    },
                                    padding: 12,
                                callback: function(value) {
                                    return formatCurrency(value);
                                }
                                },
                                border: {
                                    display: false
                                }
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        animation: {
                            // Cinematic but responsive animation per timeframe
                            duration: (function(){
                                switch(timeframe){
                                    case '1D': return 900;
                                    case '7D': return 900;
                                    case '1M': return 700;
                                    default: return 900;
                                }
                            })(),
                            easing: 'easeInOutCubic',
                            delay: (context) => {
                                if (context.type !== 'data' || context.mode !== 'default') return 0;
                                const idx = context.dataIndex || 0;
                                if (timeframe === '1D') return Math.min(idx * 12, 400);    // subtle
                                if (timeframe === '7D') return Math.min(idx * 6, 500);     // gentle build
                                if (timeframe === '1M') return Math.min(idx * 4, 400);     // light
                                return 0;
                            }
                        },
                        elements: {
                            line: {
                                shadowOffsetX: 0,
                                shadowOffsetY: 4,
                                shadowBlur: 12,
                                shadowColor: 'rgba(102, 126, 234, 0.3)'
                            }
                    }
                }
            });
                
                console.log('📊 Beautiful chart updated successfully');
            } catch (error) {
                console.error('❌ Chart creation failed:', error);
                // Show a beautiful fallback message
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif';
                ctx.fillStyle = '#6b7280';
                ctx.fillText('Chart temporarily unavailable', 50, 50);
            }
        }

        // Delta Donut Chart
        let deltaDonutChart = null;
        
        function createDeltaProgressBar() {
            // Calculate portfolio delta using corrected formula
            const deltaData = calculatePortfolioDelta();
            const { netDelta, netDeltaPercent, grossExposure } = deltaData;
            
            // Update delta display
            document.getElementById('delta-value').textContent = formatCurrency(netDelta);
            document.getElementById('delta-percentage').textContent = `${Math.abs(netDeltaPercent).toFixed(1)}%`;
            
            // Calculate progress bar position (0-100%)
            // Convert -50% to +50% delta range to 0-100% progress bar
            const normalizedDelta = Math.max(-50, Math.min(50, netDeltaPercent));
            const progressPosition = ((normalizedDelta + 50) / 100) * 100; // 0-100%
            
            // Update progress bar fill
            const progressFill = document.getElementById('delta-progress-fill');
            const progressIndicator = document.getElementById('delta-progress-indicator');
            
            // Set fill width based on long/short balance
            const longPercentage = (deltaData.totalLongNotional / grossExposure) * 100;
            const shortPercentage = (deltaData.totalShortNotional / grossExposure) * 100;
            
            // Progress bar shows long exposure (from left)
            progressFill.style.width = `${longPercentage}%`;
            progressFill.style.backgroundColor = netDeltaPercent >= 0 ? 
                'rgba(102, 126, 234, 0.3)' : 'rgba(239, 68, 68, 0.3)';
            
            // Indicator shows net delta position
            progressIndicator.style.left = `${progressPosition}%`;
            progressIndicator.style.backgroundColor = netDeltaPercent >= 0 ? 
                'rgba(102, 126, 234, 1)' : 'rgba(239, 68, 68, 1)';
        }
        
        function calculatePortfolioDelta() {
            if (!currentSnapshot.positions) return { netDelta: 0, netDeltaPercent: 0, grossExposure: 0 };
            
            let totalLongNotional = 0;
            let totalShortNotional = 0;
            let totalNotional = 0;
            
            currentSnapshot.positions.forEach(position => {
                const notional = parseFloat(position.target_notional);
                const contracts = parseFloat(position.target_contracts);
                
                if (notional && contracts) {
                    totalNotional += Math.abs(notional);
                    
                    if (contracts > 0) {
                        // Long position
                        totalLongNotional += Math.abs(notional);
                    } else {
                        // Short position
                        totalShortNotional += Math.abs(notional);
                    }
                }
            });
            
            const netDelta = totalLongNotional - totalShortNotional;
            const netDeltaPercent = totalNotional > 0 ? (netDelta / totalNotional) * 100 : 0;
            
            return {
                netDelta,
                netDeltaPercent,
                grossExposure: totalNotional,
                totalLongNotional,
                totalShortNotional
            };
        }
        
        function calculateLongShortMetrics(positions) {
            console.log('🔍 calculateLongShortMetrics called with:', {
                positions: positions ? positions.length : 0,
                currentPrices: currentSnapshot.currentPrices ? Object.keys(currentSnapshot.currentPrices).length : 0,
                baselinePrices: currentSnapshot.baselinePrices ? Object.keys(currentSnapshot.baselinePrices).length : 0
            });
            
            if (!positions || !currentSnapshot.currentPrices || !currentSnapshot.baselinePrices) {
                console.log('⚠️ Missing data in calculateLongShortMetrics');
                return { 
                    longNotional: 0, longPnL: 0, longCount: 0,
                    shortNotional: 0, shortPnL: 0, shortCount: 0 
                };
            }
            
            let longNotional = 0;
            let longPnL = 0;
            let longCount = 0;
            let shortNotional = 0;
            let shortPnL = 0;
            let shortCount = 0;
            
            positions.forEach(position => {
                const notional = parseFloat(position.target_notional);
                const contracts = parseFloat(position.target_contracts);
                const entryPrice = parseFloat(position.ref_price);
                
                // Get current price from currentSnapshot.currentPrices
                const symbol = (position.ticker || position.ric || position.internal_code).replace('_', '');
                const currentPrice = currentSnapshot.currentPrices[symbol];
                const baselinePrice = currentSnapshot.baselinePrices[symbol];
                
                if (notional && contracts && entryPrice && currentPrice && baselinePrice) {
                    // Calculate P&L for this position using baseline vs current
                    const sideMultiplier = contracts > 0 ? 1 : -1; // 1 for long, -1 for short
                    const pnl = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    
                    if (contracts > 0) {
                        // Long position
                        longNotional += Math.abs(notional);
                        longPnL += pnl;
                        longCount++;
                    } else {
                        // Short position
                        shortNotional += Math.abs(notional);
                        shortPnL += pnl;
                        shortCount++;
                    }
                }
            });
            
            const result = {
                longNotional,
                longPnL,
                longCount,
                shortNotional,
                shortPnL,
                shortCount
            };
            
            console.log('📊 calculateLongShortMetrics result:', result);
            console.log('🔍 LONG/SHORT DEBUG: Long P&L =', longPnL.toFixed(2), 'Short P&L =', shortPnL.toFixed(2), 'Total =', (longPnL + shortPnL).toFixed(2));
            return result;
        }
        
        // Top Performers
        function updateTopPerformers() {
            if (!currentSnapshot.positions || !currentSnapshot.currentPrices || !currentSnapshot.baselinePrices) return;
            
            const positions = currentSnapshot.positions.map(position => {
                const symbol = (position.ticker || position.ric || position.internal_code).replace('_', '');
                const currentPrice = currentSnapshot.currentPrices[symbol];
                const baselinePrice = currentSnapshot.baselinePrices[symbol];
                const notional = parseFloat(position.target_notional);
                const contracts = parseFloat(position.target_contracts);
                
                if (currentPrice && baselinePrice && notional && contracts) {
                    const sideMultiplier = contracts > 0 ? 1 : -1;
                    const pnl = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    return {
                        ...position,
                        symbol: position.ticker || position.ric || position.internal_code,
                        pnl,
                        side: contracts > 0 ? 'LONG' : 'SHORT'
                    };
                }
                return null;
            }).filter(p => p !== null);
            
            // Separate longs and shorts
            const longs = positions.filter(p => p.side === 'LONG').sort((a, b) => b.pnl - a.pnl);
            const shorts = positions.filter(p => p.side === 'SHORT').sort((a, b) => b.pnl - a.pnl);
            
            // Update top 3 for each
            updateTopPerformersList('top-long-performers', longs.slice(0, 3));
            updateTopPerformersList('top-short-performers', shorts.slice(0, 3));
        }
        
        function updateTopPerformersList(containerId, performers) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.innerHTML = '';
            
            if (performers.length === 0) {
                container.innerHTML = '<div class="loading">No data available</div>';
                return;
            }
            
            performers.forEach((performer, index) => {
                const item = document.createElement('div');
                item.className = 'top-performer-item';
                item.innerHTML = `
                    <span class="top-performer-rank">${index + 1}</span>
                    <span class="top-performer-symbol symbol" data-symbol="${performer.symbol}">${performer.symbol}</span>
                    <span class="top-performer-pnl ${performer.pnl >= 0 ? 'positive' : 'negative'}">${formatCurrency(performer.pnl)}</span>
                `;
                container.appendChild(item);
            });
        }
        
        // Check if position is in top 3 performers
        function checkIfTopPerformer(symbol, pnl, side) {
            if (!currentSnapshot.positions || !currentSnapshot.currentPrices || !currentSnapshot.baselinePrices) return false;
            
            // Get all positions with their P&L
            const allPositions = currentSnapshot.positions.map(position => {
                const posSymbol = (position.ticker || position.ric || position.internal_code).replace('_', '');
                const currentPrice = currentSnapshot.currentPrices[posSymbol];
                const baselinePrice = currentSnapshot.baselinePrices[posSymbol];
                const notional = parseFloat(position.target_notional);
                const contracts = parseFloat(position.target_contracts);
                
                if (currentPrice && baselinePrice && notional && contracts) {
                    const sideMultiplier = contracts > 0 ? 1 : -1;
                    const posPnl = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    const posSide = contracts > 0 ? 'LONG' : 'SHORT';
                    return { symbol: posSymbol, pnl: posPnl, side: posSide };
                }
                return null;
            }).filter(p => p !== null);
            
            // Filter by side and sort by absolute P&L
            const sameSidePositions = allPositions.filter(p => p.side === side);
            const top3 = sameSidePositions.sort((a, b) => Math.abs(b.pnl) - Math.abs(a.pnl)).slice(0, 3);
            
            return top3.some(top => top.symbol === symbol);
        }

        // Utility functions
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value);
        }

        function formatPercentage(value) {
            return `${value >= 0 ? '+' : ''}${value.toFixed(2)}%`;
        }

        // Check for new CSV periodically
        async function checkForNewCSV() {
            const csvChanged = await loadDailyCSV();
            if (csvChanged) {
                console.log('🔄 New CSV detected - creating fresh snapshot');
                await createSnapshot();
            }
        }

        // Initialize
        updateTime();
        setInterval(updateTime, 1000);
        
        // Formula Modal Logic
        const formulaMap = {
            'portfolio-value': {
                title: 'Portfolio Value',
                text: 'From S3 latest record: PV_t = portfolio_value. If missing, PV_t = initialCapital + dailyPnL.'
            },
            'daily-pnl': {
                title: 'Daily P&L',
                text: 'From S3 latest record: Daily P&L = daily_pnl. When computing locally: sum over positions [side * (Mark - Baseline) / Baseline * |Notional|].'
            },
            'total-pnl': {
                title: 'Total P&L Since Inception',
                text: 'From S3 latest record: Total P&L = total_pnl. If missing: PortfolioValue - $1,000,000.'
            },
            'positions': {
                title: 'Positions',
                text: 'Count of positions with non-zero target_contracts in the daily CSV.'
            },
            'avg-daily-return': {
                title: 'Average Daily Return',
                text: 'Mean of daily returns over last ≤30 days. For each day: r_d = (PV_end - PV_start) / PV_start. Displayed as %.'
            },
            'long-positions': {
                title: 'Long Positions',
                text: 'Notional = sum(|notional| for longs). Subtitle = Daily Long P&L from S3 audit or local calc.'
            },
            'short-positions': {
                title: 'Short Positions',
                text: 'Notional = sum(|notional| for shorts). Subtitle = Daily Short P&L from S3 audit or local calc.'
            },
            'avg-pnl-per-trade': {
                title: 'Avg P&L per Trade',
                text: 'cardDaily / openPositions, where openPositions counts non-zero target_contracts.'
            },
            'vol-ann': {
                title: 'Volatility (Annualized)',
                text: 'Annualized daily return std dev: vol_ann = stdev(daily_returns) * sqrt(365).'
            },
            'sharpe-ann': {
                title: 'Sharpe (Annualized)',
                text: 'Sharpe_ann = (mean(daily_returns) / stdev(daily_returns)) * sqrt(365). rf = 0. Requires ≥5 daily obs.'
            },
            'risk-corr': {
                title: 'Corr vs BTC',
                text: 'Pearson correlation between aligned daily returns: strategy S (from S3 PV log → per-day open/close) and BTC B (benchmarks/btc_daily_returns.csv). Window: 90D = last 90 overlapping dates; SI = all overlapping dates since inception.'
            },
            'risk-hit': {
                title: 'Hit Rate',
                text: 'Percent of days with S > 0 in the selected window. 90D = last 90 strategy days; SI = since inception (all strategy daily returns).'
            },
            'risk-mdd': {
                title: 'Max Drawdown',
                text: 'From strategy daily returns only. Equity E starts at 1; each day r%: E←E×(1+r/100). Drawdown is min(E/peak − 1) over the selected window, shown in %.'
            }
        };

        function showFormula(key) {
            const def = formulaMap[key];
            if (!def) return;
            document.getElementById('formula-title').textContent = def.title;
            document.getElementById('formula-text').textContent = def.text;
            document.getElementById('formula-modal').classList.remove('hidden');
        }

        function hideFormula() {
            document.getElementById('formula-modal').classList.add('hidden');
        }

        // Bind click handlers to cards after DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.summary-cards .card').forEach(card => {
                const key = card.getAttribute('data-formula-key');
                if (!key) return;
                card.style.cursor = 'pointer';
                card.addEventListener('click', () => showFormula(key));
            });

            // CSV info toggle
            const csvToggle = document.getElementById('csv-toggle');
            const csvInfo = document.getElementById('csv-info');
            if (csvToggle && csvInfo) {
                // Use hidden attribute for robust toggle
                csvInfo.hidden = true;
                csvToggle.addEventListener('click', () => {
                    csvInfo.hidden = !csvInfo.hidden;
                });
            }
            // Sort header clicks
            document.querySelectorAll('th.sortable').forEach(th => {
                th.style.cursor = 'pointer';
                const arrow = document.createElement('span');
                arrow.textContent = ' \u2195';
                arrow.style.color = '#94a3b8';
                th.appendChild(arrow);
                th.addEventListener('click', () => {
                    const table = th.getAttribute('data-table');
                    const key = th.getAttribute('data-key');
                    const state = window.tableSortState || (window.tableSortState = { long:{key:null,dir:1}, short:{key:null,dir:1} });
                    const cur = state[table];
                    if (cur.key === key) cur.dir = -cur.dir; else { cur.key = key; cur.dir = -1; }
                    // Visual state
                    document.querySelectorAll('th.sortable').forEach(h=>h.classList.remove('sorted-asc','sorted-desc'));
                    th.classList.add(cur.dir === 1 ? 'sorted-asc' : 'sorted-desc');
                    // Re-render
                    updatePositionsTable(referenceCapital);
                });
            });

            // Download widget toggle and presets
            const dwBtn = document.getElementById('download-btn');
            const dwPopover = document.getElementById('download-popover');
            const dwClose = document.getElementById('dw-close');
            const dwStart = document.getElementById('dw-start');
            const dwEnd = document.getElementById('dw-end');
            const dwPresets = document.querySelectorAll('.dw-presets button');
            const setPreset = (days) => {
                const today = new Date();
                const end = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate()));
                let start;
                if (days === 'all') {
                    // leave start empty to indicate full history
                    dwStart.value = '';
                    dwEnd.value = end.toISOString().slice(0,10);
                    return;
                }
                start = new Date(end.getTime() - Number(days) * 24*60*60*1000);
                dwStart.value = start.toISOString().slice(0,10);
                dwEnd.value = end.toISOString().slice(0,10);
            };
            if (dwBtn && dwPopover) {
                dwBtn.addEventListener('click', () => { 
                    const willShow = dwPopover.hidden; 
                    dwPopover.hidden = !dwPopover.hidden; 
                    if (willShow) dwPopover.classList.add('show'); else dwPopover.classList.remove('show');
                });
            }
            const dwX = document.getElementById('dw-x');
            function closePopover(){ dwPopover.classList.remove('show'); dwPopover.hidden = true; }
            if (dwClose && dwPopover) {
                dwClose.addEventListener('click', closePopover);
            }
            if (dwX && dwPopover) {
                dwX.addEventListener('click', closePopover);
            }
            // outside click / Esc to close
            document.addEventListener('click', (e) => {
                if (!dwPopover || dwPopover.hidden) return;
                const within = dwPopover.contains(e.target) || (dwBtn && dwBtn.contains(e.target));
                if (!within) closePopover();
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && dwPopover && !dwPopover.hidden) closePopover();
            });
            if (dwPresets && dwPresets.length) {
                dwPresets.forEach(btn => btn.addEventListener('click', () => {
                    dwPresets.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    setPreset(btn.dataset.preset);
                }));
                // default preset 30D
                setPreset('30');
            }

            // Download handler
            const dwDownload = document.getElementById('dw-download');
            if (dwDownload) {
                dwDownload.addEventListener('click', async () => {
                    try {
                        const fmt = (document.getElementById('dw-format')?.value || 'csv');
                        const series = (document.getElementById('dw-series')?.value || 'daily_returns');
                        // fetch full PV log
                        const res = await fetch(`${DATA_PREFIX}portfolio_value_log.jsonl?cb=${Date.now()}`, { cache: 'no-store' });
                        if (!res.ok) throw new Error('No PV log');
                        const text = (await res.text()).trim();
                        if (!text) throw new Error('Empty PV log');
                        const rows = text.split('\n').map(l=>{ try { return JSON.parse(l); } catch { return null; } }).filter(Boolean);
                        // filter by date range (UTC days)
                        const startStr = dwStart.value;
                        const endStr = dwEnd.value;
                        const filtered = rows.filter(r => {
                            const d = new Date(r.timestamp);
                            const day = d.toISOString().slice(0,10);
                            if (startStr && day < startStr) return false;
                            if (endStr && day > endStr) return false;
                            return true;
                        });
                        // group by UTC day
                        const map = new Map();
                        filtered.forEach(r => {
                            const k = new Date(r.timestamp).toISOString().slice(0,10);
                            const arr = map.get(k) || []; arr.push(r); map.set(k, arr);
                        });
                        const days = Array.from(map.keys()).sort();
                        let out = [];
                        if (series === 'daily_pv') {
                            days.forEach(k => {
                                const pts = map.get(k).sort((a,b)=> new Date(a.timestamp)-new Date(b.timestamp));
                                const pv1 = pts[pts.length-1]?.portfolio_value;
                                if (typeof pv1 === 'number') out.push({ Date:k, PV: pv1 });
                            });
                        } else {
                            let cum = 0;
                            days.forEach(k => {
                                const pts = map.get(k).sort((a,b)=> new Date(a.timestamp)-new Date(b.timestamp));
                                const pv0 = pts[0]?.portfolio_value; const pv1 = pts[pts.length-1]?.portfolio_value;
                                if (typeof pv0 === 'number' && pv0>0 && typeof pv1 === 'number') {
                                    const dailyPnl = pv1 - pv0;
                                    cum += dailyPnl;
                                    out.push({ Date:k, Performance: ((dailyPnl/pv0)*100).toFixed(2) });
                                }
                            });
                        }
                        if (fmt === 'json') {
                            const blob = new Blob([JSON.stringify(out,null,2)], {type:'application/json'});
                            const url = URL.createObjectURL(blob);
                            const name = (series==='daily_pv' ? 'daily_pv' : 'daily_returns');
                            const a = Object.assign(document.createElement('a'), { href:url, download:`${name}_${(dwStart.value||'ALL')}_to_${(dwEnd.value||'TODAY')}.json` });
                            document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
                        } else {
                            let header, lines;
                            if (series === 'daily_pv') {
                                header = 'Date,PV';
                                lines = out.map(r => `${r.Date},${r.PV}`);
                            } else {
                                header = 'Date,Performance';
                                lines = out.map(r => `${r.Date},${r.Performance}`);
                            }
                            const csv = [header].concat(lines).join('\n');
                            const blob = new Blob([csv], {type:'text/csv;charset=utf-8'});
                            const url = URL.createObjectURL(blob);
                            const name = (series==='daily_pv' ? 'daily_pv' : 'daily_returns');
                            const a = Object.assign(document.createElement('a'), { href:url, download:`${name}_${(dwStart.value||'ALL')}_to_${(dwEnd.value||'TODAY')}.csv` });
                            document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
                        }
                    } catch (e) {
                        console.warn('Download failed', e);
                    }
                });
            }
            // Initialize strategy selector and persist choice
            const sel = document.getElementById('strategy-select');
            if (sel) {
                // Set initial from storage
                for (let i = 0; i < sel.options.length; i++) {
                    if (sel.options[i].value === DATA_PREFIX) {
                        sel.selectedIndex = i;
                        break;
                    }
                }
                sel.addEventListener('change', (e) => {
                    const val = e.target.value;
                    localStorage.setItem('DATA_PREFIX', val);
                    // Full reload preserves original initialization order and avoids partial state bugs
                    location.reload();
                });
            }
        });
        
        // Initialize mobile optimizations
        initMobileOptimizations();
        
        // Load historical PV data from S3 first, THEN load CSV and start snapshots
        loadHistoricalPVData('1D').then(historicalData => {
            console.log(`📊 Loaded ${historicalData.length} historical PV points from S3`);
            console.log('📊 S3 Data:', historicalData);
            pvLogs = historicalData;
            
            // Update portfolio value from latest S3 data
            if (historicalData.length > 0) {
                const latestPV = historicalData[historicalData.length - 1].portfolio_value || historicalData[historicalData.length - 1].portfolioValue;
                if (latestPV && currentSnapshot) {
                    currentSnapshot.portfolioValue = latestPV;
                    console.log(`📊 Updated Portfolio Value from S3: $${latestPV.toFixed(2)}`);
                }
            }
            
            updateChart(historicalData, '1D'); // Pass the data directly to show full chart
            // Initialize S3-derived metrics cards immediately
            updateS3MetricsCards();

            // Load PV_pre for accurate percentage calculations
            loadPVPre().then(() => {
                console.log('📊 PV_pre loaded for percentage calculations');
            }).catch(error => {
                console.error('Error loading PV_pre:', error);
            });

            // NOW load CSV and start snapshots (after S3 data is loaded)
        loadDailyCSV().then(() => {
                // Create initial snapshot (S3 PV should be set by now)
            createSnapshot();
            
                // Update positions and P&L every 10 seconds (tick by tick) - faster for testing
                setInterval(createSnapshot, 10 * 1000);
            
            // Check for new CSV every 10 minutes (around execution time)
            setInterval(checkForNewCSV, 10 * 60 * 1000);
                
                // Update chart every 5 minutes with fresh S3 data
                setInterval(updateChartFromS3, 5 * 60 * 1000);
            });
            
        }).catch(error => {
            console.error('Error loading historical data:', error);
            console.log('📊 Initializing chart with empty data');
            pvLogs = [];
            updateChart(); // This will show the placeholder chart
            // Initialize S3-derived metrics cards in fallback
            updateS3MetricsCards();
            
            // Still load CSV even if S3 fails
            loadPVPre().then(() => {
                console.log('📊 PV_pre loaded for fallback mode');
            }).catch(error => {
                console.error('Error loading PV_pre in fallback:', error);
            });

            loadDailyCSV().then(() => {
                createSnapshot();
                setInterval(createSnapshot, 10 * 1000);
                setInterval(checkForNewCSV, 10 * 60 * 1000);
                setInterval(updateChartFromS3, 5 * 60 * 1000);
            });
        });
        // CSV info toggleable via button
        
        // Derive a human-friendly source tag from DATA_PREFIX
        function getSourceDescriptor() {
            try {
                if (!DATA_PREFIX) return '';
                if (DATA_PREFIX.indexOf('descartes-beta') !== -1) {
                    return 'beta • ml_qube/qube/signal';
                }
                if (DATA_PREFIX.indexOf('descartes-ridge-unravel') !== -1) {
                    return 'ridge • ridge_unravel/qube/signal';
                }
                // Default to Unravel mapping
                return 'unravel • combined_descartes_unravel/qube/signal';
            } catch (e) {
                return '';
            }
        }

        // Update CSV filename when data loads
        function updateCSVFilename(filename, uploadedUtc) {
            const csvElement = document.getElementById('csv-filename');
            if (csvElement) {
                if (!filename) {
                    csvElement.textContent = 'No CSV loaded';
                    return;
                }
                const src = getSourceDescriptor();
                let label = filename;
                let ts = null;
                if (uploadedUtc) {
                    // Format like: 2025-10-04 12:02 UTC
                    const d = new Date(uploadedUtc);
                    ts = isNaN(d.getTime()) ? uploadedUtc : `${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,'0')}-${String(d.getUTCDate()).padStart(2,'0')} ${String(d.getUTCHours()).padStart(2,'0')}:${String(d.getUTCMinutes()).padStart(2,'0')} UTC`;
                    label = src ? `${filename} (source: ${src} • loaded: ${ts})` : `${filename} (loaded: ${ts})`;
                }
                csvElement.textContent = label;

                // Also update legacy stamped banner if present (csv-monitor injection)
                try {
                    const nameEl = document.getElementById('csv-name');
                    const tsEl = document.getElementById('csv-timestamp');
                    if (nameEl) nameEl.textContent = filename;
                    if (tsEl) {
                        if (ts) {
                            tsEl.textContent = src ? `(source: ${src} • loaded: ${ts})` : `(loaded: ${ts})`;
                        } else {
                            tsEl.textContent = src ? `(source: ${src})` : '';
                        }
                    }
                } catch (e) { /* no-op */ }
            }
        }
        
        // Mobile-specific optimizations
        function initMobileOptimizations() {
            // Detect mobile device
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                // Reduce update frequency on mobile to save battery
                console.log('📱 Mobile device detected - optimizing for mobile');
                
                // Add mobile-specific classes
                document.body.classList.add('mobile-device');
                
                // Optimize table scrolling on mobile
                const tableContainer = document.querySelector('.table-container');
                if (tableContainer) {
                    tableContainer.style.webkitOverflowScrolling = 'touch';
                }
                
                // Add touch feedback
                const buttons = document.querySelectorAll('.time-button, .refresh-button');
                buttons.forEach(button => {
                    button.addEventListener('touchstart', function() {
                        this.style.opacity = '0.7';
                    });
                    button.addEventListener('touchend', function() {
                        this.style.opacity = '1';
                    });
                });
            }
        }
        
        // Update chart from S3 data every 5 minutes
        async function updateChartFromS3() {
            console.log('🔄 Updating chart from S3 data...');
            try {
                const cacheBuster = new Date().getTime();
                const response = await fetch(`${DATA_PREFIX}portfolio_value_log.jsonl?cb=${cacheBuster}`, {
                    cache: 'no-store'
                });
                if (response.ok) {
                    const text = await response.text();
                    const lines = text.trim().split('\n').filter(line => line.trim());
                    const s3Data = lines.map(line => JSON.parse(line));
                    
                    // Update pvLogs with fresh S3 data
                    pvLogs = s3Data;
                    
                    // Update portfolio value from latest S3 data
                    if (s3Data.length > 0) {
                        const last = s3Data[s3Data.length - 1];
                        const latestPV = last.portfolio_value || last.portfolioValue;
                        if (latestPV && currentSnapshot) {
                            currentSnapshot.portfolioValue = latestPV;
                            console.log(`📊 Updated Portfolio Value from S3 refresh: $${latestPV.toFixed(2)}`);
                            
                            // Also refresh S3-derived totals so Total P&L card stays in sync
                            if (typeof last.total_pnl === 'number') {
                                currentSnapshot.s3TotalPnL = last.total_pnl;
                            }
                            if (typeof last.daily_pnl === 'number') {
                                currentSnapshot.s3DailyPnL = last.daily_pnl;
                            }
                            
                            // Update UI with new portfolio value
                            updateUI();
                        }
                    }
                    
                    // Update chart with current timeframe only if data has changed
                    const activeButton = document.querySelector('.time-button.active');
                    const timeframe = activeButton ? activeButton.textContent : '1D';
                    updateChart(s3Data, timeframe);
                    
                    console.log(`📊 Chart updated with ${s3Data.length} data points from S3`);

                    // Refresh S3-derived metric cards (avg daily return, vol, sharpe)
                    updateS3MetricsCards();
                } else {
                    console.log('⚠️ No S3 data available yet, keeping current chart');
                    // Don't update chart if S3 data is not available, keep current data
                }
            } catch (error) {
                console.error('Error updating chart from S3:', error);
                console.log('📊 Keeping current chart data due to error');
                // Don't update chart on error, keep current data
            }
        }

        // ===== S3-derived Metrics: Avg Daily Return, Vol (Ann.), Sharpe (Ann.) =====
        function groupByUtcDay(series) {
            const groups = new Map();
            series.forEach(pt => {
                const d = new Date(pt.timestamp);
                const dayKey = d.toISOString().slice(0,10); // YYYY-MM-DD
                const arr = groups.get(dayKey) || [];
                arr.push(pt);
                groups.set(dayKey, arr);
            });
            return groups;
        }

        function computeDailyReturnsFromPV(series) {
            // Group points by UTC day and use first/last PV per day
            const groups = groupByUtcDay(series);
            const dailyReturns = [];
            for (const [day, points] of groups.entries()) {
                const sorted = points.slice().sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
                const first = sorted[0];
                const last = sorted[sorted.length - 1];
                const pv0 = first.portfolio_value || first.portfolioValue;
                const pv1 = last.portfolio_value || last.portfolioValue;
                if (typeof pv0 === 'number' && pv0 > 0 && typeof pv1 === 'number') {
                    const r = (pv1 - pv0) / pv0; // simple daily return
                    dailyReturns.push(r);
                }
            }
            return dailyReturns;
        }

        function mean(values) {
            if (!values || values.length === 0) return null;
            return values.reduce((a,b) => a + b, 0) / values.length;
        }

        function stddev(values) {
            if (!values || values.length < 2) return null;
            const m = mean(values);
            const varSum = values.reduce((acc, v) => acc + (v - m) * (v - m), 0);
            const variance = varSum / (values.length - 1); // sample stddev
            return Math.sqrt(variance);
        }

        async function updateS3MetricsCards() {
            try {
                // Use last 30 days of S3 PV logs
                const data30 = await loadHistoricalPVData('1M');
                if (!data30 || data30.length === 0) {
                    setMetricsNA();
                    return;
                }
                const dailyReturns = computeDailyReturnsFromPV(data30);
                const days = dailyReturns.length;
                const avgEl = document.getElementById('avg-daily-return');
                const avgMetaEl = document.getElementById('avg-daily-return-meta');
                const volEl = document.getElementById('vol-ann');
                const volMetaEl = document.getElementById('vol-ann-meta');
                const sharpeEl = document.getElementById('sharpe-ann');
                const sharpeMetaEl = document.getElementById('sharpe-ann-meta');

                if (days === 0) {
                    setMetricsNA();
                    return;
                }

                const m = mean(dailyReturns);
                const s = stddev(dailyReturns);

                // Average Daily Return
                if (avgEl) avgEl.textContent = `${(m * 100).toFixed(2)}%`;
                if (avgMetaEl) avgMetaEl.textContent = `based on ${days} day${days === 1 ? '' : 's'}`;

                // Volatility (Annualized)
                if (s !== null && volEl) {
                    const volAnn = s * Math.sqrt(365);
                    volEl.textContent = `${(volAnn * 100).toFixed(2)}%`;
                    if (volMetaEl) volMetaEl.textContent = `${days} daily obs`;
                } else {
                    if (volEl) volEl.textContent = 'N/A';
                    if (volMetaEl) volMetaEl.textContent = 'insufficient data';
                }

                // Sharpe (Annualized) with rf=0
                const MIN_DAYS_FOR_SHARPE = 5;
                if (days >= MIN_DAYS_FOR_SHARPE && s !== null && s > 0 && sharpeEl) {
                    const sharpeAnn = (m / s) * Math.sqrt(365);
                    sharpeEl.textContent = `${sharpeAnn.toFixed(2)}`;
                    if (sharpeMetaEl) sharpeMetaEl.textContent = `${days} daily obs`;
                } else {
                    if (sharpeEl) sharpeEl.textContent = 'N/A';
                    if (sharpeMetaEl) sharpeMetaEl.textContent = `need ≥ ${MIN_DAYS_FOR_SHARPE} days`;
                }
            } catch (e) {
                console.log('⚠️ Failed to update S3 metrics cards:', e);
                setMetricsNA();
            }
        }

        function setMetricsNA() {
            const avgEl = document.getElementById('avg-daily-return');
            const avgMetaEl = document.getElementById('avg-daily-return-meta');
            const volEl = document.getElementById('vol-ann');
            const volMetaEl = document.getElementById('vol-ann-meta');
            const sharpeEl = document.getElementById('sharpe-ann');
            const sharpeMetaEl = document.getElementById('sharpe-ann-meta');
            if (avgEl) avgEl.textContent = 'N/A';
            if (avgMetaEl) avgMetaEl.textContent = 'insufficient data';
            if (volEl) volEl.textContent = 'N/A';
            if (volMetaEl) volMetaEl.textContent = 'insufficient data';
            if (sharpeEl) sharpeEl.textContent = 'N/A';
            if (sharpeMetaEl) sharpeMetaEl.textContent = 'insufficient data';
        }
    </script>
    
    <style>
        /* Formula Modal */
        .formula-modal.hidden { display: none; }
        .formula-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .formula-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            max-width: 640px;
            width: calc(100% - 32px);
            box-shadow: var(--shadow-lg);
        }
        .formula-title {
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--text-primary);
        }
        .formula-text {
            color: var(--text-secondary);
            line-height: 1.5;
        }
        .formula-close {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            cursor: pointer;
        }
        .chart-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .csv-info[hidden] { display: none !important; }
        .csv-info { display: inline-flex; align-items: center; gap: 6px; }
        .csv-toggle {
            background: transparent;
            border: 0;
            cursor: pointer;
            font-size: 16px;
            margin-right: 8px;
            color: #10b981;
        }
        .csv-toggle:hover { opacity: 0.8; }
        /* Download widget */
        .download-widget { position: relative; margin-left: 8px; }
        .download-button { padding: 8px 14px; border-radius: 12px; border: 1px solid #e5e7eb; background:#ffffff; color:#111827; cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,0.05); }
        .download-button:hover { background:#f9fafb; transform: translateY(-1px); box-shadow:0 4px 10px rgba(0,0,0,0.08); }
        /* Solid theme (no glass) for universal consistency */
        .download-popover { position:absolute; top:40px; right:0; background:#ffffff; border:1px solid #e5e7eb; border-radius:16px; padding:16px; box-shadow:0 24px 40px rgba(2,8,23,0.16), 0 4px 10px rgba(2,8,23,0.06); width:320px; z-index:1000; }
        .download-popover { opacity:0; transform:translateY(-6px); transition:opacity .18s ease, transform .18s ease; }
        .download-popover[hidden] { display:none; }
        .download-popover.show { opacity:1; transform:translateY(0); }
        .download-popover::after { content:''; position:absolute; top:-6px; right:18px; width:12px; height:12px; background:#ffffff; border-left:1px solid #e5e7eb; border-top:1px solid #e5e7eb; transform: rotate(45deg); }
        .dw-header { display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; padding:10px 12px; border-radius:12px; background:linear-gradient(135deg,#4338ca 0%, #7c3aed 100%); color:#fff; }
        .dw-title { font-weight:700; color:#ffffff; letter-spacing:.2px; }
        .dw-x { background:transparent; border:0; font-size:18px; line-height:1; cursor:pointer; color:#ffffff; opacity:0.85; }
        .dw-row { display:flex; align-items:center; justify-content:space-between; margin:12px 0; }
        .dw-label { color:#475569; font-size:12px; margin-right:8px; font-weight:600; }
        .dw-range { display:flex; align-items:center; gap:6px; }
        .dw-range input[type=date] { -webkit-appearance:none; appearance:none; border:1px solid #e5e7eb; border-radius:10px; padding:8px 10px; font-size:12px; color:#111827; background:#fff; font-variant-numeric: tabular-nums; letter-spacing:0.2px; }
        .dw-range input[type=date]::-webkit-calendar-picker-indicator{ filter:invert(35%); opacity:0.8; cursor:pointer; }
        select#dw-series, select#dw-format { border:1px solid #e5e7eb; border-radius:10px; padding:6px 8px; font-size:12px; color:#111827; background:#fff; min-width:120px; }
        .dw-sep { color:#9ca3af; font-size:12px; }
        .dw-presets { gap:6px; }
        .dw-presets button { border:1px solid #e5e7eb; background:#fff; border-radius:10px; padding:6px 10px; cursor:pointer; font-size:12px; color:#111827; }
        .dw-presets button.active { background:#eef2ff; border-color:#c7d2fe; color:#4f46e5; box-shadow:0 2px 6px rgba(79,70,229,0.18); }
        .dw-note { color:#94a3b8; font-size:12px; justify-content:flex-start; }
        .dw-actions { gap:8px; justify-content:flex-end; margin-top:6px; }
        .dw-actions .primary { background:linear-gradient(135deg,#667eea 0%, #764ba2 100%); color:#fff; border:0; border-radius:999px; padding:10px 16px; cursor:pointer; box-shadow:0 8px 16px rgba(102,126,234,0.35); font-weight:600; }
        .dw-actions .primary:hover { filter:brightness(1.03); transform:translateY(-1px); }
        .dw-actions .secondary { background:#fff; color:#111827; border:1px solid #e5e7eb; border-radius:999px; padding:9px 14px; cursor:pointer; }
        /* removed */
        .refresh-button {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(248, 250, 252, 0.9) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(226, 232, 240, 0.8);
            color: #64748b;
            border: none;
            padding: 10px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .refresh-button:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, rgba(248, 250, 252, 1) 100%);
            border-color: rgba(102, 126, 234, 0.3);
            color: #475569;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.12);
            transform: translateY(-1px);
        }
        .refresh-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .refresh-button svg {
            transition: transform 0.3s ease;
        }
        .refresh-button:hover svg {
            transform: rotate(180deg);
        }
        
        /* Mobile-specific enhancements */
        .mobile-device .metric-card {
            transition: all 0.2s ease;
        }
        
        .mobile-device .metric-card:active {
            transform: scale(0.98);
            opacity: 0.9;
        }
        
        .mobile-device .table-container {
            border-radius: 12px;
            overflow: hidden;
        }
        
        .mobile-device table {
            border-collapse: separate;
            border-spacing: 0;
        }
        th.sortable { position: relative; user-select:none; }
        th.sortable::after { content:'\25B4'; position:absolute; right:8px; top:50%; transform:translateY(-60%) rotate(180deg); font-size:10px; opacity:.35; }
        th.sortable.sorted-asc::after { content:'\25B4'; transform:translateY(-60%) rotate(0deg); opacity:.9; }
        th.sortable.sorted-desc::after { content:'\25BE'; opacity:.9; }
        
        .mobile-device th:first-child,
        .mobile-device td:first-child {
            padding-left: var(--space-sm);
        }
        
        .mobile-device th:last-child,
        .mobile-device td:last-child {
            padding-right: var(--space-sm);
        }
        
        /* Mobile loading state */
        @media (max-width: 768px) {
            .loading-spinner {
                width: 40px;
                height: 40px;
            }
            
            .loading-text {
                font-size: 0.875rem;
                margin-top: var(--space-sm);
            }
        }
        
        /* Improve mobile chart interaction */
        @media (max-width: 768px) {
            .chart-container canvas {
                max-height: 250px;
            }
            
            .chart-controls {
                padding: var(--space-sm);
                background: var(--bg-card);
                border-radius: 12px;
                margin-top: var(--space-sm);
            }
        }
    </style>
<div style="font:14px/1.4 system-ui,sans-serif;background:#f6f7fb;border:1px solid #e2e6f0;padding:8px 12px;border-radius:8px;display:inline-block;margin:8px 0;">📊 <span id="csv-name">lpxd_external_advisors_DF_20251007-2355.csv</span> <span id="csv-timestamp">(loaded: 2025-10-08 16:02 UTC)</span></div>
</body>
</html>
