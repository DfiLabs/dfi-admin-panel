<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Monitor</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="logo">
                <img src="assets/images/dfi-labs-logo.png" alt="DFI Labs" class="logo-image">
                <div class="logo-text">
                    <span class="logo-main">Strategy Monitor</span>
                    <span class="logo-subtitle">DFI Labs</span>
                </div>
            </div>
            <div class="header-info">
                <div class="status-indicator">
                    <div class="status-dot active"></div>
                    <span>Live</span>
                </div>
                <span id="current-time">Loading...</span>
            </div>
        </div>
    </header>

    <main class="main">
        <div class="container">
            <div class="dashboard-header">
                <h1>Live Portfolio Dashboard</h1>
                <p>Real-time cryptocurrency strategy monitoring & performance tracking</p>
            </div>

            <!-- Delta Donut Chart -->
            <div class="delta-donut-section">
                <div class="delta-donut-card">
                    <div class="delta-header">
                        <h3>Portfolio Exposure</h3>
                        <div class="delta-status">
                            <span class="delta-label">NET DELTA</span>
                            <span class="delta-value" id="delta-value">Loading...</span>
                        </div>
                    </div>
                    <div class="delta-progress-container">
                        <div class="delta-progress-bar">
                            <div class="delta-progress-fill" id="delta-progress-fill"></div>
                            <div class="delta-progress-indicator" id="delta-progress-indicator"></div>
                        </div>
                        <div class="delta-progress-labels">
                            <span class="delta-label-left">SHORT</span>
                            <span class="delta-label-right">LONG</span>
                        </div>
                        <div class="delta-progress-value">
                            <span id="delta-percentage">0%</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Core Metrics -->
            <div class="summary-cards">
                <div class="card primary-metric">
                    <h3>Portfolio Value</h3>
                    <div class="value" id="portfolio-value">Loading...</div>
                    <div class="subtitle">as of <span id="portfolio-time">Loading...</span></div>
                </div>
                <div class="card">
                    <h3>Daily P&L</h3>
                    <div class="value" id="daily-pnl">Loading...</div>
                    <div class="percentage" id="daily-pnl-percent"></div>
                </div>
                <div class="card">
                    <h3>Total P&L Since Inception</h3>
                    <div class="value" id="total-pnl">Loading...</div>
                    <div class="percentage" id="total-pnl-percent"></div>
                </div>
                <div class="card">
                    <h3>Positions</h3>
                    <div class="value" id="total-positions-count">Loading...</div>
                    <div class="subtitle">Total Open Positions</div>
                </div>
                <div class="card long-position">
                    <h3>Long Positions</h3>
                    <div class="value" id="long-notional">Loading...</div>
                    <div class="percentage" id="long-pnl-percent"></div>
                    <div class="subtitle" id="long-count">0 positions</div>
                </div>
                <div class="card short-position">
                    <h3>Short Positions</h3>
                    <div class="value" id="short-notional">Loading...</div>
                    <div class="percentage" id="short-pnl-percent"></div>
                    <div class="subtitle" id="short-count">0 positions</div>
                </div>
            </div>

            <!-- Portfolio Value Chart with Time Scales -->
            <div class="chart-section">
                <div class="chart-header">
                    <h2>Portfolio Performance</h2>
                    <div class="csv-info" onclick="toggleCSVInfo()" title="Click to show current CSV">
                        <span class="csv-indicator">📊</span>
                        <span class="csv-filename" id="csv-filename" style="display: none;">Loading...</span>
                    </div>
                </div>
                <div class="chart-controls">
                    <button class="time-button active" onclick="loadChartData('1D')">1D</button>
                    <button class="time-button" onclick="loadChartData('7D')">7D</button>
                    <button class="time-button" onclick="loadChartData('1M')">1M</button>
                    <button class="refresh-button" onclick="createSnapshot()" title="Force Update Now">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="23 4 23 10 17 10"></polyline>
                            <polyline points="1 20 1 14 7 14"></polyline>
                            <path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>
                        </svg>
                    </button>
                </div>
                <div class="chart-container">
                    <canvas id="portfolio-chart"></canvas>
                </div>
            </div>

            <!-- Top Performers -->
            <div class="top-performers">
                <div class="top-performers-card longs">
                    <h4>Top Long Performers</h4>
                    <div id="top-long-performers">
                        <div class="loading">Loading top long performers...</div>
                    </div>
                </div>
                <div class="top-performers-card shorts">
                    <h4>Top Short Performers</h4>
                    <div id="top-short-performers">
                        <div class="loading">Loading top short performers...</div>
                    </div>
                </div>
            </div>

            <!-- Positions Table -->
            <div class="positions-section">
                <h2>Long Positions</h2>
                <div class="positions-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Side</th>
                                <th>Weight %</th>
                                <th>Notional $</th>
                                <th>Entry Price</th>
                                <th>Mark Price</th>
                                <th>P&L $</th>
                                <th>P&L %</th>
                            </tr>
                        </thead>
                        <tbody id="long-positions">
                            <tr><td colspan="8" class="loading">Loading long positions...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="positions-section">
                <h2>Short Positions</h2>
                <div class="positions-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Side</th>
                                <th>Weight %</th>
                                <th>Notional $</th>
                                <th>Entry Price</th>
                                <th>Mark Price</th>
                                <th>P&L $</th>
                                <th>P&L %</th>
                            </tr>
                        </thead>
                        <tbody id="short-positions">
                            <tr><td colspan="8" class="loading">Loading short positions...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </main>
    <script>
        // Core state - single source of truth
        let currentSnapshot = {
            timestamp: null,
            portfolioValue: 1000000, // Start with $1M
            dailyPnL: 0,
            positions: [],
            baselinePrices: {},
            currentPrices: {}
        };

        const initialCapital = 1000000;
        let currentPVPre = null; // Will be loaded from pre_execution.json
        let portfolioChart = null;

        // Update time display
        function updateTime() {
            const now = new Date();
            const utcTime = now.toISOString().substr(11, 8);
            const parisTime = new Date(now.getTime() + (2 * 60 * 60 * 1000)).toISOString().substr(11, 8);
            document.getElementById('current-time').textContent = `${utcTime} / ${parisTime} UTC / Paris`;
        }

        // Track current CSV to detect changes
        let currentCSVFilename = null;
        
        // Load daily CSV and set baseline
        async function loadDailyCSV() {
            try {
                // Find latest post_execution row
                const response = await fetch('/signal-dashboard/data/portfolio_daily_log.csv');
                const csvText = await response.text();
                const lines = csvText.split('\n');
                
                let latestRow = null;
                for (let i = lines.length - 1; i >= 0; i--) {
                    if (lines[i].includes('post_execution')) {
                        latestRow = lines[i].split(',');
                        break;
                    }
                }
                
                if (!latestRow) {
                    throw new Error('No post_execution row found');
                }
                
                // Check if CSV has changed
                const csvFilename = latestRow[4];
                if (csvFilename === currentCSVFilename) {
                    console.log('CSV unchanged, skipping reload');
                    return false; // No change
                }
                
                console.log(`New CSV detected: ${csvFilename} (was: ${currentCSVFilename})`);
                currentCSVFilename = csvFilename;
                updateCSVFilename(csvFilename);
                
                // Load positions from the CSV file
                const portfolioResponse = await fetch(`/signal-dashboard/data/${csvFilename}`);
                const portfolioCsv = await portfolioResponse.text();
                const portfolioLines = portfolioCsv.split('\n');
                const portfolioHeaders = portfolioLines[0].split(',');
                
                const positions = [];
                for (let i = 1; i < portfolioLines.length; i++) {
                    if (portfolioLines[i].trim()) {
                        const values = portfolioLines[i].split(',');
                        const position = {};
                        portfolioHeaders.forEach((header, index) => {
                            position[header.trim()] = values[index] ? values[index].trim() : '';
                        });
                        positions.push(position);
                    }
                }
                
                console.log(`Loaded ${positions.length} positions from ${csvFilename}`);
                
                // Set baseline prices (current market prices at CSV execution)
                const baselinePrices = await fetchBaselinePrices(positions);
                
                // Update current snapshot
                currentSnapshot.positions = positions;
                currentSnapshot.baselinePrices = baselinePrices;
                console.log('🔍 DEBUG: Loaded positions count:', positions.length);
                console.log('🔍 DEBUG: First 3 positions:', positions.slice(0, 3));
                currentSnapshot.dailyPnL = 0; // Reset daily P&L
                
                console.log('Daily CSV loaded, baseline set, Daily P&L reset to 0');
                return true; // CSV changed
                
            } catch (error) {
                console.error('Error loading daily CSV:', error);
                return false;
            }
        }

        // Load baseline prices from daily_baseline.json
        async function fetchBaselinePrices(positions) {
            try {
                const response = await fetch('/signal-dashboard/data/daily_baseline.json');
                const baseline = await response.json();
                return baseline.prices || {};
            } catch (error) {
                console.error('Error loading baseline prices:', error);
                return {};
            }
        }
        
        // Load PV_pre from pre_execution.json for accurate percentage calculations
        async function loadPVPre() {
            try {
                console.log('🔍 Loading PV_pre from pre_execution.json...');
                const response = await fetch('/signal-dashboard/data/pre_execution.json');
                if (response.ok) {
                    const data = await response.json();
                    const pvPre = parseFloat(data.pv_pre);
                    if (pvPre && pvPre > 0) {
                        currentPVPre = pvPre;
                        console.log(`📊 Loaded PV_pre: $${pvPre.toFixed(2)}`);
                        return pvPre;
                    } else {
                        console.log('⚠️ Invalid PV_pre in pre_execution.json, using initial capital');
                        return initialCapital;
                    }
                } else {
                    console.log('⚠️ No pre_execution.json available, using initial capital');
                    return initialCapital;
                }
            } catch (error) {
                console.error('Error loading PV_pre:', error);
                return initialCapital; // Fallback to initial capital
            }
        }

        // Load current mark prices from S3 latest_prices.json
        async function fetchCurrentPrices(positions) {
            try {
                console.log('🔍 Loading current prices from S3 latest_prices.json...');
                const response = await fetch('/signal-dashboard/data/latest_prices.json');
                const data = await response.json();

                const currentPrices = {};
                const symbols = positions.map(p => (p.ticker || p.ric || p.internal_code).replace('_', ''));

                // Map symbols to prices from S3 data
                symbols.forEach(symbol => {
                    const price = data.prices[symbol];
                    if (price !== undefined && price !== null) {
                        currentPrices[symbol] = parseFloat(price);
                        console.log(`✅ ${symbol}: ${price}`);
                    } else {
                        console.log(`⚠️ No price for ${symbol}`);
                        currentPrices[symbol] = null;
                    }
                });

                console.log(`📊 Loaded ${Object.keys(currentPrices).length}/${symbols.length} prices from S3`);
                return currentPrices;
            } catch (error) {
                console.error('Error loading current prices from S3:', error);
                return {};
            }
        }

        // Create new snapshot (single source of truth)
        async function createSnapshot() {
            console.log('🔄 Creating new snapshot...', new Date().toISOString());
            console.log('🔍 CACHE BUST: Debug logs updated at 13:22:00 - VERSION 2.0');
            console.log('🔍 FORCE REFRESH: This should show the correct P&L calculation!');
            console.log('🔍 DEBUG: currentSnapshot.positions.length =', currentSnapshot.positions.length);
            console.log('🔍 DEBUG: currentSnapshot.baselinePrices keys =', Object.keys(currentSnapshot.baselinePrices || {}));
            console.log('🔍 DEBUG: currentSnapshot.currentPrices keys =', Object.keys(currentSnapshot.currentPrices || {}));
            
            if (currentSnapshot.positions.length === 0) {
                console.log('❌ No positions loaded yet');
                return;
            }
            
            // Load current prices from S3
            const currentPrices = await fetchCurrentPrices(currentSnapshot.positions);
            console.log('🔍 DEBUG: Fetched currentPrices keys =', Object.keys(currentPrices || {}));
            
            // Calculate Daily P&L (vs baseline)
            let dailyPnL = 0;
            let calculatedPositions = 0;
            console.log('🔍 Calculating Daily P&L...');
            
            currentSnapshot.positions.forEach((position, index) => {
                const symbol = (position.ticker || position.ric || position.internal_code).replace('_', '');
                const baselinePrice = currentSnapshot.baselinePrices[symbol];
                const currentPrice = currentPrices[symbol];
                const notional = parseFloat(position.target_notional || 0);
                const side = parseFloat(position.target_contracts) > 0 ? 1 : -1;
                
                console.log(`🔍 DEBUG Position ${index}: ${symbol}`, {
                    baselinePrice,
                    currentPrice,
                    notional,
                    side,
                    hasBaseline: !!baselinePrice,
                    hasCurrent: !!currentPrice,
                    target_contracts: position.target_contracts,
                    target_notional: position.target_notional
                });
                
                if (baselinePrice && currentPrice) {
                    const contracts = parseFloat(position.target_contracts);
                    const notional = parseFloat(position.target_notional || 0);
                    // FIXED: Use same calculation as table: percentage change * notional
                    const pnl = side * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    console.log(`🔍 CALCULATION FIX: ${symbol} = ${side} * (${currentPrice} - ${baselinePrice}) / ${baselinePrice} * ${Math.abs(notional)} = ${pnl.toFixed(2)}`);
                    dailyPnL += pnl;
                    calculatedPositions++;
                    
                    console.log(`🔍 ${symbol}: baseline=${baselinePrice}, current=${currentPrice}, side=${side}, notional=${Math.abs(notional)}, contracts=${contracts}, pnl=${pnl.toFixed(2)}`);
                    
                    // Log all positions, not just first 3
                    if (calculatedPositions <= 5) {
                        const priceDiff = currentPrice - baselinePrice;
                        const priceChangePercent = priceDiff / baselinePrice;
                        const calculatedPnl = side * priceChangePercent * Math.abs(notional);
                        
                        console.log(`🔍 FULL DEBUG ${symbol}:`, {
                            baselinePrice,
                            currentPrice,
                            priceDiff,
                            priceChangePercent: (priceChangePercent * 100).toFixed(4) + '%',
                            side,
                            notional: Math.abs(notional),
                            calculatedPnl: calculatedPnl.toFixed(2),
                            actualPnl: pnl.toFixed(2),
                            match: Math.abs(calculatedPnl - pnl) < 0.01
                        });
                    }
                } else {
                    console.log(`⚠️ Missing data for ${symbol}: baseline=${!!baselinePrice}, current=${!!currentPrice}`);
                }
            });
            
            console.log(`📊 Calculated ${calculatedPositions} positions, total P&L: ${dailyPnL.toFixed(2)}`);
            console.log('🔍 DEBUG: Final dailyPnL =', dailyPnL);
            console.log('🔍 DEBUG: calculatedPositions =', calculatedPositions);
            
            // Update snapshot
            currentSnapshot.timestamp = new Date();
            currentSnapshot.currentPrices = currentPrices;
            currentSnapshot.dailyPnL = dailyPnL;
            
            console.log('🔍 DEBUG: Updated currentSnapshot.dailyPnL =', currentSnapshot.dailyPnL);
            
            // Only set portfolio value if we don't have S3 data yet
            // If we have S3 data, keep the real portfolio value from S3 logs
            if (!currentSnapshot.portfolioValue || currentSnapshot.portfolioValue === initialCapital) {
                currentSnapshot.portfolioValue = initialCapital + dailyPnL;
                console.log('📊 Using calculated Portfolio Value (no S3 data yet)');
            } else {
                console.log(`📊 Keeping S3 Portfolio Value: $${currentSnapshot.portfolioValue.toFixed(2)}`);
            }
            
            // Update UI with this snapshot
            updateUI();
            
            // Log PV for chart
            logPortfolioValue();
        }

        // Update UI with current snapshot
        function updateUI() {
            const snapshot = currentSnapshot;
            console.log('🔍 DEBUG: updateUI called');
            console.log('🔍 DEBUG: currentSnapshot =', currentSnapshot);
            console.log('🔍 DEBUG: currentSnapshot.dailyPnL =', currentSnapshot?.dailyPnL);
            console.log('🔍 DEBUG: currentSnapshot.portfolioValue =', currentSnapshot?.portfolioValue);
            
            console.log('🔄 Updating UI with snapshot:', {
                timestamp: snapshot.timestamp?.toISOString(),
                portfolioValue: snapshot.portfolioValue,
                dailyPnL: snapshot.dailyPnL,
                currentPricesCount: Object.keys(snapshot.currentPrices || {}).length
            });
            console.log('🔄 UI Update timestamp:', new Date().toISOString());
            
            // Portfolio Value
            document.getElementById('portfolio-value').textContent = formatCurrency(snapshot.portfolioValue);
            const timeStr = snapshot.timestamp ? snapshot.timestamp.toISOString().substr(11, 8) + ' UTC' : 'Loading...';
            document.getElementById('portfolio-time').textContent = timeStr;
            
            // Add a visual indicator that updates are happening
            const timeElement = document.getElementById('portfolio-time');
            timeElement.style.backgroundColor = '#28a745';
            timeElement.style.color = 'white';
            timeElement.style.padding = '2px 6px';
            timeElement.style.borderRadius = '3px';
            setTimeout(() => {
                timeElement.style.backgroundColor = '';
                timeElement.style.color = '';
                timeElement.style.padding = '';
                timeElement.style.borderRadius = '';
            }, 1000);
            
            // Use PV_pre for percentage calculations if available, otherwise use initialCapital
            const referenceCapital = currentPVPre || initialCapital;

            // Daily P&L
            console.log('🔍 DEBUG: Setting Daily P&L to:', snapshot.dailyPnL);
            console.log('🔍 DEBUG: Using reference capital for %:', referenceCapital);
            document.getElementById('daily-pnl').textContent = formatCurrency(snapshot.dailyPnL);
            document.getElementById('daily-pnl').className = `value ${snapshot.dailyPnL >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('daily-pnl-percent').textContent = `(${formatPercentage((snapshot.dailyPnL / referenceCapital) * 100)})`;
            document.getElementById('daily-pnl-percent').className = `percentage ${snapshot.dailyPnL >= 0 ? 'positive' : 'negative'}`;

            // Total P&L Since Inception = Portfolio Value - $1,000,000
            const totalPnL = snapshot.portfolioValue - initialCapital;
            document.getElementById('total-pnl').textContent = formatCurrency(totalPnL);
            document.getElementById('total-pnl').className = `value ${totalPnL >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('total-pnl-percent').textContent = `(${formatPercentage((totalPnL / referenceCapital) * 100)})`;
            document.getElementById('total-pnl-percent').className = `percentage ${totalPnL >= 0 ? 'positive' : 'negative'}`;
            
            // Calculate Long/Short metrics
            const longShortMetrics = calculateLongShortMetrics(snapshot.positions);
            
            // Long Positions
            document.getElementById('long-notional').textContent = formatCurrency(longShortMetrics.longNotional);
            document.getElementById('long-pnl-percent').textContent = `(${formatCurrency(longShortMetrics.longPnL)})`;
            document.getElementById('long-pnl-percent').className = `percentage ${longShortMetrics.longPnL >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('long-count').textContent = `${longShortMetrics.longCount} positions`;
            
            // Short Positions
            document.getElementById('short-notional').textContent = formatCurrency(longShortMetrics.shortNotional);
            document.getElementById('short-pnl-percent').textContent = `(${formatCurrency(longShortMetrics.shortPnL)})`;
            document.getElementById('short-pnl-percent').className = `percentage ${longShortMetrics.shortPnL >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('short-count').textContent = `${longShortMetrics.shortCount} positions`;
            
            // Update total positions count
            const totalPositions = snapshot.positions ? snapshot.positions.length : 0;
            document.getElementById('total-positions-count').textContent = totalPositions.toString();
            
            // Update delta progress bar
            createDeltaProgressBar();
            
            // Update top performers
            updateTopPerformers();
            
            // Update table
            updatePositionsTable(referenceCapital);
        }

        // Update positions table
        function updatePositionsTable(referenceCapital) {
            const snapshot = currentSnapshot;
            if (snapshot.positions.length === 0) return;
            
            const longPositions = snapshot.positions.filter(p => parseFloat(p.target_contracts) > 0);
            const shortPositions = snapshot.positions.filter(p => parseFloat(p.target_contracts) < 0);
            
            populatePositionTable('long-positions', longPositions, snapshot, referenceCapital);
            populatePositionTable('short-positions', shortPositions, snapshot, referenceCapital);
        }

        function populatePositionTable(tableId, positions, snapshot, referenceCapital) {
            const tbody = document.getElementById(tableId);
            tbody.innerHTML = '';

            // Use fixed reference capital of $1,000,000 for calculations
            const refCap = initialCapital;

            positions.forEach(position => {
                const symbol = position.ticker || position.ric || position.internal_code || 'N/A';
                const binanceSymbol = symbol.replace('_', '');
                const entryPrice = parseFloat(position.ref_price || 0);
                const baselinePrice = snapshot.baselinePrices[binanceSymbol];
                const currentPrice = snapshot.currentPrices[binanceSymbol];
                const notional = parseFloat(position.target_notional || 0);
                const side = parseFloat(position.target_contracts) > 0 ? 'LONG' : 'SHORT';
                const weight = (Math.abs(notional) / refCap) * 100;
                
                let pnl = 0;
                let pnlPercent = 0;
                
                if (baselinePrice && currentPrice) {
                    const sideMultiplier = parseFloat(position.target_contracts) > 0 ? 1 : -1;
                    pnl = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    // Fix Issue #1: Correct P&L% calculation for shorts
                    pnlPercent = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * 100;
                }
                
                const row = document.createElement('tr');
                row.className = 'position-row';
                
                // Add winning position highlight
                if (pnl > 0) {
                    row.classList.add('winning');
                }
                
                // Add top performer highlight (top 3 by absolute P&L)
                const isTopPerformer = checkIfTopPerformer(symbol, pnl, side);
                if (isTopPerformer) {
                    row.classList.add('top-performer');
                }
                
                row.innerHTML = `
                    <td class="symbol" data-symbol="${symbol}">${symbol}</td>
                    <td class="${side === 'LONG' ? 'side-long' : 'side-short'}">${side}</td>
                    <td>${weight.toFixed(2)}%</td>
                    <td>${formatCurrency(Math.abs(notional))}</td>
                    <td>${entryPrice ? entryPrice.toFixed(6) : 'N/A'}</td>
                    <td>${currentPrice ? currentPrice.toFixed(6) : 'Loading...'}</td>
                    <td class="${pnl >= 0 ? 'positive' : 'negative'}">${formatCurrency(pnl)}</td>
                    <td class="${pnlPercent >= 0 ? 'positive' : 'negative'}">${pnlPercent.toFixed(2)}%</td>
                `;
                tbody.appendChild(row);
            });
        }

        // PV logging to S3 for persistence
        let pvLogs = [];
        
        async function logPortfolioValue() {
            const logEntry = {
                timestamp: currentSnapshot.timestamp.toISOString(),
                portfolioValue: currentSnapshot.portfolioValue,
                dailyPnL: currentSnapshot.dailyPnL
            };
            
            console.log('📊 Logging PV:', logEntry);
            
            // Store in browser memory for immediate chart update
            pvLogs.push(logEntry);
            
            // Keep only last 24 hours in memory
            const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
            pvLogs = pvLogs.filter(log => new Date(log.timestamp) > oneDayAgo);
            
            console.log(`📈 PV Logs: ${pvLogs.length} entries, latest: ${logEntry.portfolioValue}`);
            // Don't update chart here - let the S3 data stay visible
            // updateChart();
        }

        // Load historical PV data from S3 portfolio_value_log.jsonl
        async function loadHistoricalPVData(timeframe) {
            try {
                const response = await fetch('/signal-dashboard/data/portfolio_value_log.jsonl');
                if (!response.ok) {
                    console.log('No S3 PV data available yet');
                    return [];
                }
                
                const text = await response.text();
                console.log('📄 Raw S3 text length:', text.length);
                
                const lines = text.trim().split('\n').filter(line => line.trim());
                console.log('📄 S3 lines count:', lines.length);
                
                const data = lines.map(line => {
                    try {
                        return JSON.parse(line);
                    } catch (e) {
                        console.error('❌ Error parsing line:', line);
                        return null;
                    }
                }).filter(item => item !== null);
                
                console.log(`📊 Loaded ${data.length} PV points from S3`);
                console.log('📊 First data point:', data[0]);
                console.log('📊 Last data point:', data[data.length - 1]);
                
                // Filter by timeframe - be more aggressive about filtering
                const now = new Date();
                let cutoffDate;
                switch(timeframe) {
                    case '1D':
                        cutoffDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                        break;
                    case '7D':
                        cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        break;
                    case '1M':
                        cutoffDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        break;
                    default:
                        cutoffDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                }
                
                const filteredData = data.filter(log => {
                    const logDate = new Date(log.timestamp);
                    return logDate >= cutoffDate && logDate <= now;
                });
                
                console.log(`📊 Filtered to ${filteredData.length} points for ${timeframe} timeframe`);
                console.log(`📊 Cutoff date: ${cutoffDate.toISOString()}`);
                console.log(`📊 Now: ${now.toISOString()}`);
                console.log(`📊 Data range: ${filteredData[0]?.timestamp} to ${filteredData[filteredData.length-1]?.timestamp}`);
                
                // Return filtered data sorted by timestamp
                return filteredData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
            } catch (error) {
                console.error('Error loading historical PV data:', error);
                return [];
            }
        }
        
        // Load chart data for different timeframes
        async function loadChartData(timeframe) {
            // Update button states
            document.querySelectorAll('.time-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[onclick="loadChartData('${timeframe}')"]`).classList.add('active');
            
            // Load historical data
            const historicalData = await loadHistoricalPVData(timeframe);
            
            // Use historical data directly (it's already the full dataset from S3)
            updateChart(historicalData, timeframe);
        }
        
        // Update chart with data
        function updateChart(data = pvLogs, timeframe = '1D') {
            // Always show chart, even with no data
            if (data.length === 0) {
                console.log('📊 No data available, showing empty chart');
                data = [{
                    timestamp: new Date().toISOString(),
                    portfolioValue: initialCapital,
                    daily_pnl: 0,
                    total_pnl: 0
                }];
            }
            
            console.log(`📊 Updating chart with ${data.length} data points`);
            
            const ctx = document.getElementById('portfolio-chart').getContext('2d');
            
            // Properly destroy existing chart
            if (portfolioChart) {
                portfolioChart.destroy();
                portfolioChart = null;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            try {
                // Create beautiful gradients
                const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
                gradient.addColorStop(0, 'rgba(102, 126, 234, 0.4)');
                gradient.addColorStop(0.5, 'rgba(102, 126, 234, 0.15)');
                gradient.addColorStop(1, 'rgba(102, 126, 234, 0.05)');

                // Create border gradient
                const borderGradient = ctx.createLinearGradient(0, 0, ctx.canvas.width, 0);
                borderGradient.addColorStop(0, 'rgba(102, 126, 234, 1)');
                borderGradient.addColorStop(0.5, 'rgba(118, 75, 162, 0.8)');
                borderGradient.addColorStop(1, 'rgba(102, 126, 234, 1)');
            
            portfolioChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Portfolio Value',
                            data: data.map(log => ({
                                x: new Date(log.timestamp),
                                y: log.portfolio_value || log.portfolioValue
                            })),
                            borderColor: borderGradient,
                            backgroundColor: gradient,
                            borderWidth: 3,
                            tension: 0.4,
                            fill: true,
                            pointRadius: 0,
                            pointHoverRadius: 8,
                            pointHoverBackgroundColor: 'rgba(255, 255, 255, 0.9)',
                            pointHoverBorderColor: 'rgba(102, 126, 234, 1)',
                            pointHoverBorderWidth: 3,
                            pointBackgroundColor: 'rgba(102, 126, 234, 0.8)',
                            pointBorderColor: 'rgba(255, 255, 255, 1)',
                            pointBorderWidth: 2,
                            shadowOffsetX: 0,
                            shadowOffsetY: 4,
                            shadowBlur: 12,
                            shadowColor: 'rgba(102, 126, 234, 0.3)'
                    }]
                },
                options: {
                    responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    usePointStyle: true,
                                    pointStyle: 'circle',
                                    padding: 20,
                                    font: {
                                        family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                        size: 13,
                                        weight: '600'
                                    },
                                    color: '#374151',
                                    boxWidth: 12,
                                    boxHeight: 12
                                }
                            },
                            tooltip: {
                                enabled: true,
                                backgroundColor: 'rgba(255, 255, 255, 0.98)',
                                titleColor: '#1f2937',
                                bodyColor: '#4b5563',
                                borderColor: 'rgba(102, 126, 234, 0.2)',
                                borderWidth: 1,
                                cornerRadius: 12,
                                displayColors: false,
                                titleFont: {
                                    family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                    size: 13,
                                    weight: '600'
                                },
                                bodyFont: {
                                    family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                    size: 12,
                                    weight: '500'
                                },
                                padding: 12,
                                caretSize: 6,
                                caretPadding: 8,
                                callbacks: {
                                    title: function(context) {
                                        const date = new Date(context[0].label);
                                        return date.toLocaleString('en-US', {
                                            weekday: 'short',
                                            month: 'short',
                                            day: 'numeric',
                                            hour: '2-digit',
                                            minute: '2-digit'
                                        });
                                    },
                                    label: function(context) {
                                        return `Portfolio: ${formatCurrency(context.parsed.y)}`;
                                    }
                                }
                            }
                        },
                    scales: {
                            x: {
                                type: 'time',
                                time: {
                                    displayFormats: (() => {
                                        switch(timeframe) {
                                            case '1D':
                                                return {
                                                    hour: 'HH:mm',
                                                    day: 'MMM dd'
                                                };
                                            case '7D':
                                                return {
                                                    day: 'MMM dd',
                                                    week: 'MMM dd'
                                                };
                                            case '1M':
                                                return {
                                                    day: 'MMM dd',
                                                    week: 'MMM dd',
                                                    month: 'MMM yyyy'
                                                };
                                            default:
                                                return {
                                                    hour: 'HH:mm',
                                                    day: 'MMM dd'
                                                };
                                        }
                                    })(),
                                    tooltipFormat: 'MMM dd HH:mm',
                                    unit: (() => {
                                        switch(timeframe) {
                                            case '1D': return 'hour';
                                            case '7D': return 'day';
                                            case '1M': return 'day';
                                            default: return 'hour';
                                        }
                                    })()
                                },
                                grid: {
                                    display: true,
                                    color: 'rgba(226, 232, 240, 0.6)',
                                    lineWidth: 1,
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#6b7280',
                                    font: {
                                        family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                        size: 11,
                                        weight: '500'
                                    },
                                    maxRotation: 45,
                                    minRotation: 0,
                                    padding: 8,
                                    maxTicksLimit: (() => {
                                        switch(timeframe) {
                                            case '1D': return 12;
                                            case '7D': return 7;
                                            case '1M': return 15;
                                            default: return 12;
                                        }
                                    })()
                                },
                                // Set explicit time boundaries based on timeframe
                                min: (() => {
                                    const now = new Date();
                                    switch(timeframe) {
                                        case '1D': 
                                            return new Date(now.getTime() - 24 * 60 * 60 * 1000);
                                        case '7D': 
                                            return new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                                        case '1M': 
                                            return new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                                        default: 
                                            return new Date(now.getTime() - 24 * 60 * 60 * 1000);
                                    }
                                })(),
                                max: new Date(),
                                border: {
                                    display: false
                                }
                            },
                        y: {
                            beginAtZero: false,
                                grid: {
                                    display: true,
                                    color: 'rgba(226, 232, 240, 0.6)',
                                    lineWidth: 1,
                                    drawBorder: false
                                },
                            ticks: {
                                    color: '#6b7280',
                                    font: {
                                        family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                        size: 11,
                                        weight: '500',
                                        variant: 'tabular-nums'
                                    },
                                    padding: 12,
                                callback: function(value) {
                                    return formatCurrency(value);
                                    }
                                },
                                border: {
                                    display: false
                                }
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        animation: {
                            duration: 1500,
                            easing: 'easeInOutQuart',
                            delay: (context) => {
                                let delay = 0;
                                if (context.type === 'data' && context.mode === 'default') {
                                    delay = context.dataIndex * 50;
                                }
                                return delay;
                            }
                        },
                        elements: {
                            line: {
                                shadowOffsetX: 0,
                                shadowOffsetY: 4,
                                shadowBlur: 12,
                                shadowColor: 'rgba(102, 126, 234, 0.3)'
                            }
                        }
                    }
                });
                
                console.log('📊 Beautiful chart updated successfully');
            } catch (error) {
                console.error('❌ Chart creation failed:', error);
                // Show a beautiful fallback message
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif';
                ctx.fillStyle = '#6b7280';
                ctx.fillText('Chart temporarily unavailable', 50, 50);
            }
        }

        // Delta Donut Chart
        let deltaDonutChart = null;
        
        function createDeltaProgressBar() {
            // Calculate portfolio delta using corrected formula
            const deltaData = calculatePortfolioDelta();
            const { netDelta, netDeltaPercent, grossExposure } = deltaData;
            
            // Update delta display
            document.getElementById('delta-value').textContent = formatCurrency(netDelta);
            document.getElementById('delta-percentage').textContent = `${Math.abs(netDeltaPercent).toFixed(1)}%`;
            
            // Calculate progress bar position (0-100%)
            // Convert -50% to +50% delta range to 0-100% progress bar
            const normalizedDelta = Math.max(-50, Math.min(50, netDeltaPercent));
            const progressPosition = ((normalizedDelta + 50) / 100) * 100; // 0-100%
            
            // Update progress bar fill
            const progressFill = document.getElementById('delta-progress-fill');
            const progressIndicator = document.getElementById('delta-progress-indicator');
            
            // Set fill width based on long/short balance
            const longPercentage = (deltaData.totalLongNotional / grossExposure) * 100;
            const shortPercentage = (deltaData.totalShortNotional / grossExposure) * 100;
            
            // Progress bar shows long exposure (from left)
            progressFill.style.width = `${longPercentage}%`;
            progressFill.style.backgroundColor = netDeltaPercent >= 0 ? 
                'rgba(102, 126, 234, 0.3)' : 'rgba(239, 68, 68, 0.3)';
            
            // Indicator shows net delta position
            progressIndicator.style.left = `${progressPosition}%`;
            progressIndicator.style.backgroundColor = netDeltaPercent >= 0 ? 
                'rgba(102, 126, 234, 1)' : 'rgba(239, 68, 68, 1)';
        }
        
        function calculatePortfolioDelta() {
            if (!currentSnapshot.positions) return { netDelta: 0, netDeltaPercent: 0, grossExposure: 0 };
            
            let totalLongNotional = 0;
            let totalShortNotional = 0;
            let totalNotional = 0;
            
            currentSnapshot.positions.forEach(position => {
                const notional = parseFloat(position.target_notional);
                const contracts = parseFloat(position.target_contracts);
                
                if (notional && contracts) {
                    totalNotional += Math.abs(notional);
                    
                    if (contracts > 0) {
                        // Long position
                        totalLongNotional += Math.abs(notional);
                    } else {
                        // Short position
                        totalShortNotional += Math.abs(notional);
                    }
                }
            });
            
            const netDelta = totalLongNotional - totalShortNotional;
            const netDeltaPercent = totalNotional > 0 ? (netDelta / totalNotional) * 100 : 0;
            
            return {
                netDelta,
                netDeltaPercent,
                grossExposure: totalNotional,
                totalLongNotional,
                totalShortNotional
            };
        }
        
        function calculateLongShortMetrics(positions) {
            console.log('🔍 calculateLongShortMetrics called with:', {
                positions: positions ? positions.length : 0,
                currentPrices: currentSnapshot.currentPrices ? Object.keys(currentSnapshot.currentPrices).length : 0,
                baselinePrices: currentSnapshot.baselinePrices ? Object.keys(currentSnapshot.baselinePrices).length : 0
            });
            
            if (!positions || !currentSnapshot.currentPrices || !currentSnapshot.baselinePrices) {
                console.log('⚠️ Missing data in calculateLongShortMetrics');
                return { 
                    longNotional: 0, longPnL: 0, longCount: 0,
                    shortNotional: 0, shortPnL: 0, shortCount: 0 
                };
            }
            
            let longNotional = 0;
            let longPnL = 0;
            let longCount = 0;
            let shortNotional = 0;
            let shortPnL = 0;
            let shortCount = 0;
            
            positions.forEach(position => {
                const notional = parseFloat(position.target_notional);
                const contracts = parseFloat(position.target_contracts);
                const entryPrice = parseFloat(position.ref_price);
                
                // Get current price from currentSnapshot.currentPrices
                const symbol = (position.ticker || position.ric || position.internal_code).replace('_', '');
                const currentPrice = currentSnapshot.currentPrices[symbol];
                const baselinePrice = currentSnapshot.baselinePrices[symbol];
                
                if (notional && contracts && entryPrice && currentPrice && baselinePrice) {
                    // Calculate P&L for this position using baseline vs current
                    const sideMultiplier = contracts > 0 ? 1 : -1; // 1 for long, -1 for short
                    const pnl = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    
                    if (contracts > 0) {
                        // Long position
                        longNotional += Math.abs(notional);
                        longPnL += pnl;
                        longCount++;
                    } else {
                        // Short position
                        shortNotional += Math.abs(notional);
                        shortPnL += pnl;
                        shortCount++;
                    }
                }
            });
            
            const result = {
                longNotional,
                longPnL,
                longCount,
                shortNotional,
                shortPnL,
                shortCount
            };
            
            console.log('📊 calculateLongShortMetrics result:', result);
            return result;
        }
        
        // Top Performers
        function updateTopPerformers() {
            if (!currentSnapshot.positions || !currentSnapshot.currentPrices || !currentSnapshot.baselinePrices) return;
            
            const positions = currentSnapshot.positions.map(position => {
                const symbol = (position.ticker || position.ric || position.internal_code).replace('_', '');
                const currentPrice = currentSnapshot.currentPrices[symbol];
                const baselinePrice = currentSnapshot.baselinePrices[symbol];
                const notional = parseFloat(position.target_notional);
                const contracts = parseFloat(position.target_contracts);
                
                if (currentPrice && baselinePrice && notional && contracts) {
                    const sideMultiplier = contracts > 0 ? 1 : -1;
                    const pnl = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    return {
                        ...position,
                        symbol: position.ticker || position.ric || position.internal_code,
                        pnl,
                        side: contracts > 0 ? 'LONG' : 'SHORT'
                    };
                }
                return null;
            }).filter(p => p !== null);
            
            // Separate longs and shorts
            const longs = positions.filter(p => p.side === 'LONG').sort((a, b) => b.pnl - a.pnl);
            const shorts = positions.filter(p => p.side === 'SHORT').sort((a, b) => b.pnl - a.pnl);
            
            // Update top 3 for each
            updateTopPerformersList('top-long-performers', longs.slice(0, 3));
            updateTopPerformersList('top-short-performers', shorts.slice(0, 3));
        }
        
        function updateTopPerformersList(containerId, performers) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.innerHTML = '';
            
            if (performers.length === 0) {
                container.innerHTML = '<div class="loading">No data available</div>';
                return;
            }
            
            performers.forEach((performer, index) => {
                const item = document.createElement('div');
                item.className = 'top-performer-item';
                item.innerHTML = `
                    <span class="top-performer-rank">${index + 1}</span>
                    <span class="top-performer-symbol symbol" data-symbol="${performer.symbol}">${performer.symbol}</span>
                    <span class="top-performer-pnl ${performer.pnl >= 0 ? 'positive' : 'negative'}">${formatCurrency(performer.pnl)}</span>
                `;
                container.appendChild(item);
            });
        }
        
        // Check if position is in top 3 performers
        function checkIfTopPerformer(symbol, pnl, side) {
            if (!currentSnapshot.positions || !currentSnapshot.currentPrices || !currentSnapshot.baselinePrices) return false;
            
            // Get all positions with their P&L
            const allPositions = currentSnapshot.positions.map(position => {
                const posSymbol = (position.ticker || position.ric || position.internal_code).replace('_', '');
                const currentPrice = currentSnapshot.currentPrices[posSymbol];
                const baselinePrice = currentSnapshot.baselinePrices[posSymbol];
                const notional = parseFloat(position.target_notional);
                const contracts = parseFloat(position.target_contracts);
                
                if (currentPrice && baselinePrice && notional && contracts) {
                    const sideMultiplier = contracts > 0 ? 1 : -1;
                    const posPnl = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    const posSide = contracts > 0 ? 'LONG' : 'SHORT';
                    return { symbol: posSymbol, pnl: posPnl, side: posSide };
                }
                return null;
            }).filter(p => p !== null);
            
            // Filter by side and sort by absolute P&L
            const sameSidePositions = allPositions.filter(p => p.side === side);
            const top3 = sameSidePositions.sort((a, b) => Math.abs(b.pnl) - Math.abs(a.pnl)).slice(0, 3);
            
            return top3.some(top => top.symbol === symbol);
        }

        // Utility functions
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value);
        }

        function formatPercentage(value) {
            return `${value >= 0 ? '+' : ''}${value.toFixed(2)}%`;
        }

        // Check for new CSV periodically
        async function checkForNewCSV() {
            const csvChanged = await loadDailyCSV();
            if (csvChanged) {
                console.log('🔄 New CSV detected - creating fresh snapshot');
                await createSnapshot();
            }
        }

        // Initialize
        updateTime();
        setInterval(updateTime, 1000);
        
        // Load historical PV data from S3 first, THEN load CSV and start snapshots
        loadHistoricalPVData('1D').then(historicalData => {
            console.log(`📊 Loaded ${historicalData.length} historical PV points from S3`);
            console.log('📊 S3 Data:', historicalData);
            pvLogs = historicalData;
            
            // Update portfolio value from latest S3 data
            if (historicalData.length > 0) {
                const latestPV = historicalData[historicalData.length - 1].portfolio_value || historicalData[historicalData.length - 1].portfolioValue;
                if (latestPV && currentSnapshot) {
                    currentSnapshot.portfolioValue = latestPV;
                    console.log(`📊 Updated Portfolio Value from S3: $${latestPV.toFixed(2)}`);
                }
            }
            
            updateChart(historicalData, '1D'); // Pass the data directly to show full chart

            // Load PV_pre for accurate percentage calculations
            loadPVPre().then(() => {
                console.log('📊 PV_pre loaded for percentage calculations');
            }).catch(error => {
                console.error('Error loading PV_pre:', error);
            });

            // NOW load CSV and start snapshots (after S3 data is loaded)
            loadDailyCSV().then(() => {
                // Create initial snapshot (S3 PV should be set by now)
                createSnapshot();
                
                // Update positions and P&L every 10 seconds (tick by tick) - faster for testing
                setInterval(createSnapshot, 10 * 1000);
                
                // Check for new CSV every 10 minutes (around execution time)
                setInterval(checkForNewCSV, 10 * 60 * 1000);
                
                // Update chart every 5 minutes with fresh S3 data
                setInterval(updateChartFromS3, 5 * 60 * 1000);
            });
            
        }).catch(error => {
            console.error('Error loading historical data:', error);
            console.log('📊 Initializing chart with empty data');
            pvLogs = [];
            updateChart(); // This will show the placeholder chart
            
            // Still load CSV even if S3 fails
            loadPVPre().then(() => {
                console.log('📊 PV_pre loaded for fallback mode');
            }).catch(error => {
                console.error('Error loading PV_pre in fallback:', error);
            });

            loadDailyCSV().then(() => {
                createSnapshot();
                setInterval(createSnapshot, 10 * 1000);
                setInterval(checkForNewCSV, 10 * 60 * 1000);
                setInterval(updateChartFromS3, 5 * 60 * 1000);
            });
        });
        // CSV info toggle function
        function toggleCSVInfo() {
            const filename = document.getElementById('csv-filename');
            if (filename.style.display === 'none') {
                filename.style.display = 'inline';
            } else {
                filename.style.display = 'none';
            }
        }
        
        // Update CSV filename when data loads
        function updateCSVFilename(filename) {
            const csvElement = document.getElementById('csv-filename');
            if (csvElement) {
                csvElement.textContent = filename || 'No CSV loaded';
            }
        }
        
        // Update chart from S3 data every 5 minutes
        async function updateChartFromS3() {
            console.log('🔄 Updating chart from S3 data...');
            try {
                const response = await fetch('/signal-dashboard/data/portfolio_value_log.jsonl');
                if (response.ok) {
                    const text = await response.text();
                    const lines = text.trim().split('\n').filter(line => line.trim());
                    const s3Data = lines.map(line => JSON.parse(line));
                    
                    // Update pvLogs with fresh S3 data
                    pvLogs = s3Data;
                    
                    // Update portfolio value from latest S3 data
                    if (s3Data.length > 0) {
                        const latestPV = s3Data[s3Data.length - 1].portfolio_value || s3Data[s3Data.length - 1].portfolioValue;
                        if (latestPV && currentSnapshot) {
                            currentSnapshot.portfolioValue = latestPV;
                            console.log(`📊 Updated Portfolio Value from S3 refresh: $${latestPV.toFixed(2)}`);
                            
                            // Update UI with new portfolio value
                            updateUI();
                        }
                    }
                    
                    // Update chart with current timeframe only if data has changed
                    const activeButton = document.querySelector('.time-button.active');
                    const timeframe = activeButton ? activeButton.textContent : '1D';
                    updateChart(s3Data, timeframe);
                    
                    console.log(`📊 Chart updated with ${s3Data.length} data points from S3`);
                } else {
                    console.log('⚠️ No S3 data available yet, keeping current chart');
                    // Don't update chart if S3 data is not available, keep current data
                }
            } catch (error) {
                console.error('Error updating chart from S3:', error);
                console.log('📊 Keeping current chart data due to error');
                // Don't update chart on error, keep current data
            }
        }
    </script>
    
    <style>
        .chart-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .csv-info { cursor: pointer; padding: 0.25rem 0.5rem; border-radius: 4px; transition: background-color 0.2s; }
        .csv-info:hover { background-color: #f8f9fa; }
        .csv-indicator { font-size: 1.2rem; margin-right: 0.5rem; }
        .csv-filename { font-size: 0.85rem; color: #6c757d; font-family: monospace; }
        .refresh-button {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(248, 250, 252, 0.9) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(226, 232, 240, 0.8);
            color: #64748b;
            border: none;
            padding: 10px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .refresh-button:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, rgba(248, 250, 252, 1) 100%);
            border-color: rgba(102, 126, 234, 0.3);
            color: #475569;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.12);
            transform: translateY(-1px);
        }
        .refresh-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .refresh-button svg {
            transition: transform 0.3s ease;
        }
        .refresh-button:hover svg {
            transform: rotate(180deg);
        }
    </style>
</body>
</html>
