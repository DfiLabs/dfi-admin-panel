<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Monitor</title>
    <script>
      (function(){
        try {
          var isDemo = location.hostname.indexOf('demo.dfi-labs.com') !== -1 || location.hostname.indexOf('pulse.dfi-labs.com') !== -1;
          if (isDemo) {
            document.title = 'Descartes – Strategy Monitor';
            window.addEventListener('DOMContentLoaded', function(){
              var h1 = document.querySelector('.dashboard-header h1');
              var p = document.querySelector('.dashboard-header p');
              if (h1) h1.textContent = 'Descartes – Live Dashboard';
              if (p) p.textContent = 'Real-time monitoring for Descartes (DFI Labs)';
            });
          }
        } catch(e) {}
      })();
    </script>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
    <header class="header">
        <div class="container">
            <div class="logo">
                <img src="assets/images/dfi-labs-logo.png" alt="DFI Labs" class="logo-image">
                <div class="logo-text">
                    <span class="logo-main">Strategy Monitor</span>
                    <span class="logo-subtitle">DFI Labs</span>
                </div>
            </div>
            <div class="header-info">
                <div class="status-indicator">
                    <div class="status-dot active"></div>
                    <span>Live</span>
                </div>
                <span id="current-time">Loading...</span>
            </div>
        </div>
    </header>

    <main class="main">
        <div class="container">
            <div class="dashboard-header">
                <h1>Live Portfolio Dashboard</h1>
                <p>Real-time cryptocurrency strategy monitoring & performance tracking</p>
                <div style="margin-top:8px">
                    <label for="strategy-select" style="font-weight:600;margin-right:8px;color:#6b7280">Strategy</label>
                    <select id="strategy-select" style="padding:10px 14px;border:1px solid #e5e7eb;border-radius:10px;background:#fff;color:#111827">
                        <option value="/signal-dashboard/data/">Descartes Diversified</option>
                        <option value="/signal-dashboard/descartes-beta/data/">Descartes Beta</option>
                        <option value="/signal-dashboard/descartes-ridge-unravel/data/">Descartes Reg</option>
                    </select>
                </div>
            </div>

            <!-- Delta Donut Chart -->
            <div class="delta-donut-section">
                <div class="delta-donut-card">
                    <div class="delta-header">
                        <h3>Portfolio Exposure</h3>
                        <div class="delta-status">
                            <span class="delta-label">NET EXPOSURE</span>
                            <span class="delta-value" id="delta-value">Loading...</span>
                        </div>
                    </div>
                    <div class="delta-progress-container">
                        <div class="delta-progress-bar">
                            <div class="delta-progress-fill" id="delta-progress-fill"></div>
                            <div class="delta-progress-indicator" id="delta-progress-indicator"></div>
                        </div>
                        <div class="delta-progress-labels">
                            <span class="delta-label-left">SHORT</span>
                            <span class="delta-label-right">LONG</span>
                        </div>
                        <div class="delta-progress-value">
                            <span id="delta-percentage">0%</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Core Metrics Row 1 (5 cards) -->
            <div class="summary-cards">
                <div class="card primary-metric" data-formula-key="portfolio-value">
                    <h3>Portfolio Value</h3>
                    <div class="value" id="portfolio-value">Loading...</div>
                    <div class="subtitle">as of <span id="portfolio-time">Loading...</span></div>
                </div>
                <div class="card" data-formula-key="daily-pnl">
                    <h3>Daily P&L</h3>
                    <div class="value" id="daily-pnl">Loading...</div>
                    <div class="percentage" id="daily-pnl-percent"></div>
                </div>
                <div class="card" data-formula-key="total-pnl">
                    <h3>Total P&L Since Inception</h3>
                    <div class="value" id="total-pnl">Loading...</div>
                    <div class="percentage" id="total-pnl-percent"></div>
                </div>
                <div class="card" data-formula-key="positions">
                    <h3>Positions</h3>
                    <div class="value" id="total-positions-count">Loading...</div>
                    <div class="subtitle">Total Open Positions</div>
                </div>
                <div class="card" data-formula-key="avg-daily-return">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
                        <h3>Average Daily Return</h3>
                        <div class="card-controls" style="display:flex; align-items:center; gap:6px;">
                            <button type="button" class="time-button metric-toggle" data-target="avg" data-tf="7D">7D</button>
                            <button type="button" class="time-button metric-toggle active" data-target="avg" data-tf="90D">90D</button>
                            <button type="button" class="time-button metric-toggle" data-target="avg" data-tf="SI">SI</button>
                        </div>
                    </div>
                    <div class="value" id="avg-daily-return">Loading...</div>
                    <div class="subtitle" id="avg-daily-return-meta"></div>
                </div>
            </div>

            <!-- Core Metrics Row 2 (5 cards) -->
            <div class="summary-cards">
                <div class="card long-position" data-formula-key="long-positions">
                    <h3>Long Positions</h3>
                    <div class="value" id="long-notional">Loading...</div>
                    <div class="percentage" id="long-pnl-percent"></div>
                    <div class="subtitle" id="long-count">0 positions</div>
                </div>
                <div class="card short-position" data-formula-key="short-positions">
                    <h3>Short Positions</h3>
                    <div class="value" id="short-notional">Loading...</div>
                    <div class="percentage" id="short-pnl-percent"></div>
                    <div class="subtitle" id="short-count">0 positions</div>
                </div>
                <div class="card" data-formula-key="avg-pnl-per-trade">
                    <h3>Avg P&L per Trade</h3>
                    <div class="value" id="avg-pnl-per-trade">Loading...</div>
                    <div class="subtitle" id="avg-pnl-trade-meta"></div>
                </div>
                <div class="card" data-formula-key="vol-ann">
                    <h3>Volatility (Ann.)</h3>
                    <div class="value" id="vol-ann">Loading...</div>
                    <div class="subtitle" id="vol-ann-meta"></div>
                </div>
                <div class="card" data-formula-key="sharpe-ann">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
                        <h3>Sharpe (Ann.)</h3>
                        <div class="card-controls" style="display:flex; align-items:center; gap:6px;">
                            <button type="button" class="time-button metric-toggle" data-target="sharpe" data-tf="7D">7D</button>
                            <button type="button" class="time-button metric-toggle active" data-target="sharpe" data-tf="90D">90D</button>
                            <button type="button" class="time-button metric-toggle" data-target="sharpe" data-tf="SI">SI</button>
                        </div>
                    </div>
                    <div class="value" id="sharpe-ann">Loading...</div>
                    <div class="subtitle" id="sharpe-ann-meta"></div>
                </div>
            </div>

            <!-- Formula Modal -->
            <div id="formula-modal" class="formula-modal hidden" onclick="hideFormula()">
                <div class="formula-content" onclick="event.stopPropagation()">
                    <div class="formula-title" id="formula-title">Formula</div>
                    <div class="formula-text" id="formula-text">Loading...</div>
                    <div style="margin-top:12px; text-align:right">
                        <button class="formula-close" onclick="hideFormula()">Close</button>
                    </div>
                </div>
            </div>

            <!-- Portfolio Value Chart with Time Scales -->
            <div class="chart-section">
                <div class="chart-header">
                    <h2>Portfolio Performance</h2>
                    <button id="csv-toggle" class="csv-toggle" title="Show CSV source and load time">📊</button>
                    <div class="download-widget">
                        <button id="download-btn" class="download-button" title="Download Daily % Returns">Download</button>
                        <div id="download-popover" class="download-popover" hidden>
                            <div class="dw-header">
                                <span class="dw-title">Download data</span>
                                <button id="dw-x" class="dw-x" aria-label="Close">×</button>
                            </div>
                            <div class="dw-row">
                                <label class="dw-label">Range</label>
                                <div class="dw-range">
                                    <input type="date" id="dw-start" />
                                    <span class="dw-sep">to</span>
                                    <input type="date" id="dw-end" />
                                </div>
                            </div>
                            <div class="dw-row dw-presets">
                                <button type="button" data-preset="7">7D</button>
                                <button type="button" data-preset="30" class="active">30D</button>
                                <button type="button" data-preset="90">90D</button>
                                <button type="button" data-preset="all">All</button>
                            </div>
                            <div class="dw-row">
                                <label class="dw-label">Series</label>
                                <select id="dw-series">
                                    <option value="daily_returns" selected>Daily % Return</option>
                                    <option value="daily_pv">Daily Portfolio Value</option>
                                    <option value="daily_vs_btc">Daily % Return + BTC % Return</option>
                                </select>
                            </div>
                            <div class="dw-row">
                                <label class="dw-label">Format</label>
                                <select id="dw-format">
                                    <option value="csv" selected>CSV</option>
                                    <option value="json">JSON</option>
                                </select>
                            </div>
                            <div class="dw-row dw-note">UTC • Strategy-aware</div>
                            <div class="dw-row dw-actions">
                                <button id="dw-download" class="primary" type="button">Download</button>
                                <button id="dw-close" class="secondary" type="button">Close</button>
                            </div>
                        </div>
                    </div>
                    <div class="csv-info" id="csv-info" title="" hidden>
                        <span class="csv-indicator">📊</span>
                        <span class="csv-filename" id="csv-filename">Loading...</span>
                    </div>
                </div>
                <div class="chart-controls">
                    <button class="time-button active" onclick="loadChartData('1D')">1D</button>
                    <button class="time-button" onclick="loadChartData('7D')">7D</button>
                    <button class="time-button" onclick="loadChartData('1M')">1M</button>
                    <button class="time-button" onclick="loadChartData('SI')">SI</button>
                    <button class="refresh-button" onclick="createSnapshot()" title="Force Update Now">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="23 4 23 10 17 10"></polyline>
                            <polyline points="1 20 1 14 7 14"></polyline>
                            <path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>
                        </svg>
                    </button>
                </div>
                <div class="chart-container">
                    <canvas id="portfolio-chart"></canvas>
                </div>
            </div>

            <!-- Monthly Returns (pulse/demo only) -->
            <div id="monthly-returns-section" class="monthly-section" style="display:none; margin-top:16px;">
                <h3 style="margin:8px 0 10px 0;">Strategy - Monthly Returns (%)</h3>
                <div class="monthly-table-wrapper">
                    <table class="monthly-table">
                        <thead id="monthly-thead"></thead>
                        <tbody id="monthly-tbody"></tbody>
                    </table>
                </div>
            </div>

            <!-- Risk Metrics Cards (Corr vs BTC, Hit Rate, Max Drawdown) -->
            <div id="risk-cards-row" class="summary-cards">
                <div class="card" data-formula-key="risk-corr">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
                        <h3>Corr vs BTC</h3>
                        <div class="card-controls" style="display:flex; align-items:center; gap:6px;">
                            <button type="button" class="icon-info" data-info="corr" title="What is this?">i</button>
                            <button type="button" class="time-button risk-toggle active" data-tf="90D">90D</button>
                            <button type="button" class="time-button risk-toggle" data-tf="SI">SI</button>
                        </div>
                    </div>
                    <div class="value" id="risk-corr">Loading...</div>
                </div>
                <div class="card" data-formula-key="risk-hit">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
                        <h3>Hit Rate</h3>
                        <button type="button" class="icon-info" data-info="hit" title="What is this?">i</button>
                    </div>
                    <div class="value" id="risk-hit">Loading...</div>
                </div>
                <div class="card" data-formula-key="risk-mdd">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
                        <h3>Max Drawdown</h3>
                        <div class="card-controls" style="display:flex; align-items:center; gap:6px;">
                            <button type="button" class="icon-info" data-info="mdd" title="What is this?">i</button>
                            <button type="button" class="time-button risk-toggle" data-tf="90D">90D</button>
                            <button type="button" class="time-button risk-toggle" data-tf="SI">SI</button>
                        </div>
                    </div>
                    <div class="value" id="risk-mdd" title="Daily EOD close-to-close max peak-to-trough over selected scope">Loading...</div>
                </div>
            </div>

            <!-- Top Performers -->
            <div class="top-performers">
                <div class="top-performers-card longs">
                    <h4>Top Long Performers</h4>
                    <div id="top-long-performers">
                        <div class="loading">Loading top long performers...</div>
                    </div>
                </div>
                <div class="top-performers-card shorts">
                    <h4>Top Short Performers</h4>
                    <div id="top-short-performers">
                        <div class="loading">Loading top short performers...</div>
                    </div>
                </div>
            </div>

            <!-- Positions Table -->
            <div class="positions-section">
                <h2>Long Positions</h2>
                <div class="positions-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Side</th>
                                <th class="sortable" data-table="long" data-key="weight">Weight %</th>
                                <th class="sortable" data-table="long" data-key="notional">Notional $</th>
                                <th>Entry Price</th>
                                <th>Mark Price</th>
                                <th class="sortable" data-table="long" data-key="pnl">Daily P&L $</th>
                                <th class="sortable" data-table="long" data-key="pnlPct">Daily P&L %</th>
                            </tr>
                        </thead>
                        <tbody id="long-positions">
                            <tr><td colspan="8" class="loading">Loading long positions...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="positions-section">
                <h2>Short Positions</h2>
                <div class="positions-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Side</th>
                                <th class="sortable" data-table="short" data-key="weight">Weight %</th>
                                <th class="sortable" data-table="short" data-key="notional">Notional $</th>
                                <th>Entry Price</th>
                                <th>Mark Price</th>
                                <th class="sortable" data-table="short" data-key="pnl">Daily P&L $</th>
                                <th class="sortable" data-table="short" data-key="pnlPct">Daily P&L %</th>
                            </tr>
                        </thead>
                        <tbody id="short-positions">
                            <tr><td colspan="8" class="loading">Loading short positions...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </main>
    <script>
        // Core state - single source of truth
        let DATA_PREFIX = localStorage.getItem('DATA_PREFIX') || '/signal-dashboard/data/';
        const IS_DEMO = (typeof location !== 'undefined') && (location.hostname.includes('demo.dfi-labs.com') || location.hostname.includes('pulse.dfi-labs.com'));
        const IS_PULSE = (typeof location !== 'undefined') && location.hostname.includes('pulse.dfi-labs.com');
        const DIAG = (typeof location !== 'undefined') && new URLSearchParams(location.search).has('diag');
        // Pulse-only access gate: require magic-link session cookie
        (function gate(){
            try {
                if (IS_PULSE) {
                    const hasSession = document.cookie.split(';').some(c => c.trim().startsWith('pulse_session='));
                    if (!hasSession) {
                        const next = encodeURIComponent('/signal-dashboard/');
                        location.replace(`/pulse/access/index.html?next=${next}`);
                        return; // stop further init on gated view
                    }
                }
            } catch (e) { /* fail open: never block admin/demo */ }
        })();
        // Force Pulse path (CF maps /signal-dashboard/* -> /descartes-ml/signal-dashboard/*)
        DATA_PREFIX = '/signal-dashboard/data/';
        try { localStorage.setItem('DATA_PREFIX', DATA_PREFIX); } catch (e) {}
        console.log('🔗 DATA_PREFIX =', DATA_PREFIX);

        // Helper to resolve a symbol safely from a position row
        function resolveSymbolFromPosition(p) {
            try {
                const raw = (p && (p.symbol || p.ticker || p.ric || p.internal_code || p.name));
                if (!raw) {
                    console.log('⚠️ Missing symbol in position row:', p);
                    return null;
                }
                return String(raw).replace('_','').replace('-','');
            } catch (err) {
                console.log('⚠️ Error resolving symbol from position:', err, p);
                return null;
            }
        }
        let currentSnapshot = {
            timestamp: null,
            portfolioValue: 1000000, // Start with $1M
            dailyPnL: 0,
            s3DailyPnL: null,
            s3TotalPnL: null,
            positions: [],
            baselinePrices: {},
            currentPrices: {}
        };
        // Preserve last successfully computed Daily P&L to avoid brief 0 flashes between price fetches
        let lastGoodDailyPnL = null;

        const initialCapital = 1000000;
        // Global fallback for legacy code paths that may reference `referenceCapital`
        // Ensures no ReferenceError even if an older cached snippet uses the symbol
        // Local scopes can still shadow this with their own `const referenceCapital`
        var referenceCapital = initialCapital;
        if (typeof window !== 'undefined') {
            window.referenceCapital = initialCapital;
        }
        let currentPVPre = null; // Will be loaded from pre_execution.json
        let portfolioChart = null;
        let currentTimeframe = '1D';

        // Update time display
        function updateTime() {
            const now = new Date();
            const utcTime = now.toISOString().substr(11, 8);
            const parisTime = new Date(now.getTime() + (2 * 60 * 60 * 1000)).toISOString().substr(11, 8);
            document.getElementById('current-time').textContent = `${utcTime} / ${parisTime} UTC / Paris`;
        }

        // Track current CSV to detect changes
        let currentCSVFilename = null;
        let currentCSVUploadedUtc = null;
        
        // Load current positions from latest.json (single source of truth)
        async function loadDailyCSV() {
            try {
                // Primary source: latest.json (authoritative for both strategies)
                const latestRes = await fetch(`${DATA_PREFIX}latest.json?cb=${Date.now()}`, { cache: 'no-store' });
                if (!latestRes.ok) {
                    console.log('⚠️ latest.json not found, falling back to pre_execution.json');
                }
                let csvFilename = null;
                let uploadedUtc = null;
                if (latestRes.ok) {
                    const latestText = await latestRes.text();
                    try {
                        const latest = JSON.parse(latestText.trim());
                        csvFilename = latest.filename || latest.csv_filename || latest.file || latest.csv;
                        uploadedUtc = latest.updated_utc || latest.updated || latest.timestamp_utc || null;
                        // Prefer explicit strategy/source from latest.json when present
                        if (latest.source || latest.strategy) {
                            updateCSVFilename(csvFilename, uploadedUtc, latest.source || latest.strategy);
                        }
                    } catch (e) {
                        console.warn('⚠️ Could not parse latest.json, text=', latestText);
                    }
                }
                
                // Fallback: pre_execution.json if latest.json missing
                if (!csvFilename) {
                    try {
                        const preResponse = await fetch(`${DATA_PREFIX}pre_execution.json?cb=${Date.now()}`, { cache: 'no-store' });
                        if (preResponse.ok) {
                            const preText = await preResponse.text();
                            const preData = JSON.parse(preText.trim());
                            csvFilename = preData.csv_filename || preData.filename || null;
                            uploadedUtc = preData.timestamp_utc || preData.executed_at_utc || preData.pv_pre_time || uploadedUtc;
                        }
                    } catch (e) {
                        console.log('❌ Could not load from pre_execution.json fallback:', e);
                    }
                }
                
                if (!csvFilename) {
                    throw new Error('No CSV filename found in latest.json or pre_execution.json');
                }
                
                // Check if CSV has changed
                if (csvFilename === currentCSVFilename) {
                    console.log('CSV unchanged, skipping reload');
                    return false; // No change
                }
                
                console.log(`New CSV detected from latest.json: ${csvFilename} (was: ${currentCSVFilename})`);
                currentCSVFilename = csvFilename;
                currentCSVUploadedUtc = uploadedUtc;
                updateCSVFilename(csvFilename, uploadedUtc);
                
                // Load positions from the CSV file
                const portfolioResponse = await fetch(`${DATA_PREFIX}${csvFilename}`);
                const portfolioCsv = await portfolioResponse.text();
                const portfolioLines = portfolioCsv.split('\n');
                const portfolioHeaders = portfolioLines[0].split(',');
                
                const positions = [];
                for (let i = 1; i < portfolioLines.length; i++) {
                    if (portfolioLines[i].trim()) {
                        const values = portfolioLines[i].split(',');
                        const position = {};
                        portfolioHeaders.forEach((header, index) => {
                            position[header.trim()] = values[index] ? values[index].trim() : '';
                        });
                        positions.push(position);
                    }
                }
                
                console.log(`Loaded ${positions.length} positions from ${csvFilename}`);
                
                // Set baseline prices (current market prices at CSV execution)
                const baselinePrices = await fetchBaselinePrices(positions);
                
                // Update current snapshot
                currentSnapshot.positions = positions;
                currentSnapshot.baselinePrices = baselinePrices;
                console.log('🔍 DEBUG: Loaded positions count:', positions.length);
                console.log('🔍 DEBUG: First 3 positions:', positions.slice(0, 3));
                // Clear any previous-day carryover to avoid large jumps on refresh
                lastGoodDailyPnL = null;
                currentSnapshot.dailyPnL = undefined;
                console.log('Daily CSV loaded, baseline set; cleared lastGoodDailyPnL and will compute fresh');
                return true; // CSV changed
                
            } catch (error) {
                console.error('Error loading daily CSV:', error);
                return false;
            }
        }

        // Load baseline prices from daily_baseline.json (with diagnostics)
        async function fetchBaselinePrices(positions) {
            try {
                const response = await fetch(`${DATA_PREFIX}daily_baseline.json?cb=${Date.now()}`, { cache: 'no-store' });
                if (!response.ok) return {};
                const baseline = await response.json();
                const prices = baseline.prices || {};
                if (DIAG) {
                    try {
                        const probe = ['BTCUSDT','ETHUSDT','BNBUSDT'];
                        const sample = probe.map(sym => ({ sym, entry: prices[sym] ?? null }));
                        console.log('[DIAG] baseline@', baseline.timestamp_utc, 'pv_pre=', baseline.pv_pre, sample);
                    } catch(_){}
                }
                return prices;
            } catch (error) {
                console.error('Error loading baseline prices:', error);
                return {};
            }
        }
        
        // Load PV_pre from pre_execution.json for accurate percentage calculations
        async function loadPVPre() {
            try {
                console.log('🔍 Loading PV_pre from pre_execution.json...');
                const response = await fetch(`${DATA_PREFIX}pre_execution.json?cb=${Date.now()}`, { cache: 'no-store' });
                if (response.ok) {
                    const data = await response.json();
                    const pvPre = parseFloat(data.pv_pre);
                    if (pvPre && pvPre > 0) {
                        currentPVPre = pvPre;
                        console.log(`📊 Loaded PV_pre: $${pvPre.toFixed(2)}`);
                        return pvPre;
                    } else {
                        console.log('⚠️ Invalid PV_pre in pre_execution.json, using initial capital');
                        return initialCapital;
                    }
                } else {
                    console.log('⚠️ No pre_execution.json available, using initial capital');
                    return initialCapital;
                }
            } catch (error) {
                console.error('Error loading PV_pre:', error);
                return initialCapital; // Fallback to initial capital
            }
        }

        // Load synchronized calculation snapshot for consistency
        async function fetchSynchronizedSnapshot() {
            try {
                console.log('🔍 Loading synchronized calculation snapshot...');
                const response = await fetch(`${DATA_PREFIX}calculation_snapshot.json`);
                if (response.ok) {
                    const snapshot = await response.json();
                    console.log('📊 Using synchronized snapshot for consistency');
                    return snapshot;
                }
            } catch (error) {
                console.log('⚠️ Synchronized snapshot not available, using individual sources');
            }
            return null;
        }

        // Load current mark prices from S3 latest_prices.json
        async function fetchCurrentPrices(positions) {
            try {
                console.log('🔍 Loading current prices from S3 latest_prices.json...');
                const cacheBuster = new Date().getTime();
                const response = await fetch(`${DATA_PREFIX}latest_prices.json?cb=${cacheBuster}`, {
                    cache: 'no-store'
                });
                if (!response.ok) return {};
                const data = await response.json();
                console.log('🧾 latest_prices.json payload keys =', Object.keys(data));
                const prices = data.prices || data || {};
                const currentPrices = {};
                const symbols = positions.map(p => resolveSymbolFromPosition(p)).filter(Boolean);
                console.log('🧩 Resolving currentPrices for symbols =', symbols);
                symbols.forEach(symbol => {
                    const price = prices[symbol];
                    currentPrices[symbol] = (price !== undefined && price !== null) ? parseFloat(price) : null;
                });
                console.log(`📊 Loaded ${Object.keys(currentPrices).length}/${symbols.length} prices from S3`);
                return currentPrices;
            } catch (error) {
                console.error('Error loading current prices from S3:', error);
                return {};
            }
        }

        // Create new snapshot using S3 data as single source of truth
        async function createSnapshot() {
            console.log('🔄 Creating new snapshot...', new Date().toISOString());
            console.log('📊 Using S3 logs as single source of truth for all calculations');
            
            // Load latest S3 data first
            try {
                // Add cache-busting parameter to force fresh data
                const cacheBuster = new Date().getTime();
                const response = await fetch(`${DATA_PREFIX}portfolio_value_log.jsonl?cb=${cacheBuster}`, {
                    cache: 'no-store'
                });
                if (response.ok) {
                    const text = await response.text();
                    const lines = text.trim().split('\n').filter(line => line.trim());
                    if (lines.length > 0) {
                        const latestEntry = JSON.parse(lines[lines.length - 1]);
                        
                        console.log('📊 Latest S3 entry:', latestEntry);
                        
                        // Prefer S3 daily fields when present (do not override PV)
                        currentSnapshot.timestamp = new Date(latestEntry.timestamp);
                        if (typeof latestEntry.daily_pnl === 'number') {
                            currentSnapshot.dailyPnL = latestEntry.daily_pnl;
                            currentSnapshot.s3DailyPnL = latestEntry.daily_pnl;
                        }
                        if (typeof latestEntry.total_pnl === 'number') {
                            currentSnapshot.s3TotalPnL = latestEntry.total_pnl;
                        }
                        
                        // Use audit data for Long/Short breakdown
                        if (latestEntry.audit) {
                            currentSnapshot.longPnL = latestEntry.audit.long_pnl;
                            currentSnapshot.shortPnL = latestEntry.audit.short_pnl;
                            console.log('📊 S3 Long P&L:', latestEntry.audit.long_pnl);
                            console.log('📊 S3 Short P&L:', latestEntry.audit.short_pnl);
                            console.log('📊 S3 Validation:', latestEntry.audit.validation_long_plus_short);
                        }
                        
                        // Ensure mark prices are available for the table/UI
                        if (currentSnapshot.positions && currentSnapshot.positions.length > 0) {
                            try {
                                currentSnapshot.currentPrices = await fetchCurrentPrices(currentSnapshot.positions);
                            } catch (e) {
                                console.log('⚠️ Failed to load current prices for table rendering:', e);
                            }
                        }

                        // Only render early if S3 daily_pnl exists; otherwise wait for local calc
                        if (typeof currentSnapshot.dailyPnL === 'number' && isFinite(currentSnapshot.dailyPnL)) {
                            updateUI();
                            return;
                        }
                    }
                }
            } catch (error) {
                console.log('⚠️ Could not load S3 data, falling back to calculation');
            }
            
            // If we have S3 data including daily P&L, we can skip local calc; else compute
            if (currentSnapshot.longPnL !== undefined && currentSnapshot.shortPnL !== undefined && typeof currentSnapshot.dailyPnL === 'number') {
                console.log('📊 S3 data loaded successfully, skipping calculations');
                updateUI();
                return;
            }
            
            console.log('🔍 DEBUG: currentSnapshot.positions.length =', currentSnapshot.positions.length);
            console.log('🔍 DEBUG: currentSnapshot.baselinePrices keys =', Object.keys(currentSnapshot.baselinePrices || {}));
            console.log('🔍 DEBUG: currentSnapshot.currentPrices keys =', Object.keys(currentSnapshot.currentPrices || {}));
            
            if (currentSnapshot.positions.length === 0) {
                console.log('❌ No positions loaded yet');
                return;
            }
            
            // Load current prices from S3
            const currentPrices = await fetchCurrentPrices(currentSnapshot.positions);
            if (DIAG) {
                try {
                    const probe = ['BTCUSDT','ETHUSDT','BNBUSDT'];
                    const sample = probe.map(sym => ({ sym, entry: currentSnapshot.baselinePrices[sym] ?? null, mark: currentPrices[sym] ?? null }));
                    console.log('[DIAG] marks', sample);
                } catch(_){}
            }
            console.log('🔍 DEBUG: Fetched currentPrices keys =', Object.keys(currentPrices || {}));
            
            // Calculate Daily P&L (vs baseline) fresh each tick to avoid compounding
            let dailyPnL = 0;
            let calculatedPositions = 0;
            console.log('🔍 Calculating Daily P&L...');
            
            currentSnapshot.positions.forEach((position, index) => {
                const symbol = resolveSymbolFromPosition(position);
                const baselinePrice = currentSnapshot.baselinePrices[symbol];
                const currentPrice = currentPrices[symbol];
                const notional = parseFloat(position.target_notional || 0);
                const side = parseFloat(position.target_contracts) > 0 ? 1 : -1;
                
                if (!symbol) {
                    console.log(`⚠️ Position ${index} has no resolvable symbol`, position);
                    return;
                }
                console.log(`🔍 DEBUG Position ${index}: ${symbol}`, {
                    baselinePrice,
                    currentPrice,
                    notional,
                    side,
                    hasBaseline: !!baselinePrice,
                    hasCurrent: !!currentPrice,
                    target_contracts: position.target_contracts,
                    target_notional: position.target_notional
                });
                
                if (baselinePrice && currentPrice) {
                    const contracts = parseFloat(position.target_contracts);
                    const notional = parseFloat(position.target_notional || 0);
                    // FIXED: Use same calculation as table: percentage change * notional
                    const pnl = side * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    console.log(`🔍 CALCULATION FIX: ${symbol} = ${side} * (${currentPrice} - ${baselinePrice}) / ${baselinePrice} * ${Math.abs(notional)} = ${pnl.toFixed(2)}`);
                    dailyPnL += pnl;
                    calculatedPositions++;
                    
                    console.log(`🔍 ${symbol}: baseline=${baselinePrice}, current=${currentPrice}, side=${side}, notional=${Math.abs(notional)}, contracts=${contracts}, pnl=${pnl.toFixed(2)}`);
                    
                    // Log all positions, not just first 3
                    if (calculatedPositions <= 5) {
                        const priceDiff = currentPrice - baselinePrice;
                        const priceChangePercent = priceDiff / baselinePrice;
                        const calculatedPnl = side * priceChangePercent * Math.abs(notional);
                        
                        console.log(`🔍 FULL DEBUG ${symbol}:`, {
                            baselinePrice,
                            currentPrice,
                            priceDiff,
                            priceChangePercent: (priceChangePercent * 100).toFixed(4) + '%',
                            side,
                            notional: Math.abs(notional),
                            calculatedPnl: calculatedPnl.toFixed(2),
                            actualPnl: pnl.toFixed(2),
                            match: Math.abs(calculatedPnl - pnl) < 0.01
                        });
                    }
                } else {
                    console.log(`⚠️ Missing data for ${symbol}: baseline=${!!baselinePrice}, current=${!!currentPrice}`);
                }
            });
            
            if (typeof dailyPnL === 'number') {
                console.log(`📊 Calculated ${calculatedPositions} positions, total P&L: ${dailyPnL.toFixed(2)}`);
            } else {
                console.log(`📊 Calculated ${calculatedPositions} positions; P&L pending until all prices arrive`);
            }
            console.log('🔍 DEBUG: Final dailyPnL =', dailyPnL);
            console.log('🔍 DEBUG: calculatedPositions =', calculatedPositions);
            
            // Update snapshot
            currentSnapshot.timestamp = new Date();
            currentSnapshot.currentPrices = currentPrices;
            currentSnapshot.dailyPnL = dailyPnL;
            if (typeof dailyPnL === 'number' && isFinite(dailyPnL)) {
                lastGoodDailyPnL = dailyPnL;
            }
            if (DIAG) {
                try {
                    const pvPre = (typeof currentPVPre === 'number') ? currentPVPre : null;
                    if (pvPre !== null && typeof dailyPnL === 'number') {
                        console.log('[DIAG] pv_check', { pvPre, dailyPnL, impliedPV: pvPre + dailyPnL, s3PV: currentSnapshot.portfolioValue });
                    }
                } catch(_){ }
            }
            
            console.log('🔍 DEBUG: Updated currentSnapshot.dailyPnL =', currentSnapshot.dailyPnL);
            
            // Always compute live PV = pv_pre + dailyPnL (Admin logic)
            if (typeof dailyPnL === 'number' && isFinite(dailyPnL)) {
                const base = (typeof currentPVPre === 'number' && isFinite(currentPVPre)) ? currentPVPre : initialCapital;
                currentSnapshot.portfolioValue = base + dailyPnL;
                console.log(`📊 Using calculated Portfolio Value: base=${base.toFixed(2)} + dailyPnL=${dailyPnL.toFixed(2)} → ${currentSnapshot.portfolioValue.toFixed(2)}`);
            }
            
            // Update UI with this snapshot
            updateUI();
            
            // Log PV for chart
            logPortfolioValue();
        }

        // --- BTC CSV fetch and strategy daily returns alignment ---
        async function fetchBtcDailyReturnsFromS3(){
            try {
                const r = await fetch('/signal-dashboard/benchmarks/btc_daily_returns.csv?cb=' + Date.now(), { cache:'no-store' });
                if (!r.ok) return [];
                const text = await r.text();
                const lines = text.trim().split('\n');
                const hdr = lines.shift().split(',').map(h=>h.trim().toLowerCase());
                const di = hdr.indexOf('date');
                const pi = hdr.indexOf('performance');
                return lines.filter(Boolean).map(line=>{
                    const parts = line.split(',');
                    return { Date: parts[di], Performance: parseFloat(parts[pi]) };
                }).filter(x=>x.Date && Number.isFinite(x.Performance));
            } catch(e){ console.error('btc fetch fail', e); return []; }
        }

        function computeDailyReturnsFromPVJsonlText(jsonlText){
            // Compute close-to-close daily returns from PV JSONL
            const lines = (jsonlText||'').trim().split('\n').filter(Boolean);
            const data = lines.map(l=>{ try { return JSON.parse(l); } catch(e){ return null; } }).filter(Boolean);
            const byDay = new Map();
            data.forEach(pt=>{
                const ts = pt.timestamp || pt.time || pt.t; if (!ts) return;
                const d = new Date(ts); const day = d.toISOString().slice(0,10);
                const arr = byDay.get(day) || []; arr.push(pt); byDay.set(day, arr);
            });
            // Sort days and take EOD close per day
            const days = Array.from(byDay.keys()).sort();
            const closes = days.map(day => {
                const arr = byDay.get(day).slice().sort((a,b)=> new Date(a.timestamp)-new Date(b.timestamp));
                const last = arr[arr.length-1];
                return (last.portfolio_value || last.portfolioValue);
            });
            const out = [];
            for (let i=0;i<days.length;i++){
                const day = days[i];
                const close = closes[i];
                if (typeof close !== 'number') continue;
                if (i === 0 || typeof closes[i-1] !== 'number' || closes[i-1] <= 0){
                    out.push({ Date: day, Performance: 0 });
                } else {
                    const r = (close / closes[i-1] - 1) * 100;
                    out.push({ Date: day, Performance: Number(r.toFixed(2)) });
                }
            }
            return out;
        }

        // --- Metrics math helpers ---
        function pearson(x, y){
            const n = Math.min(x.length, y.length);
            if (n === 0) return NaN;
            let sx=0, sy=0, sxx=0, syy=0, sxy=0;
            for (let i=0;i<n;i++){ const a=x[i], b=y[i]; sx+=a; sy+=b; sxx+=a*a; syy+=b*b; sxy+=a*b; }
            const mx = sx/n, my = sy/n;
            const cov = sxy/n - mx*my;
            const vx = sxx/n - mx*mx;
            const vy = syy/n - my*my;
            const denom = Math.sqrt(vx*vy);
            return denom>0 ? (cov/denom) : NaN;
        }
        function hitRate(returnsPct){
            if (!returnsPct || returnsPct.length===0) return 0;
            const wins = returnsPct.filter(v=> v>0).length;
            return wins / returnsPct.length * 100;
        }
        function maxDrawdown(returnsPct){
            const r = (returnsPct||[]).map(v=> v/100);
            let peak = 1, trough = 1, mdd = 0, eq = 1;
            for (const rr of r){
                eq *= (1+rr);
                if (eq>peak){ peak = eq; trough = eq; }
                if (eq<trough){ trough = eq; }
                const dd = (trough/peak - 1);
                if (dd < mdd) mdd = dd;
            }
            return mdd*100;
        }

        async function updateRiskCards(scope){
            try {
                // Strategy daily from PV log (strategy-aware via DATA_PREFIX)
                const res = await fetch(`${DATA_PREFIX}portfolio_value_log.jsonl?cb=${Date.now()}`, { cache: 'no-store' });
                if (!res.ok){
                    ['risk-corr','risk-hit','risk-mdd'].forEach(id=>{ const el = document.getElementById(id); if (el) el.textContent = 'N/A'; });
                    return;
                }
                const pvText = await res.text();
                const stratDaily = computeDailyReturnsFromPVJsonlText(pvText).map(x=>({ Date:x.Date, Performance:x.Performance }));

                // BTC benchmark (single path)
                const btcDaily = await fetchBtcDailyReturnsFromS3();
                const byDate = new Map(btcDaily.map(r=> [r.Date, r.Performance]));
                // Correlation uses intersection with BTC
                let joined = stratDaily.filter(r=> byDate.has(r.Date)).map(r=> ({ d:r.Date, s:r.Performance, b:byDate.get(r.Date) }));
                if (scope === '90D' && joined.length>90) joined = joined.slice(-90);
                const s_corr = joined.map(x=> x.s);
                const b = joined.map(x=> x.b);
                const corr = pearson(s_corr, b);

                // Hit Rate respects selected scope; MDD is ALWAYS since inception (SI)
                let s_hr = stratDaily.map(r=> r.Performance);
                if (scope === '90D' && s_hr.length>90) s_hr = s_hr.slice(-90);
                const hr = hitRate(s_hr);
                const s_full = stratDaily.map(r=> r.Performance);
                const mdd = maxDrawdown(s_full);
                const fmt = (v, dp=2)=> (Number.isFinite(v)? v.toFixed(dp) : 'N/A');
                const corrEl = document.getElementById('risk-corr'); if (corrEl) corrEl.textContent = (Number.isFinite(corr)? fmt(corr,2) : 'N/A');
                const hitEl = document.getElementById('risk-hit'); if (hitEl) hitEl.textContent = `${fmt(hr,1)}%`;
                const mddEl = document.getElementById('risk-mdd'); if (mddEl) mddEl.textContent = `${fmt(mdd,2)}%`;
                const scopeEl = document.getElementById('risk-mdd-scope'); if (scopeEl) scopeEl.textContent = `(SI)`;
            } catch (e){
                console.error('risk cards error', e);
            }
        }

        // Update UI with current snapshot
        function updateUI() {
            const snapshot = currentSnapshot;
            console.log('🔍 DEBUG: updateUI called');
            console.log('🔍 DEBUG: currentSnapshot =', currentSnapshot);
            console.log('🔍 DEBUG: currentSnapshot.dailyPnL =', currentSnapshot?.dailyPnL);
            console.log('🔍 DEBUG: currentSnapshot.portfolioValue =', currentSnapshot?.portfolioValue);
            
            console.log('🔄 Updating UI with snapshot:', {
                timestamp: snapshot.timestamp?.toISOString(),
                portfolioValue: snapshot.portfolioValue,
                dailyPnL: snapshot.dailyPnL,
                currentPricesCount: Object.keys(snapshot.currentPrices || {}).length
            });
            console.log('🔄 UI Update timestamp:', new Date().toISOString());
            
            // Portfolio Value
            document.getElementById('portfolio-value').textContent = formatCurrency(snapshot.portfolioValue);
            const timeStr = snapshot.timestamp ? snapshot.timestamp.toISOString().substr(11, 8) + ' UTC' : 'Loading...';
            document.getElementById('portfolio-time').textContent = timeStr;
            
            // Add a visual indicator that updates are happening
            const timeElement = document.getElementById('portfolio-time');
            timeElement.style.backgroundColor = '#28a745';
            timeElement.style.color = 'white';
            timeElement.style.padding = '2px 6px';
            timeElement.style.borderRadius = '3px';
            setTimeout(() => {
                timeElement.style.backgroundColor = '';
                timeElement.style.color = '';
                timeElement.style.padding = '';
                timeElement.style.borderRadius = '';
            }, 1000);
            
            // Use PV_pre for percentage calculations if available, otherwise use initialCapital
            const referenceCapital = currentPVPre || initialCapital;

            // Use S3 daily_pnl when present; otherwise use one-shot local calc (no carryover)
            let cardDaily;
            if (snapshot.s3DailyPnL !== null && snapshot.s3DailyPnL !== undefined && isFinite(snapshot.s3DailyPnL)) {
                cardDaily = snapshot.s3DailyPnL;
            } else if (typeof snapshot.dailyPnL === 'number' && isFinite(snapshot.dailyPnL)) {
                cardDaily = snapshot.dailyPnL;
            } else {
                cardDaily = undefined;
            }
            const cardTotal = (snapshot.s3TotalPnL !== null && snapshot.s3TotalPnL !== undefined)
                ? snapshot.s3TotalPnL
                : (snapshot.portfolioValue - initialCapital);

            console.log('🔍 DEBUG: Setting Daily P&L to:', cardDaily);
            console.log('🔍 DEBUG: Calculated Daily P&L:', snapshot.dailyPnL);
            console.log('🔍 DEBUG: S3 Daily P&L:', snapshot.s3DailyPnL);
            console.log('🔍 DEBUG: Using reference capital for %:', referenceCapital);

            if (cardDaily === undefined) {
                const dEl = document.getElementById('daily-pnl'); if (dEl) dEl.textContent = '…';
                const pEl = document.getElementById('daily-pnl-percent'); if (pEl) pEl.textContent = '';
            } else {
                document.getElementById('daily-pnl').textContent = formatCurrency(cardDaily);
                document.getElementById('daily-pnl').className = `value ${cardDaily >= 0 ? 'positive' : 'negative'}`;
                document.getElementById('daily-pnl-percent').textContent = `(${formatPercentage((cardDaily / referenceCapital) * 100)})`;
                document.getElementById('daily-pnl-percent').className = `percentage ${cardDaily >= 0 ? 'positive' : 'negative'}`;
            }
            // Total P&L Since Inception (prefer S3 last record)
            document.getElementById('total-pnl').textContent = formatCurrency(cardTotal);
            document.getElementById('total-pnl').className = `value ${cardTotal >= 0 ? 'positive' : 'negative'}`;
            // Percent should always be versus initial capital (since inception)
            document.getElementById('total-pnl-percent').textContent = `(${formatPercentage((cardTotal / initialCapital) * 100)})`;
            document.getElementById('total-pnl-percent').className = `percentage ${cardTotal >= 0 ? 'positive' : 'negative'}`;
            
            // Update risk cards if present (use last selected scope or default 90D)
            const hasRisk = document.getElementById('risk-cards-row');
            if (hasRisk) {
                const active = document.querySelector('.risk-toggle.active');
                const scope = active ? active.getAttribute('data-tf') : '90D';
                updateRiskCards(scope);
                document.querySelectorAll('.risk-toggle').forEach(btn=>{
                    btn.addEventListener('click',()=>{
                        document.querySelectorAll('.risk-toggle').forEach(b=> b.classList.remove('active'));
                        btn.classList.add('active');
                        const tf = btn.getAttribute('data-tf') || '90D';
                        updateRiskCards(tf);
                    });
                });
                // simplified formula tooltips via i icons
                const corrCard = document.querySelector('.icon-info[data-info="corr"]');
                const hitCard = document.querySelector('.icon-info[data-info="hit"]');
                const mddCard = document.querySelector('.icon-info[data-info="mdd"]');
                function explain(el, text){
                    if (!el) return;
                    el.addEventListener('click',()=>{
                        const tip = document.createElement('div');
                        tip.textContent = text;
                        tip.style.position='fixed'; tip.style.bottom='24px'; tip.style.right='24px'; tip.style.maxWidth='360px';
                        tip.style.background='rgba(17,24,39,0.95)'; tip.style.color='#fff'; tip.style.padding='12px 14px';
                        tip.style.borderRadius='10px'; tip.style.boxShadow='0 8px 30px rgba(0,0,0,.25)'; tip.style.zIndex='9999';
                        tip.style.fontSize='12.5px'; tip.style.lineHeight='1.4';
                        document.body.appendChild(tip);
                        setTimeout(()=> tip.remove(), 2800);
                    });
                }
                explain(corrCard, 'Correlation (daily EOD returns) with BTC over selected scope.');
                explain(hitCard, 'Hit Rate = fraction of days with positive return over selected scope.');
                explain(mddCard, 'Max Drawdown = worst peak→trough of equity built from daily close-to-close returns (90D/SI toggle applies).');
            }

            // Use S3 Long/Short P&L if available, otherwise calculate
            let longPnL, shortPnL, longCount, shortCount, longNotional, shortNotional;
            
            if (snapshot.longPnL !== undefined && snapshot.shortPnL !== undefined) {
                // Use S3 audit data (authoritative)
                longPnL = snapshot.longPnL;
                shortPnL = snapshot.shortPnL;
                console.log('📊 Using S3 Long/Short P&L values');
                
                // Calculate notionals and counts from positions
                const longShortMetrics = calculateLongShortMetrics(snapshot.positions);
                longNotional = longShortMetrics.longNotional;
                shortNotional = longShortMetrics.shortNotional;
                longCount = longShortMetrics.longCount;
                shortCount = longShortMetrics.shortCount;
            } else {
                // Fallback to calculation
                const longShortMetrics = calculateLongShortMetrics(snapshot.positions);
                longPnL = longShortMetrics.longPnL;
                shortPnL = longShortMetrics.shortPnL;
                longNotional = longShortMetrics.longNotional;
                shortNotional = longShortMetrics.shortNotional;
                longCount = longShortMetrics.longCount;
                shortCount = longShortMetrics.shortCount;
                console.log('📊 Using calculated Long/Short P&L values');
            }
            
            // Validation: Long + Short P&L should equal Daily P&L
            const longShortTotal = longPnL + shortPnL;
            console.log('🔍 VALIDATION: Long+Short P&L =', longShortTotal.toFixed(2), 'vs Daily P&L =', snapshot.dailyPnL.toFixed(2), 'Diff =', (longShortTotal - snapshot.dailyPnL).toFixed(2));
            console.log('🔍 VALIDATION: Card Daily =', (cardDaily ?? 0).toFixed(2), 'vs Rows Daily =', snapshot.dailyPnL.toFixed(2), 'Diff =', ((cardDaily ?? 0) - snapshot.dailyPnL).toFixed(2));
            
            // Long Positions
            document.getElementById('long-notional').textContent = formatCurrency(longNotional);
            document.getElementById('long-pnl-percent').textContent = `(${formatCurrency(longPnL)})`;
            document.getElementById('long-pnl-percent').className = `percentage ${longPnL >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('long-count').textContent = `${longCount} positions`;
            
            // Short Positions
            document.getElementById('short-notional').textContent = formatCurrency(shortNotional);
            document.getElementById('short-pnl-percent').textContent = `(${formatCurrency(shortPnL)})`;
            document.getElementById('short-pnl-percent').className = `percentage ${shortPnL >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('short-count').textContent = `${shortCount} positions`;
            
            // Update total positions count (count only non-zero contracts)
            const totalPositions = (longCount || 0) + (shortCount || 0);
            document.getElementById('total-positions-count').textContent = totalPositions.toString();
            
            // Update delta progress bar
            createDeltaProgressBar();
            
            // Update top performers
            updateTopPerformers();
            
            // Update table
            updatePositionsTable(referenceCapital);

            // Update Avg P&L per Trade (positions-based, S3-driven)
            try {
                const positionsCount = parseInt(document.getElementById('total-positions-count').textContent || '0', 10) || 0;
                const pnlForAvg = (typeof cardDaily === 'number') ? cardDaily : 0;
                const avgPerTrade = positionsCount > 0 ? (pnlForAvg / positionsCount) : null;
                const avgEl = document.getElementById('avg-pnl-per-trade');
                const avgMetaEl = document.getElementById('avg-pnl-trade-meta');
                if (avgEl) avgEl.textContent = (avgPerTrade !== null) ? formatCurrency(avgPerTrade) : 'N/A';
                if (avgMetaEl) avgMetaEl.textContent = `${positionsCount} position${positionsCount === 1 ? '' : 's'}`;
            } catch (e) {
                console.log('⚠️ Failed to update Avg P&L per Trade:', e);
            }
        }

        // Update positions table
        function updatePositionsTable(referenceCapital) {
            const snapshot = currentSnapshot;
            if (snapshot.positions.length === 0) return;
            
            const longPositions = snapshot.positions.filter(p => parseFloat(p.target_contracts) > 0);
            const shortPositions = snapshot.positions.filter(p => parseFloat(p.target_contracts) < 0);
            
            populatePositionTable('long-positions', longPositions, snapshot, referenceCapital);
            populatePositionTable('short-positions', shortPositions, snapshot, referenceCapital);
        }

        function populatePositionTable(tableId, positions, snapshot, referenceCapital) {
            console.log('🔍 populatePositionTable called with refCap fix, positions:', positions.length);
            const tbody = document.getElementById(tableId);
            tbody.innerHTML = '';

            // Use fixed reference capital of $1,000,000 for calculations
            const refCap = initialCapital;
            console.log('🔍 Using fixed refCap:', refCap);
            
            // Sort logic
            const tableSortState = window.tableSortState || (window.tableSortState = { long: {key:null,dir:1}, short: {key:null,dir:1} });
            const tableKind = (tableId === 'long-positions') ? 'long' : (tableId === 'short-positions') ? 'short' : null;
            if (tableKind && tableSortState[tableKind].key) {
                const { key, dir } = tableSortState[tableKind];
                positions = positions.slice().sort((a,b)=>{
                    const getDerived = (p) => {
                        const symbol = p.ticker || p.ric || p.internal_code || 'N/A';
                        const bin = symbol.replace('_','');
                        const baselinePrice = snapshot.baselinePrices[bin];
                        const currentPrice = snapshot.currentPrices[bin];
                        const notional = Math.abs(parseFloat(p.target_notional || 0));
                        const weight = notional / refCap * 100;
                        let pnl = 0, pnlPct = 0;
                        if (baselinePrice && currentPrice) {
                            const sideMult = parseFloat(p.target_contracts) > 0 ? 1 : -1;
                            pnl = sideMult * (currentPrice - baselinePrice) / baselinePrice * notional;
                            pnlPct = sideMult * (currentPrice - baselinePrice) / baselinePrice * 100;
                        }
                        return { weight, notional, pnl, pnlPct };
                    };
                    const ad = getDerived(a), bd = getDerived(b);
                    const va = ad[key];
                    const vb = bd[key];
                    return (va === vb ? 0 : (va > vb ? 1 : -1)) * dir;
                });
            }
            
            positions.forEach(position => {
                const symbol = position.ticker || position.ric || position.internal_code || 'N/A';
                const binanceSymbol = symbol.replace('_', '');
                // Removed entry-based metrics by request
                const entryPrice = snapshot.baselinePrices[binanceSymbol];
                const baselinePrice = snapshot.baselinePrices[binanceSymbol];
                const currentPrice = snapshot.currentPrices[binanceSymbol];
                const notional = parseFloat(position.target_notional || 0);
                const side = parseFloat(position.target_contracts) > 0 ? 'LONG' : 'SHORT';
                const weight = (Math.abs(notional) / refCap) * 100;
                
                // Daily P&L (vs baseline)
                let dailyPnl = 0;
                let dailyPnlPercent = 0;
                // Since-entry removed
                
                if (baselinePrice && currentPrice) {
                    const sideMultiplier = parseFloat(position.target_contracts) > 0 ? 1 : -1;
                    dailyPnl = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    dailyPnlPercent = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * 100;
                }

                // no-op
                
                const row = document.createElement('tr');
                row.className = 'position-row';
                
                // Add winning position highlight
                if (dailyPnl > 0) {
                    row.classList.add('winning');
                }
                
                // Add top performer highlight (top 3 by absolute P&L)
                const isTopPerformer = checkIfTopPerformer(symbol, dailyPnl, side);
                if (isTopPerformer) {
                    row.classList.add('top-performer');
                }
                
                row.innerHTML = `
                    <td class="symbol" data-symbol="${symbol}">${symbol}</td>
                    <td class="${side === 'LONG' ? 'side-long' : 'side-short'}">${side}</td>
                    <td>${weight.toFixed(2)}%</td>
                    <td>${formatCurrency(Math.abs(notional))}</td>
                    <td>${entryPrice ? formatCurrency(entryPrice) : '-'}</td>
                    <td>${currentPrice ? formatCurrency(currentPrice) : 'Loading...'}</td>
                    <td class="${dailyPnl >= 0 ? 'positive' : 'negative'}">${formatCurrency(dailyPnl)}</td>
                    <td class="${dailyPnlPercent >= 0 ? 'positive' : 'negative'}">${dailyPnlPercent.toFixed(2)}%</td>
                `;
                tbody.appendChild(row);
            });
        }

        // PV logging to S3 for persistence
        let pvLogs = [];
        
        async function logPortfolioValue() {
            const logEntry = {
                timestamp: currentSnapshot.timestamp.toISOString(),
                portfolioValue: currentSnapshot.portfolioValue,
                dailyPnL: currentSnapshot.dailyPnL
            };
            
            console.log('📊 Logging PV:', logEntry);
            
            // Store in browser memory for immediate chart update
            pvLogs.push(logEntry);
            
            // Keep only last 24 hours in memory
            const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
            pvLogs = pvLogs.filter(log => new Date(log.timestamp) > oneDayAgo);
            
            console.log(`📈 PV Logs: ${pvLogs.length} entries, latest: ${logEntry.portfolioValue}`);
            // Don't update chart here - let the S3 data stay visible
            // updateChart();
        }

        // Load EOD PV from CSV (history), optionally limited to last N days, and append today's live point
        async function loadEodPVData(limitDays) {
            try {
                const r = await fetch(`${DATA_PREFIX}eod_pv.csv?cb=${Date.now()}`, { cache: 'no-store' });
                if (!r.ok) { console.log('No eod_pv.csv available yet'); return []; }
                const txt = await r.text();
                const lines = txt.trim().split('\n').filter(Boolean);
                // Drop header if present
                if (lines.length && /pv/i.test(lines[0]) && /date/i.test(lines[0])) lines.shift();
                const rows = lines.map(line => {
                    const parts = line.split(',');
                    const d = (parts[0] || '').trim();
                    const pv = Number((parts[1] || '').trim());
                    if (!d || !Number.isFinite(pv)) return null;
                    // Use end-of-day timestamp for visual consistency
                    const ts = new Date(`${d}T23:59:59Z`).toISOString();
                    return { timestamp: ts, portfolio_value: pv };
                }).filter(Boolean).sort((a,b)=> new Date(a.timestamp) - new Date(b.timestamp));
                let out = rows;
                if (Number.isFinite(limitDays)) {
                    const cutoff = new Date(Date.now() - limitDays * 24 * 60 * 60 * 1000);
                    out = rows.filter(pt => new Date(pt.timestamp) >= cutoff);
                }
                // Append a live point for today if pv_pre and dailyPnL exist
                if (typeof currentPVPre === 'number' && Number.isFinite(currentPVPre)) {
                    const livePnL = (typeof currentSnapshot?.dailyPnL === 'number' && isFinite(currentSnapshot.dailyPnL)) ? currentSnapshot.dailyPnL : 0;
                    const pvNow = currentPVPre + livePnL;
                    out = out.concat([{ timestamp: new Date().toISOString(), portfolio_value: pvNow }]);
                }
                console.log(`📊 Loaded ${out.length} EOD PV points from eod_pv.csv`);
                return out;
            } catch (e) {
                console.error('eod_pv.csv load error', e);
                return [];
            }
        }

        // Load historical PV data
        async function loadHistoricalPVData(timeframe) {
            // For long windows, prefer canonical EOD PV CSV
            if (timeframe === '7D' || timeframe === '1M' || timeframe === 'SI') {
                const days = (timeframe === '7D') ? 7 : (timeframe === '1M' ? 30 : null);
                const eod = await loadEodPVData(days);
                return eod;
            }
            try {
                const cacheBuster = new Date().getTime();
                const response = await fetch(`${DATA_PREFIX}portfolio_value_log.jsonl?cb=${cacheBuster}`, {
                    cache: 'no-store'
                });
                if (!response.ok) {
                    console.log('No S3 PV data available yet');
                    return [];
                }
                
                const text = await response.text();
                console.log('📄 Raw S3 text length:', text.length);
                
                const lines = text.trim().split('\n').filter(line => line.trim());
                console.log('📄 S3 lines count:', lines.length);
                
                const data = lines.map(line => {
                    try {
                        return JSON.parse(line.trim());
                    } catch (e) {
                        console.error('❌ Error parsing line:', line);
                        return null;
                    }
                }).filter(item => item !== null);
                
                console.log(`📊 Loaded ${data.length} PV points from S3`);
                console.log('📊 First data point:', data[0]);
                console.log('📊 Last data point:', data[data.length - 1]);

                // Update cards from last S3 record (do NOT overwrite PV; PV = pv_pre + dailyPnL)
                try {
                    const last = data[data.length - 1] || {};
                    currentSnapshot.s3DailyPnL = (typeof last.daily_pnl === 'number') ? last.daily_pnl : null;
                    currentSnapshot.s3TotalPnL = (typeof last.total_pnl === 'number') ? last.total_pnl : null;
                } catch (e) {
                    console.warn('⚠️ Failed to update S3 daily/total fields', e);
                }
                
                // Filter by timeframe - be more aggressive about filtering
                const now = new Date();
                let cutoffDate;
                switch(timeframe) {
                    case '1D':
                        cutoffDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                        break;
                    case '7D':
                        cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        break;
                    case '1M':
                        cutoffDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        break;
                    case 'SI':
                        // Since inception: return the entire series unfiltered (sorted)
                        return data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                    default:
                        cutoffDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                }
                
                const filteredData = data.filter(log => {
                    const logDate = new Date(log.timestamp);
                    return logDate >= cutoffDate && logDate <= now;
                });
                
                console.log(`📊 Filtered to ${filteredData.length} points for ${timeframe} timeframe`);
                console.log(`📊 Cutoff date: ${cutoffDate.toISOString()}`);
                console.log(`📊 Now: ${now.toISOString()}`);
                console.log(`📊 Data range: ${filteredData[0]?.timestamp} to ${filteredData[filteredData.length-1]?.timestamp}`);
                
                // Return filtered data sorted by timestamp
                return filteredData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
            } catch (error) {
                console.error('Error loading historical PV data:', error);
                return [];
            }
        }
        
        // Load chart data for different timeframes
        async function loadChartData(timeframe) {
            // Update button states
            document.querySelectorAll('.time-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[onclick="loadChartData('${timeframe}')"]`).classList.add('active');
            
            // Load historical data
            currentTimeframe = timeframe;
            let historicalData = await loadHistoricalPVData(timeframe);
            
            // SI: show raw S3 PV full history (no rebasing)
            if (timeframe === 'SI') {
                console.log(`[SI] Full-series points: ${historicalData.length}`);
                if (historicalData.length > 0) {
                    const firstTs = historicalData[0].timestamp;
                    const lastTs = historicalData[historicalData.length - 1].timestamp;
                    console.log(`[SI] First timestamp: ${firstTs}`);
                    console.log(`[SI] Last timestamp:  ${lastTs}`);
                }
            }
            
            // 1D needs a second point to draw a line across the day.
            // If we only have the EOD/open point, or the last point is stale,
            // synthesize a "now" anchor using last PV + calculated daily P&L.
            if (timeframe === '1D' && historicalData.length >= 1) {
                const last = historicalData[historicalData.length - 1];
                const lastPv = (last.portfolio_value ?? last.portfolioValue) || initialCapital;
                const lastTsMs = new Date(last.timestamp).getTime();
                const nowMs = Date.now();
                const minutesSinceLast = (nowMs - lastTsMs) / 60000;

                // If there is only one point OR the last point is older than 15 minutes,
                // append a now-anchor. Prefer calculated dailyPnL when available.
                if (historicalData.length === 1 || minutesSinceLast > 15) {
                    const dailyPnLNow = (typeof currentSnapshot?.dailyPnL === 'number' && isFinite(currentSnapshot.dailyPnL))
                        ? currentSnapshot.dailyPnL
                        : 0;
                    const pvNow = lastPv + dailyPnLNow;
                    const nowISO = new Date(nowMs).toISOString();
                    historicalData = [
                        ...historicalData,
                        { timestamp: nowISO, portfolio_value: pvNow }
                    ];
                    console.log(`[1D] Added now anchor → pvNow=${pvNow.toFixed(2)} (lastPv=${lastPv.toFixed(2)} + dailyPnL=${dailyPnLNow.toFixed(2)}), minutesSinceLast=${minutesSinceLast.toFixed(0)}`);
                }
            }
            // If the 1D filter produced zero points (gap between yesterday 00:00Z and now before 00:00Z today),
            // synthesize a flat start and a now point so the line is visible.
            if (timeframe === '1D' && historicalData.length === 0) {
                const basePv = (typeof currentSnapshot?.portfolioValue === 'number')
                    ? currentSnapshot.portfolioValue
                    : initialCapital;
                const dailyPnLNow = (typeof currentSnapshot?.dailyPnL === 'number' && isFinite(currentSnapshot.dailyPnL))
                    ? currentSnapshot.dailyPnL
                    : 0;
                const now = new Date();
                const start = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                const pvNow = basePv + dailyPnLNow;
                historicalData = [
                    { timestamp: start.toISOString(), portfolio_value: basePv },
                    { timestamp: now.toISOString(), portfolio_value: pvNow }
                ];
                console.log(`[1D] Synthesized window because no S3 points in last 24h → start=${basePv.toFixed(2)}, now=${pvNow.toFixed(2)}`);
            }
            
            // Timeframe-aware resampling for uniform visual cadence (display-only)
            const displayData = resampleForTimeframe(historicalData, timeframe);
            console.log(`🔧 Resampled ${historicalData.length} → ${displayData.length} for ${timeframe}`);

            // Use resampled data for chart; metrics/downloads still use raw S3 data
            updateChart(displayData, timeframe);
        }

        // Resample PV series to a uniform cadence per timeframe (display-only)
        function resampleForTimeframe(series, timeframe) {
            try {
                if (!Array.isArray(series) || series.length === 0) return [];
                const sorted = series.slice().sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                const getPV = (d) => (typeof d.portfolio_value === 'number' ? d.portfolio_value : d.portfolioValue);

                // SI → group by UTC day, keep last point (EOD)
                if (timeframe === 'SI') {
                    const byDay = new Map();
                    for (const pt of sorted) {
                        const day = new Date(pt.timestamp).toISOString().slice(0, 10);
                        const cur = byDay.get(day);
                        if (!cur || new Date(cur.timestamp) <= new Date(pt.timestamp)) {
                            byDay.set(day, { timestamp: pt.timestamp, portfolio_value: getPV(pt) });
                        }
                    }
                    return Array.from(byDay.values()).sort((a,b)=> new Date(a.timestamp) - new Date(b.timestamp));
                }

                // Bucket sizes per timeframe
                let bucketMinutes = 5; // default for 1D
                if (timeframe === '7D') bucketMinutes = 30;
                if (timeframe === '1M') bucketMinutes = 120;

                const bucketMs = bucketMinutes * 60 * 1000;
                const buckets = new Map(); // key -> {timestamp, pv}

                for (const pt of sorted) {
                    const t = new Date(pt.timestamp).getTime();
                    const key = Math.floor(t / bucketMs) * bucketMs; // bucket start
                    // Keep the last point within the bucket (closest to bucket end)
                    const existing = buckets.get(key);
                    if (!existing || existing.t <= t) {
                        buckets.set(key, { t, point: { timestamp: pt.timestamp, portfolio_value: getPV(pt) } });
                    }
                }

                const result = Array.from(buckets.values())
                    .sort((a, b) => a.t - b.t)
                    .map(x => x.point);

                // Ensure first and last points are present for visual continuity
                const first = { timestamp: sorted[0].timestamp, portfolio_value: getPV(sorted[0]) };
                const last = { timestamp: sorted[sorted.length - 1].timestamp, portfolio_value: getPV(sorted[sorted.length - 1]) };
                if (result.length === 0 || new Date(result[0].timestamp).getTime() > new Date(first.timestamp).getTime()) {
                    result.unshift(first);
                }
                if (new Date(result[result.length - 1].timestamp).getTime() < new Date(last.timestamp).getTime()) {
                    result.push(last);
                }
                return result;
            } catch (e) {
                console.warn('Resample failed, returning original series', e);
                return series;
            }
        }
        
        // Update chart with data
        function updateChart(data = pvLogs, timeframe = '1D') {
            // Always show chart, even with no data
            if (data.length === 0) {
                console.log('📊 No data available, showing empty chart');
                data = [{
                    timestamp: new Date().toISOString(),
                    portfolioValue: initialCapital,
                    daily_pnl: 0,
                    total_pnl: 0
                }];
            }
            
            console.log(`📊 Updating chart with ${data.length} data points`);
            if (timeframe === 'SI' && data.length > 0) {
                const xs = data.map(d => new Date(d.timestamp).getTime());
                const ys = data.map(d => (d.portfolio_value ?? d.portfolioValue));
                const minX = new Date(Math.min.apply(null, xs)).toISOString();
                const maxX = new Date(Math.max.apply(null, xs)).toISOString();
                const minY = Math.min.apply(null, ys);
                const maxY = Math.max.apply(null, ys);
                console.log(`[SI] X range: ${minX} → ${maxX}`);
                console.log(`[SI] Y range: ${minY.toFixed(2)} → ${maxY.toFixed(2)}`);
            }
            
            const ctx = document.getElementById('portfolio-chart').getContext('2d');
            
            // Properly destroy existing chart
            if (portfolioChart) {
                portfolioChart.destroy();
                portfolioChart = null;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            // Compute SI bounds so we can show the full series
            let siMin = null, siMax = null, siYMin = null, siYMax = null;
            if (timeframe === 'SI' && data && data.length > 0) {
                const xs = data.map(d => new Date(d.timestamp).getTime());
                const ys = data.map(d => (d.portfolio_value ?? d.portfolioValue));
                siMin = new Date(Math.min.apply(null, xs));
                siMax = new Date(Math.max.apply(null, xs));
                siYMin = Math.min.apply(null, ys);
                siYMax = Math.max.apply(null, ys);
                console.log(`[SI] applying bounds: ${siMin.toISOString()} → ${siMax.toISOString()} | Y ${siYMin} → ${siYMax}`);
            }

            try {
                // Create beautiful gradients
                const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
                gradient.addColorStop(0, 'rgba(102, 126, 234, 0.4)');
                gradient.addColorStop(0.5, 'rgba(102, 126, 234, 0.15)');
                gradient.addColorStop(1, 'rgba(102, 126, 234, 0.05)');

                // Create border gradient
                const borderGradient = ctx.createLinearGradient(0, 0, ctx.canvas.width, 0);
                borderGradient.addColorStop(0, 'rgba(102, 126, 234, 1)');
                borderGradient.addColorStop(0.5, 'rgba(118, 75, 162, 0.8)');
                borderGradient.addColorStop(1, 'rgba(102, 126, 234, 1)');
            
            portfolioChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Portfolio Value',
                            data: data.map(log => ({
                                x: new Date(log.timestamp),
                                y: log.portfolio_value || log.portfolioValue
                            })),
                            borderColor: borderGradient,
                            backgroundColor: gradient,
                            borderWidth: 3,
                            tension: 0.4,
                            fill: true,
                            pointRadius: 0,
                            pointHoverRadius: 8,
                            pointHoverBackgroundColor: 'rgba(255, 255, 255, 0.9)',
                            pointHoverBorderColor: 'rgba(102, 126, 234, 1)',
                            pointHoverBorderWidth: 3,
                            pointBackgroundColor: 'rgba(102, 126, 234, 0.8)',
                            pointBorderColor: 'rgba(255, 255, 255, 1)',
                            pointBorderWidth: 2,
                            shadowOffsetX: 0,
                            shadowOffsetY: 4,
                            shadowBlur: 12,
                            shadowColor: 'rgba(102, 126, 234, 0.3)'
                    }]
                },
                options: {
                    responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    usePointStyle: true,
                                    pointStyle: 'circle',
                                    padding: 20,
                                    font: {
                                        family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                        size: 13,
                                        weight: '600'
                                    },
                                    color: '#374151',
                                    boxWidth: 12,
                                    boxHeight: 12
                                }
                            },
                            tooltip: {
                                enabled: true,
                                backgroundColor: 'rgba(255, 255, 255, 0.98)',
                                titleColor: '#1f2937',
                                bodyColor: '#4b5563',
                                borderColor: 'rgba(102, 126, 234, 0.2)',
                                borderWidth: 1,
                                cornerRadius: 12,
                                displayColors: false,
                                titleFont: {
                                    family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                    size: 13,
                                    weight: '600'
                                },
                                bodyFont: {
                                    family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                    size: 12,
                                    weight: '500'
                                },
                                padding: 12,
                                caretSize: 6,
                                caretPadding: 8,
                                callbacks: {
                                    title: function(context) {
                                        const date = new Date(context[0].label);
                                        return date.toLocaleString('en-US', {
                                            weekday: 'short',
                                            month: 'short',
                                            day: 'numeric',
                                            hour: '2-digit',
                                            minute: '2-digit'
                                        });
                                    },
                                    label: function(context) {
                                        return `Portfolio: ${formatCurrency(context.parsed.y)}`;
                                    }
                                }
                            }
                        },
                    scales: {
                            x: {
                                type: 'time',
                                time: {
                                    displayFormats: (() => {
                                        switch(timeframe) {
                                            case '1D':
                                                return {
                                                    hour: 'HH:mm',
                                                    day: 'MMM dd'
                                                };
                                            case '7D':
                                                return {
                                                    day: 'MMM dd',
                                                    week: 'MMM dd'
                                                };
                                            case '1M':
                                                return {
                                                    day: 'MMM dd',
                                                    week: 'MMM dd',
                                                    month: 'MMM yyyy'
                                                };
                                            case 'SI':
                                                return {
                                                    month: 'MMM yyyy',
                                                    year: 'yyyy'
                                                };
                                            default:
                                                return {
                                                    hour: 'HH:mm',
                                                    day: 'MMM dd'
                                                };
                                        }
                                    })(),
                                    tooltipFormat: 'MMM dd HH:mm',
                                    unit: (() => {
                                        switch(timeframe) {
                                            case '1D': return 'hour';
                                            case '7D': return 'day';
                                            case '1M': return 'day';
                                            case 'SI': return 'month';
                                            default: return 'hour';
                                        }
                                    })()
                                },
                                grid: {
                                    display: true,
                                    color: 'rgba(226, 232, 240, 0.6)',
                                    lineWidth: 1,
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#6b7280',
                                    font: {
                                        family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                        size: 11,
                                        weight: '500'
                                    },
                                    maxRotation: 45,
                                    minRotation: 0,
                                    padding: 8,
                                    maxTicksLimit: (() => {
                                        switch(timeframe) {
                                            case '1D': return 12;
                                            case '7D': return 7;
                                            case '1M': return 15;
                                            default: return 12;
                                        }
                                    })()
                                },
                                // Set explicit time boundaries based on timeframe
                                min: timeframe === 'SI' && siMin ? siMin : (() => {
                                    const now = new Date();
                                    switch(timeframe) {
                                        case '1D': return new Date(now.getTime() - 24 * 60 * 60 * 1000);
                                        case '7D': return new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                                        case '1M': return new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                                        default: return new Date(now.getTime() - 24 * 60 * 60 * 1000);
                                    }
                                })(),
                                max: timeframe === 'SI' && siMax ? siMax : new Date(),
                                border: {
                                    display: false
                                }
                            },
                        y: {
                            beginAtZero: false,
                                grid: {
                                    display: true,
                                    color: 'rgba(226, 232, 240, 0.6)',
                                    lineWidth: 1,
                                    drawBorder: false
                                },
                            ticks: {
                                    color: '#6b7280',
                                    font: {
                                        family: '-apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif',
                                        size: 11,
                                        weight: '500',
                                        variant: 'tabular-nums'
                                    },
                                    padding: 12,
                                callback: function(value) {
                                    return formatCurrency(value);
                                }
                                },
                                border: { display: false },
                                suggestedMin: timeframe === 'SI' && siYMin !== null ? siYMin * 0.98 : undefined,
                                suggestedMax: timeframe === 'SI' && siYMax !== null ? siYMax * 1.02 : undefined
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        animation: {
                            // Cinematic but responsive animation per timeframe
                            duration: (function(){
                                switch(timeframe){
                                    case '1D': return 900;
                                    case '7D': return 900;
                                    case '1M': return 700;
                                    default: return 900;
                                }
                            })(),
                            easing: 'easeInOutCubic',
                            delay: (context) => {
                                if (context.type !== 'data' || context.mode !== 'default') return 0;
                                const idx = context.dataIndex || 0;
                                if (timeframe === '1D') return Math.min(idx * 12, 400);    // subtle
                                if (timeframe === '7D') return Math.min(idx * 6, 500);     // gentle build
                                if (timeframe === '1M') return Math.min(idx * 4, 400);     // light
                                return 0;
                            }
                        },
                        elements: {
                            line: {
                                shadowOffsetX: 0,
                                shadowOffsetY: 4,
                                shadowBlur: 12,
                                shadowColor: 'rgba(102, 126, 234, 0.3)'
                            }
                    }
                }
            });
                
                console.log('📊 Beautiful chart updated successfully');
            } catch (error) {
                console.error('❌ Chart creation failed:', error);
                // Show a beautiful fallback message
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif';
                ctx.fillStyle = '#6b7280';
                ctx.fillText('Chart temporarily unavailable', 50, 50);
            }
        }

        // Delta Donut Chart
        let deltaDonutChart = null;
        
        function createDeltaProgressBar() {
            // Calculate portfolio delta using corrected formula
            const deltaData = calculatePortfolioDelta();
            const { netDelta, netDeltaPercent, grossExposure } = deltaData;
            
            // Update delta display
            document.getElementById('delta-value').textContent = formatCurrency(netDelta);
            document.getElementById('delta-percentage').textContent = `${Math.abs(netDeltaPercent).toFixed(1)}%`;
            
            // Calculate progress bar position (0-100%)
            // Convert -50% to +50% delta range to 0-100% progress bar
            const normalizedDelta = Math.max(-50, Math.min(50, netDeltaPercent));
            const progressPosition = ((normalizedDelta + 50) / 100) * 100; // 0-100%
            
            // Update progress bar fill
            const progressFill = document.getElementById('delta-progress-fill');
            const progressIndicator = document.getElementById('delta-progress-indicator');
            
            // Set fill width based on long/short balance
            const longPercentage = (deltaData.totalLongNotional / grossExposure) * 100;
            const shortPercentage = (deltaData.totalShortNotional / grossExposure) * 100;
            
            // Progress bar shows long exposure (from left)
            progressFill.style.width = `${longPercentage}%`;
            progressFill.style.backgroundColor = netDeltaPercent >= 0 ? 
                'rgba(102, 126, 234, 0.3)' : 'rgba(239, 68, 68, 0.3)';
            
            // Indicator shows net delta position
            progressIndicator.style.left = `${progressPosition}%`;
            progressIndicator.style.backgroundColor = netDeltaPercent >= 0 ? 
                'rgba(102, 126, 234, 1)' : 'rgba(239, 68, 68, 1)';
        }
        
        function calculatePortfolioDelta() {
            if (!currentSnapshot.positions) return { netDelta: 0, netDeltaPercent: 0, grossExposure: 0 };
            
            let totalLongNotional = 0;
            let totalShortNotional = 0;
            let totalNotional = 0;
            
            currentSnapshot.positions.forEach(position => {
                const notional = parseFloat(position.target_notional);
                const contracts = parseFloat(position.target_contracts);
                
                if (notional && contracts) {
                    totalNotional += Math.abs(notional);
                    
                    if (contracts > 0) {
                        // Long position
                        totalLongNotional += Math.abs(notional);
                    } else {
                        // Short position
                        totalShortNotional += Math.abs(notional);
                    }
                }
            });
            
            const netDelta = totalLongNotional - totalShortNotional;
            const netDeltaPercent = totalNotional > 0 ? (netDelta / totalNotional) * 100 : 0;
            
            return {
                netDelta,
                netDeltaPercent,
                grossExposure: totalNotional,
                totalLongNotional,
                totalShortNotional
            };
        }
        
        function calculateLongShortMetrics(positions) {
            console.log('🔍 calculateLongShortMetrics called with:', {
                positions: positions ? positions.length : 0,
                currentPrices: currentSnapshot.currentPrices ? Object.keys(currentSnapshot.currentPrices).length : 0,
                baselinePrices: currentSnapshot.baselinePrices ? Object.keys(currentSnapshot.baselinePrices).length : 0
            });
            
            if (!positions || !currentSnapshot.currentPrices || !currentSnapshot.baselinePrices) {
                console.log('⚠️ Missing data in calculateLongShortMetrics');
                return { 
                    longNotional: 0, longPnL: 0, longCount: 0,
                    shortNotional: 0, shortPnL: 0, shortCount: 0 
                };
            }
            
            let longNotional = 0;
            let longPnL = 0;
            let longCount = 0;
            let shortNotional = 0;
            let shortPnL = 0;
            let shortCount = 0;
            
            positions.forEach(position => {
                const notional = parseFloat(position.target_notional);
                const contracts = parseFloat(position.target_contracts);
                const entryPrice = parseFloat(position.ref_price);
                
                // Get current price from currentSnapshot.currentPrices
                const symbol = (position.ticker || position.ric || position.internal_code).replace('_', '');
                const currentPrice = currentSnapshot.currentPrices[symbol];
                const baselinePrice = currentSnapshot.baselinePrices[symbol];
                
                if (notional && contracts && entryPrice && currentPrice && baselinePrice) {
                    // Calculate P&L for this position using baseline vs current
                    const sideMultiplier = contracts > 0 ? 1 : -1; // 1 for long, -1 for short
                    const pnl = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    
                    if (contracts > 0) {
                        // Long position
                        longNotional += Math.abs(notional);
                        longPnL += pnl;
                        longCount++;
                    } else {
                        // Short position
                        shortNotional += Math.abs(notional);
                        shortPnL += pnl;
                        shortCount++;
                    }
                }
            });
            
            const result = {
                longNotional,
                longPnL,
                longCount,
                shortNotional,
                shortPnL,
                shortCount
            };
            
            console.log('📊 calculateLongShortMetrics result:', result);
            console.log('🔍 LONG/SHORT DEBUG: Long P&L =', longPnL.toFixed(2), 'Short P&L =', shortPnL.toFixed(2), 'Total =', (longPnL + shortPnL).toFixed(2));
            return result;
        }
        
        // Top Performers
        function updateTopPerformers() {
            if (!currentSnapshot.positions || !currentSnapshot.currentPrices || !currentSnapshot.baselinePrices) return;
            
            const positions = currentSnapshot.positions.map(position => {
                const symbol = (position.ticker || position.ric || position.internal_code).replace('_', '');
                const currentPrice = currentSnapshot.currentPrices[symbol];
                const baselinePrice = currentSnapshot.baselinePrices[symbol];
                const notional = parseFloat(position.target_notional);
                const contracts = parseFloat(position.target_contracts);
                
                if (currentPrice && baselinePrice && notional && contracts) {
                    const sideMultiplier = contracts > 0 ? 1 : -1;
                    const pnl = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    return {
                        ...position,
                        symbol: position.ticker || position.ric || position.internal_code,
                        pnl,
                        side: contracts > 0 ? 'LONG' : 'SHORT'
                    };
                }
                return null;
            }).filter(p => p !== null);
            
            // Separate longs and shorts
            const longs = positions.filter(p => p.side === 'LONG').sort((a, b) => b.pnl - a.pnl);
            const shorts = positions.filter(p => p.side === 'SHORT').sort((a, b) => b.pnl - a.pnl);
            
            // Update top 3 for each
            updateTopPerformersList('top-long-performers', longs.slice(0, 3));
            updateTopPerformersList('top-short-performers', shorts.slice(0, 3));
        }
        
        function updateTopPerformersList(containerId, performers) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.innerHTML = '';
            
            if (performers.length === 0) {
                container.innerHTML = '<div class="loading">No data available</div>';
                return;
            }
            
            performers.forEach((performer, index) => {
                const item = document.createElement('div');
                item.className = 'top-performer-item';
                item.innerHTML = `
                    <span class="top-performer-rank">${index + 1}</span>
                    <span class="top-performer-symbol symbol" data-symbol="${performer.symbol}">${performer.symbol}</span>
                    <span class="top-performer-pnl ${performer.pnl >= 0 ? 'positive' : 'negative'}">${formatCurrency(performer.pnl)}</span>
                `;
                container.appendChild(item);
            });
        }
        
        // Check if position is in top 3 performers
        function checkIfTopPerformer(symbol, pnl, side) {
            if (!currentSnapshot.positions || !currentSnapshot.currentPrices || !currentSnapshot.baselinePrices) return false;
            
            // Get all positions with their P&L
            const allPositions = currentSnapshot.positions.map(position => {
                const posSymbol = (position.ticker || position.ric || position.internal_code).replace('_', '');
                const currentPrice = currentSnapshot.currentPrices[posSymbol];
                const baselinePrice = currentSnapshot.baselinePrices[posSymbol];
                const notional = parseFloat(position.target_notional);
                const contracts = parseFloat(position.target_contracts);
                
                if (currentPrice && baselinePrice && notional && contracts) {
                    const sideMultiplier = contracts > 0 ? 1 : -1;
                    const posPnl = sideMultiplier * (currentPrice - baselinePrice) / baselinePrice * Math.abs(notional);
                    const posSide = contracts > 0 ? 'LONG' : 'SHORT';
                    return { symbol: posSymbol, pnl: posPnl, side: posSide };
                }
                return null;
            }).filter(p => p !== null);
            
            // Filter by side and sort by absolute P&L
            const sameSidePositions = allPositions.filter(p => p.side === side);
            const top3 = sameSidePositions.sort((a, b) => Math.abs(b.pnl) - Math.abs(a.pnl)).slice(0, 3);
            
            return top3.some(top => top.symbol === symbol);
        }

        // Utility functions
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value);
        }

        function formatPercentage(value) {
            return `${value >= 0 ? '+' : ''}${value.toFixed(2)}%`;
        }

        // Check for new CSV periodically
        async function checkForNewCSV() {
            const csvChanged = await loadDailyCSV();
            if (csvChanged) {
                console.log('🔄 New CSV detected - creating fresh snapshot');
                await createSnapshot();
            }
        }

        // Initialize
        updateTime();
        setInterval(updateTime, 1000);
        
        // Formula Modal Logic
        const formulaMap = {
            'portfolio-value': {
                title: 'Portfolio Value',
                text: 'From S3 latest record: PV_t = portfolio_value. If missing, PV_t = initialCapital + dailyPnL.'
            },
            'daily-pnl': {
                title: 'Daily P&L',
                text: 'From S3 latest record: Daily P&L = daily_pnl. When computing locally: sum over positions [side * (Mark - Baseline) / Baseline * |Notional|].'
            },
            'total-pnl': {
                title: 'Total P&L Since Inception',
                text: 'From S3 latest record: Total P&L = total_pnl. If missing: PortfolioValue - $1,000,000.'
            },
            'positions': {
                title: 'Positions',
                text: 'Count of positions with non-zero target_contracts in the daily CSV.'
            },
            'avg-daily-return': {
                title: 'Average Daily Return',
                text: 'Geometric mean of daily close-to-close returns over the selected window (7D/90D/SI). r_geo = (∏(1 + r_d))^(1/N) − 1. Displayed as %.'
            },
            'long-positions': {
                title: 'Long Positions',
                text: 'Notional = sum(|notional| for longs). Subtitle = Daily Long P&L from S3 audit or local calc.'
            },
            'short-positions': {
                title: 'Short Positions',
                text: 'Notional = sum(|notional| for shorts). Subtitle = Daily Short P&L from S3 audit or local calc.'
            },
            'avg-pnl-per-trade': {
                title: 'Avg P&L per Trade',
                text: 'cardDaily / openPositions, where openPositions counts non-zero target_contracts.'
            },
            'vol-ann': {
                title: 'Volatility (Annualized)',
                text: 'Annualized daily return std dev: vol_ann = stdev(daily_returns) * sqrt(365).'
            },
            'sharpe-ann': {
                title: 'Sharpe (Annualized)',
                text: 'Sharpe_ann = (mean(daily_returns) / stdev(daily_returns)) * sqrt(365). rf = 0. Requires ≥5 daily obs.'
            },
            'risk-corr': {
                title: 'Corr vs BTC',
                text: 'Pearson correlation between aligned daily returns: strategy S (from S3 PV log → per-day open/close) and BTC B (benchmarks/btc_daily_returns.csv). Window: 90D = last 90 overlapping dates; SI = all overlapping dates since inception.'
            },
            'risk-hit': {
                title: 'Hit Rate',
                text: 'Percent of days with S > 0 in the selected window. 90D = last 90 strategy days; SI = since inception (all strategy daily returns).'
            },
            'risk-mdd': {
                title: 'Max Drawdown',
                text: 'From strategy daily returns only. Equity E starts at 1; each day r%: E←E×(1+r/100). Drawdown is min(E/peak − 1) over the selected window, shown in %.'
            }
        };

        function showFormula(key) {
            const def = formulaMap[key];
            if (!def) return;
            document.getElementById('formula-title').textContent = def.title;
            document.getElementById('formula-text').textContent = def.text;
            document.getElementById('formula-modal').classList.remove('hidden');
        }

        function hideFormula() {
            document.getElementById('formula-modal').classList.add('hidden');
        }

        // Bind click handlers to cards after DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            // Only the small "i" icon should open the formula dialog now

            // CSV info toggle
            const csvToggle = document.getElementById('csv-toggle');
            const csvInfo = document.getElementById('csv-info');
            if (csvToggle && csvInfo) {
                // Default hidden; on pulse hide icon entirely (clients shouldn't see this)
                csvInfo.hidden = true;
                if (IS_PULSE) {
                    csvToggle.style.display = 'none';
                } else {
                    csvToggle.addEventListener('click', () => {
                        csvInfo.hidden = !csvInfo.hidden;
                    });
                }
            }
            // Bind metric toggle buttons (7D/90D/SI)
            document.querySelectorAll('.metric-toggle').forEach(btn=>{
                btn.addEventListener('click', ()=>{
                    const tf = btn.getAttribute('data-tf') || '90D';
                    // Only toggle buttons within same card should switch active state
                    const group = btn.closest('.card');
                    if (group) {
                        group.querySelectorAll('.metric-toggle').forEach(b=> b.classList.remove('active'));
                        btn.classList.add('active');
                    }
                    const target = btn.getAttribute('data-target');
                    if (target === 'avg') updateAvgCard(tf);
                    if (target === 'sharpe') updateSharpeCard(tf);
                });
            });

            // Sort header clicks
            document.querySelectorAll('th.sortable').forEach(th => {
                th.style.cursor = 'pointer';
                const arrow = document.createElement('span');
                arrow.textContent = ' \u2195';
                arrow.style.color = '#94a3b8';
                th.appendChild(arrow);
                th.addEventListener('click', () => {
                    const table = th.getAttribute('data-table');
                    const key = th.getAttribute('data-key');
                    const state = window.tableSortState || (window.tableSortState = { long:{key:null,dir:1}, short:{key:null,dir:1} });
                    const cur = state[table];
                    if (cur.key === key) cur.dir = -cur.dir; else { cur.key = key; cur.dir = -1; }
                    // Visual state
                    document.querySelectorAll('th.sortable').forEach(h=>h.classList.remove('sorted-asc','sorted-desc'));
                    th.classList.add(cur.dir === 1 ? 'sorted-asc' : 'sorted-desc');
                    // Re-render
                    updatePositionsTable(referenceCapital);
                });
            });

            // Download widget toggle and presets
            const dwBtn = document.getElementById('download-btn');
            const dwPopover = document.getElementById('download-popover');
            const dwClose = document.getElementById('dw-close');
            const dwStart = document.getElementById('dw-start');
            const dwEnd = document.getElementById('dw-end');
            const dwPresets = document.querySelectorAll('.dw-presets button');
            const setPreset = (days) => {
                const today = new Date();
                const end = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate()));
                let start;
                if (days === 'all') {
                    // leave start empty to indicate full history
                    dwStart.value = '';
                    dwEnd.value = end.toISOString().slice(0,10);
                    return;
                }
                start = new Date(end.getTime() - Number(days) * 24*60*60*1000);
                dwStart.value = start.toISOString().slice(0,10);
                dwEnd.value = end.toISOString().slice(0,10);
            };
            if (dwBtn && dwPopover) {
                dwBtn.addEventListener('click', () => { 
                    const willShow = dwPopover.hidden; 
                    dwPopover.hidden = !dwPopover.hidden; 
                    if (willShow) dwPopover.classList.add('show'); else dwPopover.classList.remove('show');
                });
            }
            const dwX = document.getElementById('dw-x');
            function closePopover(){ dwPopover.classList.remove('show'); dwPopover.hidden = true; }
            if (dwClose && dwPopover) {
                dwClose.addEventListener('click', closePopover);
            }
            if (dwX && dwPopover) {
                dwX.addEventListener('click', closePopover);
            }
            // outside click / Esc to close
            document.addEventListener('click', (e) => {
                if (!dwPopover || dwPopover.hidden) return;
                const within = dwPopover.contains(e.target) || (dwBtn && dwBtn.contains(e.target));
                if (!within) closePopover();
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && dwPopover && !dwPopover.hidden) closePopover();
            });
            if (dwPresets && dwPresets.length) {
                dwPresets.forEach(btn => btn.addEventListener('click', () => {
                    dwPresets.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    setPreset(btn.dataset.preset);
                }));
                // default preset 30D
                setPreset('30');
            }

            // Download handler
            const dwDownload = document.getElementById('dw-download');
            if (dwDownload) {
                dwDownload.addEventListener('click', async () => {
                    try {
                        const fmt = (document.getElementById('dw-format')?.value || 'csv');
                        const series = (document.getElementById('dw-series')?.value || 'daily_returns');
                        // Normalize date inputs from either YYYY-MM-DD or DD/MM/YYYY
                        const normalizeDate = (s) => {
                            if (!s) return '';
                            if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s; // ISO
                            if (/^\d{2}\/\d{2}\/\d{4}$/.test(s)) {
                                const [dd, mm, yyyy] = s.split('/');
                                return `${yyyy}-${mm}-${dd}`; // to ISO
                            }
                            // Fallback: try Date parse
                            const d = new Date(s);
                            if (!isNaN(d.getTime())) return d.toISOString().slice(0,10);
                            return '';
                        };
                        const startStr = normalizeDate(dwStart.value);
                        const endStr = normalizeDate(dwEnd.value);

                        // Load canonical EOD PV history (full history)
                        const eodUrl = `${DATA_PREFIX}eod_pv.csv?cb=${Date.now()}`;
                        console.log('⬇️ Download request:', { series, fmt, eodUrl, startStr, endStr });
                        const eodText = await fetch(eodUrl, { cache: 'no-store' }).then(r => r.ok ? r.text() : '');

                        let eod = [];
                        if (eodText) {
                            const lines = eodText.trim().split('\n');
                            const header = (lines[0] || '').toLowerCase();
                            if (header.includes('date') && header.includes('pv')) lines.shift();
                            lines.forEach(line => {
                                const [d, pvRaw] = line.split(',');
                                const pv = Number(pvRaw);
                                if (d && !Number.isNaN(pv)) eod.push({ Date: d.trim(), PV: pv });
                            });
                        }

                        if (!eod.length) {
                            throw new Error('No EOD PV history available');
                        }

                        // Filter by requested date range (inclusive)
                        const eodFiltered = (!startStr && !endStr)
                            ? eod // ALL history
                            : eod.filter(r => (!startStr || r.Date >= startStr) && (!endStr || r.Date <= endStr));

                        let out = [];
                        if (series === 'daily_pv') {
                            out = eodFiltered;
                        } else {
                            // Compute strategy daily % returns from FULL history,
                            // then slice to requested date range so the first day in-range
                            // uses the previous day's EOD (not 0.00).
                            const sortedAll = [...eod].sort((a,b)=> a.Date.localeCompare(b.Date));
                            let prevCloseAll = null;
                            const returnByDate = new Map();
                            sortedAll.forEach(r => {
                                let perf;
                                if (typeof prevCloseAll === 'number' && prevCloseAll > 0) {
                                    perf = ((r.PV / prevCloseAll) - 1) * 100;
                                } else {
                                    perf = 0; // earliest day only
                                }
                                returnByDate.set(r.Date, perf.toFixed(2));
                                prevCloseAll = r.PV;
                            });

                            const returns = eodFiltered.map(r => ({ Date: r.Date, Performance: returnByDate.get(r.Date) ?? '0.00' }));

                            if (series === 'daily_vs_btc') {
                                // Join with BTC daily returns (best-effort)
                                const btcUrl = '/signal-dashboard/benchmarks/btc_daily_returns.csv?cb=' + Date.now();
                                const btcText = await fetch(btcUrl, { cache: 'no-store' }).then(r => r.ok ? r.text() : '');
                                const btcMap = new Map();
                                if (btcText) {
                                    const bl = btcText.trim().split('\n');
                                    const h = (bl[0] || '').toLowerCase();
                                    if (h.includes('date')) bl.shift();
                                    bl.forEach(line => { const [d, p] = line.split(','); if (d) btcMap.set(d.trim(), String(p ?? '').trim()); });
                                }
                                out = returns.map(r => ({ Date: r.Date, Performance: r.Performance, BTC_Performance: (btcMap.get(r.Date) ?? '') }));
                            } else {
                                out = returns;
                            }
                        }

                        // Emit file
                        if (fmt === 'json') {
                            const blob = new Blob([JSON.stringify(out, null, 2)], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            const base = (series==='daily_pv') ? 'daily_pv' : (series==='daily_vs_btc' ? 'daily_vs_btc' : 'daily_returns');
                            const a = Object.assign(document.createElement('a'), { href: url, download: `${base}_${(startStr||'ALL')}_to_${(endStr||'TODAY')}.json` });
                            document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
                        } else {
                            let header, lines;
                            if (series === 'daily_pv') {
                                header = 'Date,PV';
                                lines = out.map(r => `${r.Date},${r.PV}`);
                            } else if (series === 'daily_vs_btc') {
                                header = 'Date,Performance,BTC_Performance';
                                lines = out.map(r => `${r.Date},${r.Performance},${r.BTC_Performance}`);
                            } else {
                                header = 'Date,Performance';
                                lines = out.map(r => `${r.Date},${r.Performance}`);
                            }
                            const csv = [header].concat(lines).join('\n');
                            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
                            const url = URL.createObjectURL(blob);
                            const base = (series==='daily_pv') ? 'daily_pv' : (series==='daily_vs_btc' ? 'daily_vs_btc' : 'daily_returns');
                            const a = Object.assign(document.createElement('a'), { href: url, download: `${base}_${(startStr||'ALL')}_to_${(endStr||'TODAY')}.csv` });
                            document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
                        }
                    } catch (e) {
                        console.warn('Download failed', e);
                    }
                });
            }
            // Initialize strategy selector and persist choice
            const sel = document.getElementById('strategy-select');
            if (sel) {
                // If demo: hide selector and lock to Diversified
                if (IS_DEMO) {
                    const wrapper = sel.parentElement; if (wrapper) wrapper.style.display = 'none';
                    // Ensure selected option reflects locked prefix
                    for (let i = 0; i < sel.options.length; i++) {
                        if (sel.options[i].value === DATA_PREFIX) { sel.selectedIndex = i; break; }
                    }
                } else {
                    // Non-demo: enable switching
                    for (let i = 0; i < sel.options.length; i++) {
                        if (sel.options[i].value === DATA_PREFIX) { sel.selectedIndex = i; break; }
                    }
                    sel.addEventListener('change', (e) => {
                        const val = e.target.value;
                        localStorage.setItem('DATA_PREFIX', val);
                        // Full reload preserves original initialization order and avoids partial state bugs
                        location.reload();
                    });
                }
            }
        });
        
        // Initialize mobile optimizations
        initMobileOptimizations();
        
            // Load historical PV data from S3 first, THEN load CSV and start snapshots
            loadHistoricalPVData('1D').then(historicalData => {
            console.log(`📊 Loaded ${historicalData.length} historical PV points from S3`);
            console.log('📊 S3 Data:', historicalData);
            pvLogs = historicalData;
            
            // Update portfolio value from latest S3 data
            if (historicalData.length > 0) {
                const latestPV = historicalData[historicalData.length - 1].portfolio_value || historicalData[historicalData.length - 1].portfolioValue;
                if (latestPV && currentSnapshot) {
                    currentSnapshot.portfolioValue = latestPV;
                    console.log(`📊 Updated Portfolio Value from S3: $${latestPV.toFixed(2)}`);
                }
            }
            
            updateChart(historicalData, '1D'); // Pass the data directly to show full chart
            // Initialize S3-derived metrics cards immediately
            initializeMetrics();

            // Render monthly table on pulse/demo
            if (IS_DEMO) {
                try { renderMonthlyTable(); } catch(e) { console.error('Monthly table error', e); }
            }

            // Load PV_pre for accurate percentage calculations (do this early)
            loadPVPre().then(() => {
                console.log('📊 PV_pre loaded for percentage calculations');
            }).catch(error => {
                console.error('Error loading PV_pre:', error);
            });

            // NOW load CSV and start snapshots (after S3 data is loaded)
        loadDailyCSV().then(() => {
                // Create initial snapshot (S3 PV should be set by now)
            createSnapshot();
            
                // Update positions and P&L every 10 seconds (tick by tick) - faster for testing
                setInterval(createSnapshot, 10 * 1000);
            
                // Check for new CSV frequently to catch the 00:30 UTC roll
                // Poll every 2 minutes to avoid missing the fresh daily file
                setInterval(checkForNewCSV, 2 * 60 * 1000);
                
                // Update chart every 2 minutes with fresh S3 data
                setInterval(updateChartFromS3, 2 * 60 * 1000);
            });
            
        }).catch(error => {
            console.error('Error loading historical data:', error);
            console.log('📊 Initializing chart with empty data');
            pvLogs = [];
            updateChart(); // This will show the placeholder chart
            // Initialize S3-derived metrics cards in fallback
                initializeMetrics();
            
            // Still load CSV even if S3 fails
            loadPVPre().then(() => {
                console.log('📊 PV_pre loaded for fallback mode');
            }).catch(error => {
                console.error('Error loading PV_pre in fallback:', error);
            });

            loadDailyCSV().then(() => {
                createSnapshot();
                setInterval(createSnapshot, 10 * 1000);
            setInterval(checkForNewCSV, 10 * 60 * 1000);
                setInterval(updateChartFromS3, 5 * 60 * 1000);
            });
        });
        // CSV info toggleable via button
        
        // Derive a human-friendly source tag from DATA_PREFIX
        function getSourceDescriptor(explicitSource) {
            try {
                if (explicitSource) {
                    if (explicitSource.toLowerCase().includes('ridge')) return 'ridge • ridge_unravel/qube/signal';
                    if (explicitSource.toLowerCase().includes('beta')) return 'beta • ml_qube/qube/signal';
                    if (explicitSource.toLowerCase().includes('unravel')) return 'unravel • combined_descartes_unravel/qube/signal';
                }
                if (!DATA_PREFIX) return '';
                if (DATA_PREFIX.indexOf('descartes-beta') !== -1) {
                    return 'beta • ml_qube/qube/signal';
                }
                if (DATA_PREFIX.indexOf('descartes-ridge-unravel') !== -1) {
                    return 'ridge • ridge_unravel/qube/signal';
                }
                // Default to Unravel mapping
                return 'unravel • combined_descartes_unravel/qube/signal';
            } catch (e) {
                return '';
            }
        }

        // Update CSV filename when data loads
        function updateCSVFilename(filename, uploadedUtc, explicitSource) {
            const csvElement = document.getElementById('csv-filename');
            if (csvElement) {
                if (!filename) {
                    csvElement.textContent = 'No CSV loaded';
                    return;
                }
                const src = getSourceDescriptor(explicitSource);
                let label = filename;
                let ts = null;
                if (uploadedUtc) {
                    // Format like: 2025-10-04 12:02 UTC
                    const d = new Date(uploadedUtc);
                    ts = isNaN(d.getTime()) ? uploadedUtc : `${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,'0')}-${String(d.getUTCDate()).padStart(2,'0')} ${String(d.getUTCHours()).padStart(2,'0')}:${String(d.getUTCMinutes()).padStart(2,'0')} UTC`;
                    label = src ? `${filename} (source: ${src} • loaded: ${ts})` : `${filename} (loaded: ${ts})`;
                }
                csvElement.textContent = label;

                // Also update legacy stamped banner if present (csv-monitor injection)
                try {
                    const nameEl = document.getElementById('csv-name');
                    const tsEl = document.getElementById('csv-timestamp');
                    if (nameEl) nameEl.textContent = filename;
                    if (tsEl) {
                        if (ts) {
                            tsEl.textContent = src ? `(source: ${src} • loaded: ${ts})` : `(loaded: ${ts})`;
                        } else {
                            tsEl.textContent = src ? `(source: ${src})` : '';
                        }
                    }
                } catch (e) { /* no-op */ }
            }
        }
        
        // Mobile-specific optimizations
        function initMobileOptimizations() {
            // Detect mobile device
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                // Reduce update frequency on mobile to save battery
                console.log('📱 Mobile device detected - optimizing for mobile');
                
                // Add mobile-specific classes
                document.body.classList.add('mobile-device');
                
                // Optimize table scrolling on mobile
                const tableContainer = document.querySelector('.table-container');
                if (tableContainer) {
                    tableContainer.style.webkitOverflowScrolling = 'touch';
                }
                
                // Add touch feedback
                const buttons = document.querySelectorAll('.time-button, .refresh-button');
                buttons.forEach(button => {
                    button.addEventListener('touchstart', function() {
                        this.style.opacity = '0.7';
                    });
                    button.addEventListener('touchend', function() {
                        this.style.opacity = '1';
                    });
                });
            }
        }
        
        // Update chart from S3 data every 2 minutes (fresher intraday)
        async function updateChartFromS3() {
            console.log('🔄 Updating chart from S3 data...');
            try {
                const cacheBuster = Date.now();
                const response = await fetch(`${DATA_PREFIX}portfolio_value_log.jsonl?cb=${cacheBuster}`, { cache: 'no-store' });
                if (!response.ok) {
                    console.log('⚠️ No S3 data available yet, keeping current chart');
                    return;
                }

                const text = await response.text();
                const lines = text.trim().split('\n').filter(Boolean);
                const s3Data = lines.map(line => JSON.parse(line));

                // Update S3-derived totals ONLY (do not override PV; PV = pv_pre + dailyPnL)
                if (s3Data.length > 0) {
                    const last = s3Data[s3Data.length - 1];
                    if (typeof last.total_pnl === 'number') currentSnapshot.s3TotalPnL = last.total_pnl;
                    if (typeof last.daily_pnl === 'number') currentSnapshot.s3DailyPnL = last.daily_pnl;
                    updateUI();
                }

                // Choose data source by timeframe
                const activeButton = document.querySelector('.time-button.active');
                const timeframe = activeButton ? activeButton.textContent : '1D';
                let displayData;
                if (timeframe === '1D') {
                    // Intraday JSONL for 1D only, but rebase Y values to pv_pre + intraday Δ
                    if (typeof currentPVPre === 'number' && isFinite(currentPVPre)) {
                        try {
                            const first = s3Data.find(Boolean);
                            const firstPv = first ? (first.portfolio_value ?? first.portfolioValue) : null;
                            displayData = s3Data.map((pt) => {
                                const pv = (pt.portfolio_value ?? pt.portfolioValue);
                                // If S3 sends absolute PV, convert to delta relative to first point, then rebase to pv_pre
                                if (typeof pv === 'number' && typeof firstPv === 'number') {
                                    const delta = pv - firstPv; // absolute delta across the day
                                    return { timestamp: pt.timestamp, portfolio_value: currentPVPre + delta };
                                }
                                // If S3 provides daily_pnl, use it directly
                                if (typeof pt.daily_pnl === 'number') {
                                    return { timestamp: pt.timestamp, portfolio_value: currentPVPre + pt.daily_pnl };
                                }
                                return { timestamp: pt.timestamp, portfolio_value: currentPVPre };
                            });
                        } catch(e){ displayData = s3Data; }
                    } else {
                        displayData = s3Data;
                    }
                } else {
                    // Canonical EOD PV from CSV for long windows
                    displayData = await loadHistoricalPVData(timeframe);
                }

                updateChart(displayData, timeframe);
                console.log(`📊 Chart updated for ${timeframe} with ${displayData.length} points`);

                // Refresh S3-derived metric cards (avg daily return, vol, sharpe)
                updateS3MetricsCards();
            } catch (error) {
                console.error('Error updating chart from S3:', error);
                console.log('📊 Keeping current chart data due to error');
            }
        }

        // ===== S3-derived Metrics: Avg Daily Return, Vol (Ann.), Sharpe (Ann.) =====
        function groupByUtcDay(series) {
            const groups = new Map();
            series.forEach(pt => {
                const d = new Date(pt.timestamp);
                const dayKey = d.toISOString().slice(0,10); // YYYY-MM-DD
                const arr = groups.get(dayKey) || [];
                arr.push(pt);
                groups.set(dayKey, arr);
            });
            return groups;
        }

        function computeDailyReturnsFromPV(series) {
            // Group points by UTC day and use first/last PV per day
            const groups = groupByUtcDay(series);
            const dailyReturns = [];
            for (const [day, points] of groups.entries()) {
                const sorted = points.slice().sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
                const first = sorted[0];
                const last = sorted[sorted.length - 1];
                const pv0 = first.portfolio_value || first.portfolioValue;
                const pv1 = last.portfolio_value || last.portfolioValue;
                if (typeof pv0 === 'number' && pv0 > 0 && typeof pv1 === 'number') {
                    const r = (pv1 - pv0) / pv0; // simple daily return
                    dailyReturns.push(r);
                }
            }
            return dailyReturns;
        }

        function mean(values) {
            if (!values || values.length === 0) return null;
            return values.reduce((a,b) => a + b, 0) / values.length;
        }

        function stddev(values) {
            if (!values || values.length < 2) return null;
            const m = mean(values);
            const varSum = values.reduce((acc, v) => acc + (v - m) * (v - m), 0);
            const variance = varSum / (values.length - 1); // sample stddev
            return Math.sqrt(variance);
        }

        function computeMonthlyFromDaily(daily) {
            // daily: array of decimal returns, but we also need dates; recompute from full PV to get dates
            // We'll load full SI PV and rebuild daily with dates here for robustness
            // Returns: { [year]: { Jan: pct, Feb: pct, ... , YTD: pct } }
            const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            // Use full SI PV to get EOD closes for every day since inception
            return (async () => {
                const pvAll = await loadHistoricalPVData('SI');
                if (!pvAll || pvAll.length === 0) return {};
                const groups = groupByUtcDay(pvAll);
                const closes = [];
                for (const [day, points] of groups.entries()) {
                    const sorted = points.slice().sort((a,b)=> new Date(a.timestamp)-new Date(b.timestamp));
                    const last = sorted[sorted.length-1];
                    const close = last.portfolio_value || last.portfolioValue;
                    if (typeof close === 'number') closes.push({ date: day, close });
                }
                closes.sort((a,b)=> a.date.localeCompare(b.date));
                const daily = [];
                for (let i=1;i<closes.length;i++){
                    const prev=closes[i-1].close, cur=closes[i].close;
                    if (prev>0) daily.push({ date: closes[i].date, r: (cur/prev)-1 });
                }
                const acc = {};
                for (const row of daily){
                    const [y,m] = row.date.split('-');
                    const monthKey = months[Math.max(0, Math.min(11, parseInt(m,10)-1))];
                    acc[y] = acc[y] || { cum: 1 };
                    acc[y][monthKey] = (acc[y][monthKey] ?? 1) * (1 + row.r);
                    acc[y].cum *= (1 + row.r);
                }
                for (const y of Object.keys(acc)){
                    const row = acc[y];
                    for (const mk of months) if (row[mk] !== undefined) row[mk] = (row[mk]-1)*100;
                    row.YTD = (row.cum-1)*100;
                    delete row.cum;
                }
                return acc;
            })();
        }

        async function renderMonthlyTable() {
            const section = document.getElementById('monthly-returns-section');
            const thead = document.getElementById('monthly-thead');
            const tbody = document.getElementById('monthly-tbody');
            if (!section || !thead || !tbody) return;
            const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            const data = await computeMonthlyFromDaily();
            const years = Object.keys(data).sort((a,b)=> parseInt(b,10)-parseInt(a,10));
            // Header
            thead.innerHTML = '<tr><th>Year</th>' + months.map(m=>`<th>${m}</th>`).join('') + '<th>YTD</th></tr>';
            // Body
            tbody.innerHTML = years.map(y=>{
                const row = data[y];
                const tds = months.map(m=>{
                    const v = row[m];
                    if (v === undefined) return '<td></td>';
                    const cls = v >= 0 ? 'perf-pos' : 'perf-neg';
                    return `<td class="${cls}">${v.toFixed(2)}%</td>`;
                }).join('');
                const ytdCls = (row.YTD ?? 0) >= 0 ? 'perf-pos' : 'perf-neg';
                const ytd = row.YTD !== undefined ? `<td class="${ytdCls}">${row.YTD.toFixed(2)}%</td>` : '<td></td>';
                return `<tr><td>${y}</td>${tds}${ytd}</tr>`;
            }).join('');
            section.style.display = 'block';
        }

        // Cache SI daily returns for metrics to avoid refetching
        let METRICS_DAILY_ALL = null; // numbers in decimal (not %)

        async function ensureMetricsDaily() {
            if (Array.isArray(METRICS_DAILY_ALL)) return METRICS_DAILY_ALL;
            const pvAll = await loadHistoricalPVData('SI');
            METRICS_DAILY_ALL = computeDailyReturnsFromPV(pvAll);
            return METRICS_DAILY_ALL;
        }

        function sliceByScope(arr, scope) {
            if (!Array.isArray(arr)) return [];
            if (scope === '7D' && arr.length > 7) return arr.slice(-7);
            if (scope === '90D' && arr.length > 90) return arr.slice(-90);
            return arr;
        }

        async function updateAvgCard(scope) {
            const dailyAll = await ensureMetricsDaily();
            const daily = sliceByScope(dailyAll, scope);
            const days = daily.length;
            // Geometric mean of daily returns: (∏(1+r))^(1/N) - 1
            let geo = null;
            if (days > 0) {
                const product = daily.reduce((acc, r) => acc * (1 + r), 1);
                geo = Math.pow(product, 1 / days) - 1;
            }
            const el = document.getElementById('avg-daily-return');
            const meta = document.getElementById('avg-daily-return-meta');
            if (el) el.textContent = Number.isFinite(geo) ? `${(geo*100).toFixed(2)}%` : 'N/A';
            if (meta) meta.textContent = `based on ${days} day${days===1?'':'s'}`;
        }

        async function updateVolCardSI() {
            const dailyAll = await ensureMetricsDaily();
            const s = stddev(dailyAll);
            const el = document.getElementById('vol-ann');
            const meta = document.getElementById('vol-ann-meta');
            if (s !== null && el) {
                const volAnn = s * Math.sqrt(365);
                el.textContent = `${(volAnn*100).toFixed(2)}%`;
                if (meta) meta.textContent = `${dailyAll.length} daily obs`;
            } else {
                if (el) el.textContent = 'N/A';
                if (meta) meta.textContent = 'insufficient data';
            }
        }

        async function updateSharpeCard(scope) {
            const dailyAll = await ensureMetricsDaily();
            const daily = sliceByScope(dailyAll, scope);
            const days = daily.length;
            const m = mean(daily);
            const s = stddev(daily);
            const el = document.getElementById('sharpe-ann');
            const meta = document.getElementById('sharpe-ann-meta');
            const MIN_DAYS_FOR_SHARPE = 5;
            if (days >= MIN_DAYS_FOR_SHARPE && s !== null && s > 0 && el) {
                const sharpeAnn = (m / s) * Math.sqrt(365);
                el.textContent = `${sharpeAnn.toFixed(2)}`;
                if (meta) meta.textContent = `${days} daily obs`;
            } else {
                if (el) el.textContent = 'N/A';
                if (meta) meta.textContent = `need ≥ ${MIN_DAYS_FOR_SHARPE} days`;
            }
        }

        async function initializeMetrics() {
            await ensureMetricsDaily();
            // Defaults: avg 90D, sharpe 90D, vol SI
            await updateAvgCard('90D');
            await updateSharpeCard('90D');
            await updateVolCardSI();
        }

        function setMetricsNA() {
            const avgEl = document.getElementById('avg-daily-return');
            const avgMetaEl = document.getElementById('avg-daily-return-meta');
            const volEl = document.getElementById('vol-ann');
            const volMetaEl = document.getElementById('vol-ann-meta');
            const sharpeEl = document.getElementById('sharpe-ann');
            const sharpeMetaEl = document.getElementById('sharpe-ann-meta');
            if (avgEl) avgEl.textContent = 'N/A';
            if (avgMetaEl) avgMetaEl.textContent = 'insufficient data';
            if (volEl) volEl.textContent = 'N/A';
            if (volMetaEl) volMetaEl.textContent = 'insufficient data';
            if (sharpeEl) sharpeEl.textContent = 'N/A';
            if (sharpeMetaEl) sharpeMetaEl.textContent = 'insufficient data';
        }
    </script>
    
    <style>
        /* Formula Modal */
        .formula-modal.hidden { display: none; }
        .formula-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .formula-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            max-width: 640px;
            width: calc(100% - 32px);
            box-shadow: var(--shadow-lg);
        }
        .formula-title {
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--text-primary);
        }
        .formula-text {
            color: var(--text-secondary);
            line-height: 1.5;
        }
        .formula-close {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            cursor: pointer;
        }
        .chart-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .csv-info[hidden] { display: none !important; }
        .csv-info { display: inline-flex; align-items: center; gap: 6px; }
        .csv-toggle {
            background: transparent;
            border: 0;
            cursor: pointer;
            font-size: 16px;
            margin-right: 8px;
            color: #10b981;
        }
        .csv-toggle:hover { opacity: 0.8; }
        /* Download widget */
        .download-widget { position: relative; margin-left: 8px; }
        .download-button { padding: 8px 14px; border-radius: 12px; border: 1px solid #e5e7eb; background:#ffffff; color:#111827; cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,0.05); }
        .download-button:hover { background:#f9fafb; transform: translateY(-1px); box-shadow:0 4px 10px rgba(0,0,0,0.08); }
        /* Solid theme (no glass) for universal consistency */
        .download-popover { position:absolute; top:40px; right:0; background:#ffffff; border:1px solid #e5e7eb; border-radius:16px; padding:16px; box-shadow:0 24px 40px rgba(2,8,23,0.16), 0 4px 10px rgba(2,8,23,0.06); width:320px; z-index:1000; }
        .download-popover { opacity:0; transform:translateY(-6px); transition:opacity .18s ease, transform .18s ease; }
        .download-popover[hidden] { display:none; }
        .download-popover.show { opacity:1; transform:translateY(0); }
        .download-popover::after { content:''; position:absolute; top:-6px; right:18px; width:12px; height:12px; background:#ffffff; border-left:1px solid #e5e7eb; border-top:1px solid #e5e7eb; transform: rotate(45deg); }
        .dw-header { display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; padding:10px 12px; border-radius:12px; background:linear-gradient(135deg,#4338ca 0%, #7c3aed 100%); color:#fff; }
        .dw-title { font-weight:700; color:#ffffff; letter-spacing:.2px; }
        .dw-x { background:transparent; border:0; font-size:18px; line-height:1; cursor:pointer; color:#ffffff; opacity:0.85; }
        .dw-row { display:flex; align-items:center; justify-content:space-between; margin:12px 0; }
        .dw-label { color:#475569; font-size:12px; margin-right:8px; font-weight:600; }
        .dw-range { display:flex; align-items:center; gap:6px; }
        .dw-range input[type=date] { -webkit-appearance:none; appearance:none; border:1px solid #e5e7eb; border-radius:10px; padding:8px 10px; font-size:12px; color:#111827; background:#fff; font-variant-numeric: tabular-nums; letter-spacing:0.2px; }
        .dw-range input[type=date]::-webkit-calendar-picker-indicator{ filter:invert(35%); opacity:0.8; cursor:pointer; }
        select#dw-series, select#dw-format { border:1px solid #e5e7eb; border-radius:10px; padding:6px 8px; font-size:12px; color:#111827; background:#fff; min-width:120px; }
        .dw-sep { color:#9ca3af; font-size:12px; }
        .dw-presets { gap:6px; }
        .dw-presets button { border:1px solid #e5e7eb; background:#fff; border-radius:10px; padding:6px 10px; cursor:pointer; font-size:12px; color:#111827; }
        .dw-presets button.active { background:#eef2ff; border-color:#c7d2fe; color:#4f46e5; box-shadow:0 2px 6px rgba(79,70,229,0.18); }
        .dw-note { color:#94a3b8; font-size:12px; justify-content:flex-start; }
        .dw-actions { gap:8px; justify-content:flex-end; margin-top:6px; }
        .dw-actions .primary { background:linear-gradient(135deg,#667eea 0%, #764ba2 100%); color:#fff; border:0; border-radius:999px; padding:10px 16px; cursor:pointer; box-shadow:0 8px 16px rgba(102,126,234,0.35); font-weight:600; }
        .dw-actions .primary:hover { filter:brightness(1.03); transform:translateY(-1px); }
        .dw-actions .secondary { background:#fff; color:#111827; border:1px solid #e5e7eb; border-radius:999px; padding:9px 14px; cursor:pointer; }
        /* removed */
        .refresh-button {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(248, 250, 252, 0.9) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(226, 232, 240, 0.8);
            color: #64748b;
            border: none;
            padding: 10px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .refresh-button:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 1) 0%, rgba(248, 250, 252, 1) 100%);
            border-color: rgba(102, 126, 234, 0.3);
            color: #475569;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.12);
            transform: translateY(-1px);
        }
        .refresh-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .refresh-button svg {
            transition: transform 0.3s ease;
        }
        .refresh-button:hover svg {
            transform: rotate(180deg);
        }
        
        /* Mobile-specific enhancements */
        /* Monthly table */
        .monthly-table { width:100%; border-collapse: separate; border-spacing:0; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:12px; overflow:hidden; }
        .monthly-table thead th { font-weight:600; font-size:12px; color:#64748b; background:var(--bg-tertiary); padding:10px 8px; border-bottom:1px solid var(--border-color); text-align:right; }
        .monthly-table thead th:first-child, .monthly-table tbody td:first-child { text-align:left; padding-left:12px; }
        .monthly-table tbody td { padding:10px 8px; font-variant-numeric: tabular-nums; text-align:right; border-bottom:1px solid var(--border-color); }
        .monthly-table tbody tr:last-child td { border-bottom:0; }
        .perf-pos { color:#059669; }
        .perf-neg { color:#dc2626; }
        .mobile-device .metric-card {
            transition: all 0.2s ease;
        }
        
        .mobile-device .metric-card:active {
            transform: scale(0.98);
            opacity: 0.9;
        }
        
        .mobile-device .table-container {
            border-radius: 12px;
            overflow: hidden;
        }
        
        .mobile-device table {
            border-collapse: separate;
            border-spacing: 0;
        }
        th.sortable { position: relative; user-select:none; }
        th.sortable::after { content:'\25B4'; position:absolute; right:8px; top:50%; transform:translateY(-60%) rotate(180deg); font-size:10px; opacity:.35; }
        th.sortable.sorted-asc::after { content:'\25B4'; transform:translateY(-60%) rotate(0deg); opacity:.9; }
        th.sortable.sorted-desc::after { content:'\25BE'; opacity:.9; }
        
        .mobile-device th:first-child,
        .mobile-device td:first-child {
            padding-left: var(--space-sm);
        }
        
        .mobile-device th:last-child,
        .mobile-device td:last-child {
            padding-right: var(--space-sm);
        }
        
        /* Mobile loading state */
        @media (max-width: 768px) {
            .loading-spinner {
                width: 40px;
                height: 40px;
            }
            
            .loading-text {
                font-size: 0.875rem;
                margin-top: var(--space-sm);
            }
        }
        
        /* Improve mobile chart interaction */
        @media (max-width: 768px) {
            .chart-container canvas {
                max-height: 250px;
            }
            
            .chart-controls {
                padding: var(--space-sm);
                background: var(--bg-card);
                border-radius: 12px;
                margin-top: var(--space-sm);
            }
        }
    </style>
</body>
</html>
<script>
(function(){
  try {
    window.PulseDiag = {
      version: 'pulse-diag-1',
      seriesSummary: function() {
        try {
          var s = window.currentSnapshot || {}; 
          return {
            positions: (s.positions||[]).length,
            baselineKeys: Object.keys(s.baselinePrices||{}).length,
            currentPriceKeys: Object.keys(s.currentPrices||{}).length,
            timeframe: window.currentTimeframe || '1D'
          };
        } catch(e){ return { error: String(e) }; }
      },
      sumDailyPnl: function() {
        try {
          var s = window.currentSnapshot || {};
          var positions = s.positions || [];
          var bp = s.baselinePrices || {};
          var cp = s.currentPrices || {};
          var total = 0, count = 0;
          for (var i=0;i<positions.length;i++){
            var p = positions[i];
            var sym = p.symbol || p.ticker || p.asset || p.name;
            if (!sym) continue;
            var b = bp[sym]; var c = cp[sym];
            if (!b || !c) continue;
            var side = (typeof p.side === 'number') ? p.side : ((p.contracts||0) >= 0 ? 1 : -1);
            var notional = Math.abs(p.notional || 0);
            if (!notional && typeof p.weight === 'number') {
              var ref = (window.currentPVPre || window.referenceCapital || 1000000);
              notional = Math.abs(p.weight * ref);
            }
            if (!notional) continue;
            var pnl = side * (c - b) / b * notional;
            total += pnl; count++;
          }
          return { total: +total.toFixed(2), counted: count };
        } catch(e){ return { error: String(e) }; }
      },
      validateDailyPnl: function(){
        try {
          var calc = this.sumDailyPnl();
          var s = window.currentSnapshot || {};
          var card = (typeof s.dailyPnL === 'number') ? s.dailyPnL : null;
          var diff = (card!=null && calc.total!=null) ? (card - calc.total) : null;
          return { ok: diff!=null && Math.abs(diff) < 0.02, calc: calc.total, card: card, diffAbs: diff!=null?+Math.abs(diff).toFixed(2):null };
        } catch(e){ return { error: String(e) }; }
      }
    };
  } catch(e){}
})();
</script>
