<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            color: #2c3e50;
            line-height: 1.6;
            min-height: 100vh;
        }
        
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .primary-metric {
            border-left: 4px solid #007bff;
            background: #f8f9fa;
        }
        
        .secondary-metric {
            border-left: 4px solid #6c757d;
            background: #ffffff;
        }
        
        .card {
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #e9ecef;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .card:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            transform: translateY(-1px);
        }
        
        .card h3 {
            color: #6c757d;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        
        .card .value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #2c3e50;
            letter-spacing: -0.01em;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .card .percentage {
            font-size: 0.9rem;
            font-weight: 500;
            color: #6c757d;
            margin-top: 0.25rem;
            opacity: 0.8;
        }
        
        .card .percentage.positive {
            color: #28a745;
        }
        
        .card .percentage.negative {
            color: #dc3545;
        }
        
        .card .value.positive {
            color: #28a745;
        }
        
        .card .value.negative {
            color: #dc3545;
        }
        
        .portfolio-table {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
        }
        
        .portfolio-table table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .portfolio-table th {
            background: #f8f9fa;
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
        }
        
        .portfolio-table td {
            padding: 1rem;
            border-bottom: 1px solid #e9ecef;
            color: #2c3e50;
        }
        
        .portfolio-table tr:hover {
            background: rgba(102, 126, 234, 0.05);
        }
        
        .side-long {
            color: #28a745;
            font-weight: 600;
        }
        
        .side-short {
            color: #dc3545;
            font-weight: 600;
        }
        
        .positive {
            color: #28a745;
        }
        
        .negative {
            color: #dc3545;
        }
        
        .pnl-positive {
            color: #388e3c;
            font-weight: 600;
            background-color: rgba(76, 175, 80, 0.08);
            padding: 2px 4px;
            border-radius: 3px;
            border-left: 2px solid #66bb6a;
        }
        
        .pnl-negative {
            color: #d32f2f;
            font-weight: 600;
            background-color: rgba(244, 67, 54, 0.08);
            padding: 2px 4px;
            border-radius: 3px;
            border-left: 2px solid #ef5350;
        }
        
        .net-pnl-row {
            background-color: #f8f9fa;
            border-top: 2px solid #e9ecef;
            font-weight: 600;
        }
        
        .net-pnl-row td {
            padding: 0.75rem 1rem;
        }
        
        .net-pnl-row .pnl-positive {
            color: #2e7d32;
            font-weight: 700;
            background-color: rgba(76, 175, 80, 0.12);
            padding: 3px 6px;
            border-radius: 4px;
            border-left: 3px solid #66bb6a;
        }
        
        .net-pnl-row .pnl-negative {
            color: #c62828;
            font-weight: 700;
            background-color: rgba(244, 67, 54, 0.12);
            padding: 3px 6px;
            border-radius: 4px;
            border-left: 3px solid #ef5350;
        }
        
        .loading {
            text-align: center;
            padding: 2rem;
            color: #6c757d;
        }
        
        /* Notification Styles */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            min-width: 300px;
            max-width: 500px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-left: 4px solid #667eea;
            animation: slideIn 0.3s ease-out;
        }
        
        .notification-success {
            border-left-color: #28a745;
        }
        
        .notification-error {
            border-left-color: #dc3545;
        }
        
        .notification-warning {
            border-left-color: #ffc107;
        }
        
        .notification-content {
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .notification-icon {
            font-size: 1.2rem;
        }
        
        .notification-message {
            flex: 1;
            color: #2c3e50;
            font-size: 0.9rem;
        }
        
        .notification-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #6c757d;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .notification-close:hover {
            color: #2c3e50;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* Monitoring Status */
        .monitoring-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            z-index: 1000;
        }
        
        .monitoring-status.active {
            background: rgba(40, 167, 69, 0.9);
        }
        
        .monitoring-status.inactive {
            background: rgba(220, 53, 69, 0.9);
        }
        
        /* Graph Card Styles */
        .graph-card {
            margin-bottom: 2rem;
        }
        
        .graph-container {
            position: relative;
            height: 300px;
            margin: 1rem 0;
        }
        
        .graph-info {
            text-align: center;
            margin-top: 0.5rem;
        }
        
        .graph-label {
            font-size: 0.85rem;
            color: #6c757d;
            font-style: italic;
        }
        
        /* Navigation Bar */
        .nav-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1.5rem;
            border-bottom: 2px solid #e9ecef;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .nav-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        
        .clock-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }
        
        .clock {
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            font-weight: 600;
            color: #667eea;
            background: #f8f9fa;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            min-width: 200px;
            text-align: center;
        }
        
        .timezone-info {
            font-size: 0.75rem;
            color: #6c757d;
            font-weight: 500;
        }
        
        /* CSV Status Bar */
        .csv-status-bar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 0.25rem 0;
            font-size: 0.8rem;
        }
        
        .csv-status-label {
            color: #6c757d;
            font-weight: 500;
        }
        
        .csv-filename {
            color: #667eea;
            font-weight: 600;
            cursor: pointer;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .csv-filename:hover {
            background: #f0f4ff;
            color: #4c63d2;
        }
        
        .filename-display {
            font-family: 'Courier New', monospace;
        }
        
        .click-hint {
            font-size: 0.7rem;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .csv-filename:hover .click-hint {
            opacity: 1;
        }
        
        /* Notification Styles */
        .notification {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-left: 4px solid #667eea;
            margin-bottom: 10px;
            min-width: 300px;
            max-width: 400px;
            animation: slideIn 0.3s ease-out;
        }
        
        .notification-success {
            border-left-color: #28a745;
        }
        
        .notification-error {
            border-left-color: #dc3545;
        }
        
        .notification-warning {
            border-left-color: #ffc107;
        }
        
        .notification-content {
            padding: 1rem;
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
        }
        
        .notification-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }
        
        .notification-text {
            flex: 1;
        }
        
        .notification-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        
        .notification-message {
            color: #6c757d;
            font-size: 0.85rem;
            line-height: 1.4;
        }
        
        .notification-close {
            background: none;
            border: none;
            font-size: 1.2rem;
            color: #6c757d;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .notification-close:hover {
            color: #2c3e50;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .nav-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }
        
        .nav-button:hover {
            background: #5a6fd8;
        }
        
        .dashboard-title {
            color: #2c3e50;
            font-size: 1.5rem;
            margin: 0;
        }
        
        .dashboard-subtitle {
            font-size: 0.9rem;
            color: #6c757d;
            margin: 0.25rem 0 0 0;
            font-weight: 400;
        }
        
        /* Portfolio Sections */
        .portfolio-section {
            margin-bottom: 2rem;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .section-title {
            color: #2c3e50;
            font-size: 1.2rem;
            font-weight: 600;
            margin: 0;
        }
        
        .section-summary {
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        .summary-value {
            color: #2c3e50;
            font-weight: 600;
            font-size: 1rem;
        }
    </style>
</head>
<body>
    
    <div class="container">
        <!-- Navigation -->
        <div class="nav-bar">
            <button class="nav-button" onclick="window.location.href='index.html'">← Back to Homepage</button>
            <div class="nav-center">
                <h1 class="dashboard-title">Strategy Monitor</h1>
                <p class="dashboard-subtitle">In-house simple strategy tracking & monitoring</p>
                <div class="csv-status-bar">
                    <span class="csv-status-label">Data:</span>
                    <span id="current-csv-filename" class="csv-filename" onclick="toggleCSVDetails()" title="Click to show file details">
                        <span class="filename-display">Click to show file</span>
                        <span class="click-hint">ℹ️</span>
                    </span>
                </div>
                <div class="clock-container">
                    <div class="clock" id="clock">Loading...</div>
                    <div class="timezone-info">UTC / Paris</div>
                </div>
            </div>
        </div>
        
        <script>
            (function initialClock() {
                try {
                    var el = document.getElementById('clock');
                    if (el) {
                        var now = new Date();
                        var utc = now.toISOString().substr(11, 8);
                        var paris = now.toLocaleString('en-GB', {
                            timeZone: 'Europe/Paris',
                            hour12: false,
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                        el.textContent = utc + ' / ' + paris;
                    }
                } catch (e) {
                    // no-op
                }
            })();
        </script>

        <div class="summary-cards">
            <!-- Primary Performance Metrics -->
            <div class="card primary-metric">
                <h3>Portfolio Value</h3>
                <div class="value" id="portfolio-value">$1,000,000</div>
            </div>
            <div class="card primary-metric">
                <h3>Daily P&L</h3>
                <div class="value" id="daily-pnl">$0</div>
                <div class="percentage" id="daily-pnl-percent">(0.00%)</div>
            </div>
            <div class="card primary-metric">
                <h3>Total P&L Since Inception</h3>
                <div class="value" id="cumulative-pnl">$0</div>
                <div class="percentage" id="total-pnl-percent">(0.00%)</div>
            </div>
            <div class="card secondary-metric">
                <h3>Total Notional at Entry</h3>
                <div class="value" id="total-notional-at-entry">$0</div>
            </div>
            <div class="card secondary-metric">
                <h3>Positions</h3>
                <div class="value" id="position-count">0</div>
            </div>
        </div>
        
        <!-- Portfolio Value Evolution Graph -->
        <div class="card graph-card">
            <h3>Portfolio Value Evolution</h3>
            <div class="graph-container">
                <canvas id="portfolioValueChart" width="800" height="300"></canvas>
            </div>
            <div class="graph-info">
                <span class="graph-label">Daily portfolio value tracking since inception</span>
            </div>
        </div>
        
        <!-- Long Positions Section -->
        <div class="portfolio-section">
            <div class="section-header">
                <h3 class="section-title">Long Positions</h3>
                <div class="section-summary">
                    Total Notional at Entry: <span id="long-total-notional" class="summary-value">$0.00</span>
                </div>
            </div>
            <div class="portfolio-table-container">
                <table class="portfolio-table">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Side</th>
                            <th>Weight %</th>
                            <th>Notional $</th>
                            <th>Entry Price</th>
                            <th>Current Price</th>
                            <th>P&L $</th>
                            <th>P&L %</th>
                        </tr>
                    </thead>
                    <tbody id="long-portfolio-tbody">
                        <tr>
                            <td colspan="8" class="loading">Loading long positions...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Short Positions Section -->
        <div class="portfolio-section">
            <div class="section-header">
                <h3 class="section-title">Short Positions</h3>
                <div class="section-summary">
                    Total Notional at Entry: <span id="short-total-notional" class="summary-value">$0.00</span>
                </div>
            </div>
            <div class="portfolio-table-container">
                <table class="portfolio-table">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Side</th>
                            <th>Weight %</th>
                            <th>Notional $</th>
                            <th>Entry Price</th>
                            <th>Current Price</th>
                            <th>P&L $</th>
                            <th>P&L %</th>
                        </tr>
                    </thead>
                    <tbody id="short-portfolio-tbody">
                        <tr>
                            <td colspan="8" class="loading">Loading short positions...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- Monitoring Status -->
    <div class="monitoring-status" id="monitoring-status">
        🔄 Monitoring CSV files...
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="scripts/csv-monitor.js"></script>
    <script src="scripts/portfolio-logger.js"></script>
    <script>
        let portfolioData = [];
        let currentPrices = {};
        let csvMonitor = null;
        let portfolioLogger = null;
        let portfolioValueChart = null;
        let preExecutionPortfolioValue = 1000000; // Value before CSV execution
        let cumulativePnL = 0; // Track cumulative P&L since inception
        let initialCapital = 1000000; // Starting capital
        
        // Initialize Portfolio Value Chart
        function initializePortfolioValueChart() {
            const ctx = document.getElementById('portfolioValueChart').getContext('2d');
            portfolioValueChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Portfolio Value',
                        data: [],
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: '#667eea',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return 'Portfolio Value: ' + formatCurrency(context.parsed.y);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Date'
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Portfolio Value ($)'
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return '$' + (value / 1000000).toFixed(1) + 'M';
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }
        
        // Add new data point to portfolio value chart
        function addPortfolioValueDataPoint(date, portfolioValue) {
            if (portfolioValueChart) {
                portfolioValueChart.data.labels.push(date);
                portfolioValueChart.data.datasets[0].data.push(portfolioValue);
                portfolioValueChart.update('none'); // Update without animation for performance
                console.log(`📈 Added new portfolio value data point: ${date} = $${formatCurrency(portfolioValue)}`);
            }
        }
        
        // Make function available globally for portfolio logger
        window.addPortfolioValueDataPoint = addPortfolioValueDataPoint;
        
        // Load and display portfolio value history
        async function loadPortfolioValueHistory() {
            try {
                const response = await fetch('portfolio_daily_log.csv');
                if (!response.ok) {
                    console.log('📊 No portfolio log file found, starting fresh');
                    return;
                }
                
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');
                if (lines.length < 2) return;
                
                const headers = lines[0].split(',');
                const dateIndex = headers.indexOf('date');
                const portfolioValueIndex = headers.indexOf('portfolio_value');
                const actionIndex = headers.indexOf('action');
                
                if (dateIndex === -1 || portfolioValueIndex === -1 || actionIndex === -1) return;
                
                const chartData = [];
                const chartLabels = [];
                
                // Process each line and collect post_execution entries
                for (let i = 1; i < lines.length; i++) {
                    const row = lines[i].split(',');
                    if (row.length >= headers.length) {
                        const action = row[actionIndex];
                        if (action === 'post_execution') {
                            const date = row[dateIndex];
                            const portfolioValue = parseFloat(row[portfolioValueIndex]);
                            
                            if (!isNaN(portfolioValue)) {
                                chartLabels.push(date);
                                chartData.push(portfolioValue);
                            }
                        }
                    }
                }
                
                // Update chart with historical data
                if (chartData.length > 0) {
                    portfolioValueChart.data.labels = chartLabels;
                    portfolioValueChart.data.datasets[0].data = chartData;
                    portfolioValueChart.update();
                    console.log(`📈 Loaded ${chartData.length} historical portfolio value points`);
                }
                
            } catch (error) {
                console.error('❌ Error loading portfolio value history:', error);
            }
        }
        
        // Log CSV file usage for tracking
        async function logCSVUsage(csvFilename) {
            try {
                const now = new Date();
                const timestamp = now.toISOString();
                const date = now.toISOString().split('T')[0];
                const timeUTC = now.toISOString().substr(11, 8);
                const timeParis = now.toLocaleString('en-GB', {
                    timeZone: 'Europe/Paris',
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                
                const logEntry = {
                    timestamp,
                    date,
                    time_utc: timeUTC,
                    time_paris: timeParis,
                    csv_filename: csvFilename,
                    action: 'csv_loaded',
                    portfolio_value: initialCapital + cumulativePnL,
                    daily_pnl: 0,
                    daily_pnl_percent: 0,
                    cumulative_pnl: cumulativePnL,
                    total_positions: portfolioData ? portfolioData.length : 0,
                    long_positions: portfolioData ? portfolioData.filter(p => parseFloat(p.target_contracts) > 0).length : 0,
                    short_positions: portfolioData ? portfolioData.filter(p => parseFloat(p.target_contracts) < 0).length : 0,
                    long_notional: 0,
                    short_notional: 0,
                    total_long_notional: 0,
                    total_short_notional: 0,
                    total_gross_notional: 0,
                    gross_exposure: 0,
                    net_exposure: 0,
                    top_long_symbol: '',
                    top_long_weight: 0,
                    top_short_symbol: '',
                    top_short_weight: 0,
                    hit_rate_estimate: 0,
                    avg_win: 0,
                    avg_loss: 0,
                    reliability_ratio: 0
                };
                
                // Send to server for logging
                await fetch('/api/log-csv-usage', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(logEntry)
                });
                
                console.log(`📝 Logged CSV usage: ${csvFilename} at ${timeParis}`);
            } catch (error) {
                console.error('❌ Error logging CSV usage:', error);
            }
        }

        // Load cumulative P&L from daily log
        async function loadCumulativePnL() {
            try {
                // Check if we have a real portfolio log file (not the sample)
                const response = await fetch('portfolio_daily_log.csv');
                if (!response.ok) {
                    console.log('📊 No real portfolio log file found, starting fresh with $0 cumulative P&L');
                    cumulativePnL = 0;
                    return;
                }
                
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');
                const headers = lines[0].split(',');
                
                // Find the last post_execution entry to get cumulative P&L
                let lastPostExecution = null;
                for (let i = lines.length - 1; i >= 1; i--) {
                    const row = lines[i].split(',');
                    if (row.length >= headers.length) {
                        const action = row[5]; // action column
                        if (action === 'post_execution') {
                            lastPostExecution = row;
                            break;
                        }
                    }
                }
                
                if (lastPostExecution) {
                    const portfolioValue = parseFloat(lastPostExecution[6]); // portfolio_value column
                    cumulativePnL = portfolioValue - initialCapital;
                    console.log(`📊 Loaded cumulative P&L from real log: $${formatCurrency(cumulativePnL)}`);
                } else {
                    console.log('📊 No post_execution entries found in real log, starting fresh');
                    cumulativePnL = 0;
                }
            } catch (error) {
                console.error('❌ Error loading cumulative P&L:', error);
                console.log('📊 Starting fresh with $0 cumulative P&L');
                cumulativePnL = 0;
            }
        }

        // Initialize CSV monitoring
        function initializeCSVMonitoring() {
            csvMonitor = new CSVMonitor();
            portfolioLogger = new PortfolioLogger();
            
            // Set up rebalancing callback
            csvMonitor.setOnRebalance(async (newPortfolioData, csvFilename) => {
                console.log('🔄 Rebalancing portfolio with new data...');
                
                // Log pre-execution data (current state before change)
                if (portfolioLogger && portfolioData.length > 0) {
                    // Set the pre-execution portfolio value for logging
                    preExecutionPortfolioValue = initialCapital + cumulativePnL;
                    await portfolioLogger.logPreExecution(csvFilename);
                }
                
                // Update portfolio data
                portfolioData = newPortfolioData;
                
                // Update display
                populatePortfolioTable();
                updateSummary();
                
                // Log post-execution data (new state after change)
                if (portfolioLogger) {
                    await portfolioLogger.logPostExecution(csvFilename);
                    // Update pre-execution value for next day (current portfolio value becomes tomorrow's starting point)
                    preExecutionPortfolioValue = initialCapital + cumulativePnL;
                }
                
                // Update cumulative P&L after rebalancing
                await loadCumulativePnL();
                
                // Log CSV usage for tracking
                await logCSVUsage(csvFilename);
                
                // Update monitoring status
                updateMonitoringStatus('active', `Rebalanced with ${csvFilename}`);
                
                // Fetch new prices
                await fetchBinancePrices();
            });
            
            // Start monitoring
            csvMonitor.startMonitoring();
            updateMonitoringStatus('active', 'Monitoring active');
        }
        
        // Update monitoring status display
        function updateMonitoringStatus(status, message) {
            const statusElement = document.getElementById('monitoring-status');
            statusElement.className = `monitoring-status ${status}`;
            
            const icons = {
                active: '✅',
                inactive: '❌',
                monitoring: '🔄'
            };
            
            statusElement.innerHTML = `${icons[status] || icons.monitoring} ${message}`;
        }
        
        // Load CSV data
        async function loadPortfolioData() {
            try {
                console.log('Loading portfolio data...');
                
                // Load cumulative P&L first
                await loadCumulativePnL();
                
                // Load portfolio value history for chart
                await loadPortfolioValueHistory();
                
                // Discover the latest filename from S3 latest.json
                const latestResp = await fetch('/signal-dashboard/data/latest.json?t=' + Date.now());
                let requiredFilename = 'lpxd_external_advisors_DF_20250915-2355.csv';
                if (latestResp.ok) {
                    const meta = await latestResp.json();
                    if (meta && meta.filename && meta.filename.endsWith('2355.csv')) {
                        requiredFilename = meta.filename;
                    }
                }
                console.log('🔍 Using CSV:', requiredFilename);
                const cacheBuster = `?t=${Date.now()}&v=2355`;
                const response = await fetch('/signal-dashboard/data/' + requiredFilename + cacheBuster);
                if (!response.ok) throw new Error('CSV not found at expected S3 path');
                const csvText = await response.text();
                console.log('CSV loaded, parsing...');
                
                portfolioData = parseCSV(csvText);
                console.log('Loaded portfolio data:', portfolioData.length, 'positions');
                
                if (portfolioData.length === 0) {
                    throw new Error('No data found in CSV');
                }
                
                // Update CSV status bar instead of popup
                // ALWAYS show 2355.csv status
                updateCSVStatus(requiredFilename);
                
                // Log CSV usage for tracking
                await logCSVUsage(requiredFilename);
                
                populatePortfolioTable();
                updateSummary();
                startLiveUpdates();
                
                // Log initial load as post-execution
                if (portfolioLogger) {
                    setTimeout(async () => {
                        await portfolioLogger.logPostExecution(csvFilename);
                        // Set initial pre-execution value for next day
                        preExecutionPortfolioValue = initialCapital + cumulativePnL;
                    }, 3000); // Wait for prices to load
                }
                
                // Validate calculations after a short delay to ensure prices are loaded
                setTimeout(validatePnLCalculations, 2000);
                
            } catch (error) {
                console.error('Error loading CSV:', error);
                // Show error message
                document.getElementById('portfolio-tbody').innerHTML = 
                    '<tr><td colspan="8" class="loading">Error loading data: ' + error.message + '</td></tr>';
            }
        }
        
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',');
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                const row = {};
                headers.forEach((header, index) => {
                    row[header.trim()] = values[index] ? values[index].trim() : '';
                });
                data.push(row);
            }
            
            return data;
        }
        
        // CORRECT P&L CALCULATION FUNCTION (identity-based)
        function calculatePnL(side, notionalEntry, entryPrice, currentPrice) {
            // P&L % is always computed vs Entry; sign handled by side
            const rawPct = ((currentPrice - entryPrice) / entryPrice); // positive if current > entry
            const pnlPercent = (side === 'LONG' ? rawPct : -rawPct) * 100;
            
            // Enforce identity: PnL$ = |notional_at_entry| × PnL% (decimal)
            const notionalAbs = Math.abs(notionalEntry);
            const pnlDollar = notionalAbs * (pnlPercent / 100);
            
            return {
                qty: notionalAbs / entryPrice, // informational only
                pnlDollar,
                pnlPercent
            };
        }

        // Helper functions for number formatting
        function formatCurrency(value, decimals = 2) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: decimals,
                maximumFractionDigits: decimals
            }).format(value);
        }
        
        function formatNumber(value, decimals = 2) {
            return new Intl.NumberFormat('en-US', {
                minimumFractionDigits: decimals,
                maximumFractionDigits: decimals
            }).format(value);
        }
        
        function formatPercentage(value) {
            return new Intl.NumberFormat('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(value) + '%';
        }

        function populatePortfolioTable() {
            const longTbody = document.getElementById('long-portfolio-tbody');
            const shortTbody = document.getElementById('short-portfolio-tbody');
            
            longTbody.innerHTML = '';
            shortTbody.innerHTML = '';
            
            if (!portfolioData || portfolioData.length === 0) {
                longTbody.innerHTML = '<tr><td colspan="8">No data available</td></tr>';
                shortTbody.innerHTML = '<tr><td colspan="8">No data available</td></tr>';
                return;
            }
            
            // Separate LONG and SHORT positions
            const longPositions = [];
            const shortPositions = [];
            let longTotalNotional = 0;
            let shortTotalNotional = 0;
            
            portfolioData.forEach(position => {
                const side = parseFloat(position.target_contracts) > 0 ? 'LONG' : 'SHORT';
                const notional = parseFloat(position.target_notional);
                
                if (side === 'LONG') {
                    longPositions.push(position);
                    longTotalNotional += notional;
                } else {
                    shortPositions.push(position);
                    shortTotalNotional += Math.abs(notional); // Use absolute value for short total
                }
            });
            
            // Sort each group by absolute weight (highest to lowest)
            longPositions.sort((a, b) => Math.abs(parseFloat(b.target_notional)) - Math.abs(parseFloat(a.target_notional)));
            shortPositions.sort((a, b) => Math.abs(parseFloat(b.target_notional)) - Math.abs(parseFloat(a.target_notional)));
            
            // Populate LONG positions table
            longPositions.forEach(position => {
                const row = document.createElement('tr');
                const symbol = position.ticker || position.ric || position.internal_code || 'N/A';
                const side = 'LONG';
                const weight = (parseFloat(position.target_notional) / 1000000) * 100;
                const notional = parseFloat(position.target_notional);
                const entryPrice = parseFloat(position.ref_price);
                const binanceSymbol = symbol.replace('_', '');
                const currentPrice = currentPrices[binanceSymbol];
                
                // Show loading state if no current price available yet
                const currentPriceDisplay = currentPrice ? formatCurrency(currentPrice, entryPrice < 1 ? 6 : 2) : 'Loading...';
                
                // CORRECT P&L CALCULATION using the proper function
                const pnlData = currentPrice ? calculatePnL('LONG', notional, entryPrice, currentPrice) : null;
                const pnlDollar = pnlData ? pnlData.pnlDollar : null;
                const pnlPercent = pnlData ? pnlData.pnlPercent : null;
                
                row.innerHTML = `
                    <td>${symbol}</td>
                    <td class="side-long">${side}</td>
                    <td>${formatPercentage(weight)}</td>
                    <td>${formatCurrency(notional)}</td>
                    <td>${formatCurrency(entryPrice, entryPrice < 1 ? 6 : 2)}</td>
                    <td>${currentPriceDisplay}</td>
                    <td class="${pnlDollar !== null ? (pnlDollar >= 0 ? 'pnl-positive' : 'pnl-negative') : ''}">${pnlDollar !== null ? formatCurrency(pnlDollar) : 'Loading...'}</td>
                    <td class="${pnlPercent !== null ? (pnlPercent >= 0 ? 'pnl-positive' : 'pnl-negative') : ''}">${pnlPercent !== null ? formatPercentage(pnlPercent) : 'Loading...'}</td>
                `;
                
                longTbody.appendChild(row);
            });
            
            // Populate SHORT positions table
            shortPositions.forEach(position => {
                const row = document.createElement('tr');
                const symbol = position.ticker || position.ric || position.internal_code || 'N/A';
                const side = 'SHORT';
                const weight = (parseFloat(position.target_notional) / 1000000) * 100;
                const notional = parseFloat(position.target_notional);
                const entryPrice = parseFloat(position.ref_price);
                const binanceSymbol = symbol.replace('_', '');
                const currentPrice = currentPrices[binanceSymbol];
                
                // Show loading state if no current price available yet
                const currentPriceDisplay = currentPrice ? formatCurrency(currentPrice, entryPrice < 1 ? 6 : 2) : 'Loading...';
                
                // CORRECT P&L CALCULATION using the proper function
                const pnlData = currentPrice ? calculatePnL('SHORT', notional, entryPrice, currentPrice) : null;
                const pnlDollar = pnlData ? pnlData.pnlDollar : null;
                const pnlPercent = pnlData ? pnlData.pnlPercent : null;
                
                row.innerHTML = `
                    <td>${symbol}</td>
                    <td class="side-short">${side}</td>
                    <td>${formatPercentage(weight)}</td>
                    <td>${formatCurrency(notional)}</td>
                    <td>${formatCurrency(entryPrice, entryPrice < 1 ? 6 : 2)}</td>
                    <td>${currentPriceDisplay}</td>
                    <td class="${pnlDollar !== null ? (pnlDollar >= 0 ? 'pnl-positive' : 'pnl-negative') : ''}">${pnlDollar !== null ? formatCurrency(pnlDollar) : 'Loading...'}</td>
                    <td class="${pnlPercent !== null ? (pnlPercent >= 0 ? 'pnl-positive' : 'pnl-negative') : ''}">${pnlPercent !== null ? formatPercentage(pnlPercent) : 'Loading...'}</td>
                `;
                
                shortTbody.appendChild(row);
            });
            
            // Calculate net P&L for each group
            let longNetPnL = 0;
            let shortNetPnL = 0;
            
            longPositions.forEach(position => {
                const symbol = position.ticker || position.ric || position.internal_code || 'N/A';
                const notional = parseFloat(position.target_notional);
                const entryPrice = parseFloat(position.ref_price);
                const binanceSymbol = symbol.replace('_', '');
                const currentPrice = currentPrices[binanceSymbol];
                
                if (currentPrice) {
                    const pnlData = calculatePnL('LONG', notional, entryPrice, currentPrice);
                    longNetPnL += pnlData.pnlDollar;
                }
            });
            
            shortPositions.forEach(position => {
                const symbol = position.ticker || position.ric || position.internal_code || 'N/A';
                const notional = parseFloat(position.target_notional);
                const entryPrice = parseFloat(position.ref_price);
                const binanceSymbol = symbol.replace('_', '');
                const currentPrice = currentPrices[binanceSymbol];
                
                if (currentPrice) {
                    const pnlData = calculatePnL('SHORT', notional, entryPrice, currentPrice);
                    shortNetPnL += pnlData.pnlDollar;
                }
            });
            
            // Add net P&L summary rows
            if (longPositions.length > 0) {
                const longNetRow = document.createElement('tr');
                longNetRow.className = 'net-pnl-row';
                longNetRow.innerHTML = `
                    <td colspan="6"><strong>Net P&L (Long Positions)</strong></td>
                    <td class="${longNetPnL >= 0 ? 'pnl-positive' : 'pnl-negative'}"><strong>${formatCurrency(longNetPnL)}</strong></td>
                    <td class="${longNetPnL >= 0 ? 'pnl-positive' : 'pnl-negative'}"><strong>${formatPercentage((longNetPnL / longTotalNotional) * 100)}</strong></td>
                `;
                longTbody.appendChild(longNetRow);
            }
            
            if (shortPositions.length > 0) {
                const shortNetRow = document.createElement('tr');
                shortNetRow.className = 'net-pnl-row';
                shortNetRow.innerHTML = `
                    <td colspan="6"><strong>Net P&L (Short Positions)</strong></td>
                    <td class="${shortNetPnL >= 0 ? 'pnl-positive' : 'pnl-negative'}"><strong>${formatCurrency(shortNetPnL)}</strong></td>
                    <td class="${shortNetPnL >= 0 ? 'pnl-positive' : 'pnl-negative'}"><strong>${formatPercentage((shortNetPnL / shortTotalNotional) * 100)}</strong></td>
                `;
                shortTbody.appendChild(shortNetRow);
            }
            
            // Update total notional amounts
            document.getElementById('long-total-notional').textContent = formatCurrency(longTotalNotional);
            document.getElementById('short-total-notional').textContent = formatCurrency(shortTotalNotional);
        }
        
        function updateSummary() {
            if (!portfolioData || portfolioData.length === 0) return;
            
            let dailyPnL = 0; // Daily P&L (starts fresh each CSV execution)
            let totalLongNotional = 0;
            let totalShortNotional = 0;
            
            let hasAllPrices = true;
            
            portfolioData.forEach(position => {
                const symbol = position.ticker || position.ric || position.internal_code;
                const entryPrice = parseFloat(position.ref_price);
                const notional = parseFloat(position.target_notional);
                const binanceSymbol = symbol.replace('_', '');
                const currentPrice = currentPrices[binanceSymbol];
                
                // Calculate total notional amounts
                const side = parseFloat(position.target_contracts) > 0 ? 'LONG' : 'SHORT';
                if (side === 'LONG') {
                    totalLongNotional += Math.abs(notional);
                } else {
                    totalShortNotional += Math.abs(notional);
                }
                
                if (!currentPrice) {
                    hasAllPrices = false;
                    return;
                }
                
                // CORRECT P&L CALCULATION using the proper function
                const pnlData = calculatePnL(side, notional, entryPrice, currentPrice);
                dailyPnL += pnlData.pnlDollar;
            });
            
            // Calculate portfolio values
            const totalPortfolioValue = initialCapital + cumulativePnL + dailyPnL;
            const dailyPnLPercent = (dailyPnL / initialCapital) * 100;
            const totalPnLPercent = ((cumulativePnL + dailyPnL) / initialCapital) * 100;
            
            // Update display
            if (hasAllPrices) {
                // Portfolio Value = Initial Capital + Total P&L Since Inception
                document.getElementById('portfolio-value').textContent = formatCurrency(totalPortfolioValue);
                
                // Daily P&L (just for today)
                document.getElementById('daily-pnl').textContent = formatCurrency(dailyPnL);
                document.getElementById('daily-pnl').className = `value ${dailyPnL >= 0 ? 'positive' : 'negative'}`;
                document.getElementById('daily-pnl-percent').textContent = `(${formatPercentage(dailyPnLPercent)})`;
                document.getElementById('daily-pnl-percent').className = `percentage ${dailyPnL >= 0 ? 'positive' : 'negative'}`;
                
                // Total P&L Since Inception (cumulative)
                document.getElementById('cumulative-pnl').textContent = formatCurrency(cumulativePnL + dailyPnL);
                document.getElementById('cumulative-pnl').className = `value ${(cumulativePnL + dailyPnL) >= 0 ? 'positive' : 'negative'}`;
                document.getElementById('total-pnl-percent').textContent = `(${formatPercentage(totalPnLPercent)})`;
                document.getElementById('total-pnl-percent').className = `percentage ${(cumulativePnL + dailyPnL) >= 0 ? 'positive' : 'negative'}`;
                
                // Total Notional at Entry
                document.getElementById('total-notional-at-entry').textContent = formatCurrency(totalLongNotional + totalShortNotional);
            } else {
                // Show loading state for P&L calculations
                const currentPortfolioValue = initialCapital + cumulativePnL;
                document.getElementById('portfolio-value').textContent = formatCurrency(currentPortfolioValue);
                document.getElementById('daily-pnl').textContent = 'Loading...';
                document.getElementById('daily-pnl').className = 'value';
                document.getElementById('daily-pnl-percent').textContent = '(Loading...)';
                document.getElementById('daily-pnl-percent').className = 'percentage';
                document.getElementById('cumulative-pnl').textContent = formatCurrency(cumulativePnL);
                document.getElementById('cumulative-pnl').className = `value ${cumulativePnL >= 0 ? 'positive' : 'negative'}`;
                document.getElementById('total-pnl-percent').textContent = `(${formatPercentage((cumulativePnL / initialCapital) * 100)})`;
                document.getElementById('total-pnl-percent').className = `percentage ${cumulativePnL >= 0 ? 'positive' : 'negative'}`;
                document.getElementById('total-notional-at-entry').textContent = formatCurrency(totalLongNotional + totalShortNotional);
            }
            
            // Always show position count
            document.getElementById('position-count').textContent = formatNumber(portfolioData.length, 0);
        }
        
        async function fetchBinancePrices() {
            try {
                const symbols = portfolioData.map(p => (p.ticker || p.ric || p.internal_code).replace('_', ''));
                console.log('Fetching prices for symbols:', symbols);
                
                // Fetch prices one by one to avoid API issues
                for (const symbol of symbols) {
                    try {
                        const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`);
                        if (response.ok) {
                            const priceData = await response.json();
                            currentPrices[symbol] = parseFloat(priceData.price);
                            console.log(`Updated ${symbol}: $${priceData.price}`);
                        }
                    } catch (symbolError) {
                        console.warn(`Failed to fetch price for ${symbol}:`, symbolError);
                    }
                }
                
                console.log('All updated prices:', currentPrices);
                
            } catch (error) {
                console.error('Error fetching Binance prices:', error);
            }
        }
        
        function startLiveUpdates() {
            // Fetch real prices every 2 minutes
            fetchBinancePrices();
            setInterval(fetchBinancePrices, 120000);
            
            // Simulate price movements for immediate feedback
            simulatePriceMovements();
            
            // Update display every 5 seconds
            setInterval(() => {
                populatePortfolioTable();
                updateSummary();
            }, 5000);
        }
        
        function simulatePriceMovements() {
            // Add some price variation to show P&L working
            setInterval(() => {
                if (portfolioData.length > 0) {
                    portfolioData.forEach(position => {
                        const symbol = position.ticker || position.ric || position.internal_code;
                        const entryPrice = parseFloat(position.ref_price);
                        
                        // If we don't have a current price, start with entry price
                        if (!currentPrices[symbol]) {
                            currentPrices[symbol] = entryPrice;
                        }
                        
                        // Add small random price movements (-2% to +2%)
                        const variation = (Math.random() - 0.5) * 0.04; // ±2%
                        currentPrices[symbol] = entryPrice * (1 + variation);
                    });
                    
                    console.log('Simulated price movements applied');
                }
            }, 10000); // Update every 10 seconds
        }
        
        // Notification system
        function showNotification(type, title, message) {
            const notificationsDiv = document.getElementById('notifications');
            if (!notificationsDiv) {
                // Create notifications container if it doesn't exist
                const container = document.createElement('div');
                container.id = 'notifications';
                container.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 1000;';
                document.body.appendChild(container);
            }
            
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = `
                <div class="notification-content">
                    <span class="notification-icon">${getNotificationIcon(type)}</span>
                    <div class="notification-text">
                        <div class="notification-title">${title}</div>
                        <div class="notification-message">${message}</div>
                    </div>
                    <button class="notification-close" onclick="this.parentElement.parentElement.remove()">×</button>
                </div>
            `;
            
            document.getElementById('notifications').appendChild(notification);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 5000);
        }
        
        function getNotificationIcon(type) {
            const icons = {
                info: 'ℹ️',
                success: '✅',
                error: '❌',
                warning: '⚠️'
            };
            return icons[type] || icons.info;
        }
        
        // Validation function to check P&L calculations with sanity checks
        function validatePnLCalculations() {
            if (!portfolioData || !currentPrices) return;
            
            console.log('🔍 Validating P&L calculations...');
            let errors = 0;
            
            portfolioData.forEach(position => {
                const symbol = position.ticker || position.ric || position.internal_code;
                const notional = parseFloat(position.target_notional);
                const entryPrice = parseFloat(position.ref_price);
                const binanceSymbol = symbol.replace('_', '');
                const currentPrice = currentPrices[binanceSymbol];
                
                if (!currentPrice) return;
                
                const side = parseFloat(position.target_contracts) > 0 ? 'LONG' : 'SHORT';
                const pnlData = calculatePnL(side, notional, entryPrice, currentPrice);
                
                // SANITY CHECKS
                
                // 1. If Current = Entry, then P&L must be 0
                if (Math.abs(currentPrice - entryPrice) < 0.000001) {
                    if (Math.abs(pnlData.pnlDollar) > 0.01) {
                        console.error(`❌ ${symbol}: Current = Entry but P&L ≠ 0: $${pnlData.pnlDollar.toFixed(2)}`);
                        errors++;
                    }
                }
                
                // 2. For shorts, if Current > Entry, P&L must be negative
                if (side === 'SHORT' && currentPrice > entryPrice) {
                    if (pnlData.pnlDollar >= 0) {
                        console.error(`❌ ${symbol}: Short with Current > Entry but P&L ≥ 0: $${pnlData.pnlDollar.toFixed(2)}`);
                        errors++;
                    }
                }
                
                // 3. For longs, if Current > Entry, P&L must be positive
                if (side === 'LONG' && currentPrice > entryPrice) {
                    if (pnlData.pnlDollar <= 0) {
                        console.error(`❌ ${symbol}: Long with Current > Entry but P&L ≤ 0: $${pnlData.pnlDollar.toFixed(2)}`);
                        errors++;
                    }
                }
                
                // 4. Back-of-envelope check: P&L ≈ Notional × (Current - Entry)/Entry
                const expectedPnL = notional * (currentPrice - entryPrice) / entryPrice;
                const pnlError = Math.abs(pnlData.pnlDollar - expectedPnL) / Math.abs(expectedPnL);
                
                if (pnlError > 0.01) { // 1% tolerance
                    console.warn(`⚠️ ${symbol}: P&L mismatch - calculated: $${pnlData.pnlDollar.toFixed(2)}, expected: $${expectedPnL.toFixed(2)}, error: ${(pnlError * 100).toFixed(2)}%`);
                    errors++;
                }
            });
            
            if (errors === 0) {
                console.log('✅ All P&L calculations validated successfully');
            } else {
                console.warn(`❌ Found ${errors} calculation errors`);
            }
        }

        // Update CSV status bar
        function updateCSVStatus(filename) {
            const filenameElement = document.getElementById('current-csv-filename');
            
            if (filenameElement) {
                // Store the filename for the toggle function
                filenameElement.dataset.filename = filename;
                // Keep the display as "Click to show file" initially
                filenameElement.querySelector('.filename-display').textContent = 'Click to show file';
            }
        }
        
        // Toggle CSV details when clicked
        function toggleCSVDetails() {
            const filenameElement = document.getElementById('current-csv-filename');
            const filename = filenameElement.dataset.filename;
            const displayElement = filenameElement.querySelector('.filename-display');
            
            if (!filename || filename === 'Loading...') {
                showNotification('info', 'No CSV Data', 'No CSV file is currently loaded');
                return;
            }
            
            // Toggle between showing filename and "Click to show file"
            if (displayElement.textContent === 'Click to show file') {
                displayElement.textContent = filename;
                filenameElement.title = 'Click to hide file details';
            } else {
                displayElement.textContent = 'Click to show file';
                filenameElement.title = 'Click to show file details';
            }
        }

        // Clock functions
        function updateClock() {
            const now = new Date();
            const utcTime = now.toISOString().substr(11, 8);
            const parisTime = now.toLocaleString('en-GB', { 
                timeZone: 'Europe/Paris',
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            
            document.getElementById('clock').textContent = `${utcTime} / ${parisTime}`;
        }
        
        function startClock() {
            updateClock(); // Initial update
            setInterval(updateClock, 1000); // Update every second
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializePortfolioValueChart();
            loadPortfolioData();
            initializeCSVMonitoring();
            startClock();
        });
    </script>
</body>
</html>
