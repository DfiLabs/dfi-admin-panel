<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Strategy Monitor - CACHE BUSTED v4.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            color: #2c3e50;
            line-height: 1.6;
            min-height: 100vh;
        }
        
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .primary-metric {
            border-left: 4px solid #007bff;
            background: #f8f9fa;
        }
        
        .secondary-metric {
            border-left: 4px solid #6c757d;
            background: #ffffff;
        }
        
        .card {
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #e9ecef;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .card:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            transform: translateY(-1px);
        }
        
        .card h3 {
            color: #6c757d;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        
        .card .value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #2c3e50;
            letter-spacing: -0.01em;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .card .percentage {
            font-size: 0.9rem;
            font-weight: 500;
            color: #6c757d;
            margin-top: 0.25rem;
            opacity: 0.8;
        }
        
        .card .percentage.positive {
            color: #28a745;
        }
        
        .card .percentage.negative {
            color: #dc3545;
        }
        
        .card .value.positive {
            color: #28a745;
        }
        
        .card .value.negative {
            color: #dc3545;
        }
        
        .portfolio-table {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
        }
        
        .portfolio-table table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .portfolio-table th {
            background: #f8f9fa;
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
        }
        
        .portfolio-table td {
            padding: 1rem;
            border-bottom: 1px solid #e9ecef;
            color: #2c3e50;
        }
        
        .portfolio-table tr:hover {
            background: rgba(102, 126, 234, 0.05);
        }
        
        .side-long {
            color: #28a745;
            font-weight: 600;
        }
        
        .side-short {
            color: #dc3545;
            font-weight: 600;
        }
        
        .positive {
            color: #28a745;
        }
        
        .negative {
            color: #dc3545;
        }
        
        .pnl-positive {
            color: #388e3c;
            font-weight: 600;
            background-color: rgba(76, 175, 80, 0.08);
            padding: 2px 4px;
            border-radius: 3px;
            border-left: 2px solid #66bb6a;
        }
        
        .pnl-negative {
            color: #d32f2f;
            font-weight: 600;
            background-color: rgba(244, 67, 54, 0.08);
            padding: 2px 4px;
            border-radius: 3px;
            border-left: 2px solid #ef5350;
        }
        
        .net-pnl-row {
            background-color: #f8f9fa;
            border-top: 2px solid #e9ecef;
            font-weight: 600;
        }
        
        .net-pnl-row td {
            padding: 0.75rem 1rem;
        }
        
        .net-pnl-row .pnl-positive {
            color: #2e7d32;
            font-weight: 700;
            background-color: rgba(76, 175, 80, 0.12);
            padding: 3px 6px;
            border-radius: 4px;
            border-left: 3px solid #66bb6a;
        }
        
        .net-pnl-row .pnl-negative {
            color: #c62828;
            font-weight: 700;
            background-color: rgba(244, 67, 54, 0.12);
            padding: 3px 6px;
            border-radius: 4px;
            border-left: 3px solid #ef5350;
        }
        
        .loading {
            text-align: center;
            padding: 2rem;
            color: #6c757d;
        }
        
        /* Notification Styles */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            min-width: 300px;
            max-width: 500px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-left: 4px solid #667eea;
            animation: slideIn 0.3s ease-out;
        }
        
        .notification-success {
            border-left-color: #28a745;
        }
        
        .notification-error {
            border-left-color: #dc3545;
        }
        
        .notification-warning {
            border-left-color: #ffc107;
        }
        
        .notification-content {
            padding: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .notification-icon {
            font-size: 1.2rem;
        }
        
        .notification-message {
            flex: 1;
            color: #2c3e50;
            font-size: 0.9rem;
        }
        
        .notification-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #6c757d;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .notification-close:hover {
            color: #2c3e50;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        /* Monitoring Status */
        .monitoring-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            z-index: 1000;
        }
        
        .monitoring-status.active {
            background: rgba(40, 167, 69, 0.9);
        }
        
        .monitoring-status.inactive {
            background: rgba(220, 53, 69, 0.9);
        }
        
        /* Graph Card Styles */
        .graph-card {
            margin-bottom: 2rem;
        }
        
        .graph-container {
            position: relative;
            height: 300px;
            margin: 1rem 0;
        }
        
        .range-switcher {
            display: flex;
            gap: 4px;
        }
        
        .range-btn {
            padding: 6px 12px;
            border: 1px solid #e0e0e0;
            background: white;
            color: #666;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .range-btn:hover {
            background: #f5f5f5;
            border-color: #ccc;
        }
        
        .range-btn.active {
            background: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        .sparkline-container {
            margin-left: 10px;
        }
        
        #portfolioSparkline {
            border-radius: 4px;
            background: #f8f9fa;
        }
        
        .graph-info {
            text-align: center;
            margin-top: 0.5rem;
        }
        
        .graph-label {
            font-size: 0.85rem;
            color: #6c757d;
            font-style: italic;
        }
        
        /* Navigation Bar */
        .nav-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1.5rem;
            border-bottom: 2px solid #e9ecef;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .nav-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        
        .clock-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }
        
        .clock {
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            font-weight: 600;
            color: #667eea;
            background: #f8f9fa;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            min-width: 200px;
            text-align: center;
        }
        
        .timezone-info {
            font-size: 0.75rem;
            color: #6c757d;
            font-weight: 500;
        }
        
        /* CSV Status Bar */
        .csv-status-bar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 0.25rem 0;
            font-size: 0.8rem;
        }
        
        .csv-status-label {
            color: #6c757d;
            font-weight: 500;
        }
        
        .csv-filename {
            color: #667eea;
            font-weight: 600;
            cursor: pointer;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
        }
        
        .csv-filename:hover {
            background: #f0f4ff;
            color: #4c63d2;
        }
        
        .filename-display {
            font-family: 'Courier New', monospace;
        }
        
        .click-hint {
            font-size: 0.7rem;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .csv-filename:hover .click-hint {
            opacity: 1;
        }
        
        /* Notification Styles */
        .notification {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-left: 4px solid #667eea;
            margin-bottom: 10px;
            min-width: 300px;
            max-width: 400px;
            animation: slideIn 0.3s ease-out;
        }
        
        .notification-success {
            border-left-color: #28a745;
        }
        
        .notification-error {
            border-left-color: #dc3545;
        }
        
        .notification-warning {
            border-left-color: #ffc107;
        }
        
        .notification-content {
            padding: 1rem;
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
        }
        
        .notification-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }
        
        .notification-text {
            flex: 1;
        }
        
        .notification-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        
        .notification-message {
            color: #6c757d;
            font-size: 0.85rem;
            line-height: 1.4;
        }
        
        .notification-close {
            background: none;
            border: none;
            font-size: 1.2rem;
            color: #6c757d;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .notification-close:hover {
            color: #2c3e50;
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .nav-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }
        
        .nav-button:hover {
            background: #5a6fd8;
        }
        
        .dashboard-title {
            color: #2c3e50;
            font-size: 1.5rem;
            margin: 0;
        }
        
        .dashboard-subtitle {
            font-size: 0.9rem;
            color: #6c757d;
            margin: 0.25rem 0 0 0;
            font-weight: 400;
        }
        
        /* Portfolio Sections */
        .portfolio-section {
            margin-bottom: 2rem;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .section-title {
            color: #2c3e50;
            font-size: 1.2rem;
            font-weight: 600;
            margin: 0;
        }
        
        .section-summary {
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        .summary-value {
            color: #2c3e50;
            font-weight: 600;
            font-size: 1rem;
        }
    </style>
</head>
<body>
    
    <div class="container">
        <!-- Navigation -->
        <div class="nav-bar">
            <button class="nav-button" onclick="window.location.href='index.html'">← Back to Homepage</button>
            <div class="nav-center">
                <h1 class="dashboard-title">Strategy Monitor</h1>
                <p class="dashboard-subtitle">In-house simple strategy tracking & monitoring</p>
                <div class="csv-status-bar">
                    <span class="csv-status-label">Data:</span>
                    <span id="current-csv-filename" class="csv-filename" onclick="toggleCSVDetails()" title="Click to show file details">
                        <span class="filename-display">Click to show file</span>
                        <span class="click-hint">ℹ️</span>
                    </span>
                </div>
                <div class="clock-container">
                    <div class="clock" id="clock">Loading...</div>
                    <div class="timezone-info">UTC / Paris</div>
                </div>
            </div>
        </div>
        
        <script>
            // Debug mode detection
            const DEBUG_MODE = new URLSearchParams(window.location.search).get('debug') === '1';
            
            // Debug logging function
            function debugLog(category, data) {
                if (DEBUG_MODE) {
                    console.log(`[DEBUG:${category}]`, JSON.stringify(data, null, 2));
                }
            }
            
            (function initialClock() {
                try {
                    var el = document.getElementById('clock');
                    if (el) {
                        var now = new Date();
                        var utc = now.toISOString().substr(11, 8);
                        var paris = now.toLocaleString('en-GB', {
                            timeZone: 'Europe/Paris',
                            hour12: false,
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                        el.textContent = utc + ' / ' + paris;
                    }
                } catch (e) {
                    // no-op
                }
            })();
        </script>

        <div class="summary-cards">
            <!-- Primary Performance Metrics -->
            <div class="card primary-metric">
                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <div>
                <h3>Portfolio Value</h3>
                        <div class="value" id="portfolio-value">Loading...</div>
                        <div class="timestamp" id="portfolio-timestamp" style="font-size: 12px; color: #666; margin-top: 4px;"></div>
                    </div>
                    <div class="sparkline-container">
                        <canvas id="portfolioSparkline" width="120" height="40"></canvas>
                    </div>
                </div>
            </div>
            <div class="card primary-metric">
                <h3>Daily P&L</h3>
                <div class="value" id="daily-pnl">Loading...</div>
                <div class="percentage" id="daily-pnl-percent"></div>
            </div>
            <div class="card primary-metric">
                <h3>Total P&L Since Inception</h3>
                <div class="value" id="cumulative-pnl">Loading...</div>
                <div class="percentage" id="total-pnl-percent"></div>
            </div>
            <div class="card secondary-metric">
                <h3>Total Notional at Entry</h3>
                <div class="value" id="total-notional-at-entry">Loading...</div>
            </div>
            <div class="card secondary-metric">
                <h3>Positions</h3>
                <div class="value" id="position-count">Loading...</div>
            </div>
        </div>
        
        <!-- Portfolio Value Evolution Graph -->
        <div class="card graph-card">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3>Portfolio Value Evolution</h3>
                <div class="range-switcher">
                    <button class="range-btn active" data-range="1D">1D</button>
                    <button class="range-btn" data-range="7D">7D</button>
                    <button class="range-btn" data-range="1M">1M</button>
                    <button class="range-btn" data-range="3M">3M</button>
                </div>
            </div>
            <div class="graph-container">
                <canvas id="portfolioValueChart" width="800" height="300"></canvas>
            </div>
            <div class="graph-info">
                <span class="graph-label">Daily portfolio value tracking since inception</span>
            </div>
        </div>
        
        <!-- Long Positions Section -->
        <div class="portfolio-section">
            <div class="section-header">
                <h3 class="section-title">Long Positions</h3>
                <div class="section-summary">
                    Total Notional at Entry: <span id="long-total-notional" class="summary-value">$0.00</span>
                </div>
            </div>
            <div class="portfolio-table-container">
                <table class="portfolio-table">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Side</th>
                            <th>Weight %</th>
                            <th>Notional $</th>
                            <th>Entry Price</th>
                            <th>Current Price</th>
                            <th>P&L $</th>
                            <th>P&L %</th>
                        </tr>
                    </thead>
                    <tbody id="long-portfolio-tbody">
                        <tr>
                            <td colspan="8" class="loading">Loading long positions...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Short Positions Section -->
        <div class="portfolio-section">
            <div class="section-header">
                <h3 class="section-title">Short Positions</h3>
                <div class="section-summary">
                    Total Notional at Entry: <span id="short-total-notional" class="summary-value">$0.00</span>
                </div>
            </div>
            <div class="portfolio-table-container">
                <table class="portfolio-table">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Side</th>
                            <th>Weight %</th>
                            <th>Notional $</th>
                            <th>Entry Price</th>
                            <th>Current Price</th>
                            <th>P&L $</th>
                            <th>P&L %</th>
                        </tr>
                    </thead>
                    <tbody id="short-portfolio-tbody">
                        <tr>
                            <td colspan="8" class="loading">Loading short positions...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- Monitoring Status (hidden from users) -->
    <div class="monitoring-status" id="monitoring-status" style="display: none;">
        🔄 Monitoring CSV files...
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script>
        // JavaScript is working
        console.log('🔥 JavaScript file loaded!');
        console.log('🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨 CACHE BUST TEST - NEW CODE VERSION 4.0 IS RUNNING! 🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨');
        console.log('🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨 TIMESTAMP: ' + new Date().toISOString() + ' 🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨');
        console.log('🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨 P&L MISMATCH FIX ACTIVE! 🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨');
        
        let portfolioData = [];
        let currentPrices = {};
        let csvMonitor = null;
        let portfolioLogger = null;
        let preExecutionPortfolioValue = 1000000; // Value before CSV execution
        let cumulativePnL = 0; // Track cumulative P&L since inception
        let initialCapital = 1000000; // Starting capital
        let baselinePrices = {}; // Daily baseline prices captured at post-execution
        let baselinePortfolioValue = null; // For reference
        
        // UI State Management
        let uiState = 'loading'; // 'loading', 'day1-fallback', 'baseline-mode'
        let lastTick = null; // Latest atomic tick payload
        let mismatchFailureCount = 0; // Track consecutive mismatch failures
        
        // Chart state management
        let currentRange = '1D';
        let portfolioValueChart = null;
        let portfolioSparkline = null;
        let baselineOverlays = [];
        
        // Initialize Portfolio Value Chart with intraday support
        function initializePortfolioValueChart() {
            const ctx = document.getElementById('portfolioValueChart').getContext('2d');
            portfolioValueChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Portfolio Value',
                        data: [],
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1,
                        pointBackgroundColor: '#667eea',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 2,
                        pointHoverRadius: 4,
                        showLine: true,
                        spanGaps: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                },
                                label: function(context) {
                                    return 'Portfolio Value: ' + formatCurrency(context.parsed.y);
                                }
                            }
                        },
                        annotation: {
                            annotations: {}
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'HH:mm',
                                    day: 'MMM d'
                                }
                            },
                            ticks: {
                                callback: function(value, index, ticks) {
                                    const date = new Date(value);
                                    if (currentRange === '1D') {
                                        return date.getUTCHours().toString().padStart(2, '0') + ':' + 
                                               date.getUTCMinutes().toString().padStart(2, '0') + ' UTC';
                                    } else {
                                        return date.toLocaleDateString('en-US', { 
                                            month: 'short', 
                                            day: 'numeric',
                                            timeZone: 'UTC'
                                        }) + ' UTC';
                                    }
                                }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: function(value) {
                                    return formatCurrency(value);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Add new data point to portfolio value chart
        function addPortfolioValueDataPoint(date, portfolioValue) {
            if (portfolioValueChart) {
                portfolioValueChart.data.labels.push(date);
                portfolioValueChart.data.datasets[0].data.push(portfolioValue);
                portfolioValueChart.update('none'); // Update without animation for performance
                console.log(`📈 Added new portfolio value data point: ${date} = $${formatCurrency(portfolioValue)}`);
            }
        }
        
        // Make function available globally for portfolio logger
        window.addPortfolioValueDataPoint = addPortfolioValueDataPoint;
        
        // Atomic tick rendering - single source of truth
        function renderFromTick(tick) {
            if (!tick) {
                console.log('❌ renderFromTick called with null/undefined tick');
                return;
            }
            
            console.log('🎯 renderFromTick called with:', tick);
            lastTick = tick;
            
            // Determine UI state
            if (tick.is_day1_fallback) {
                uiState = 'day1-fallback';
                console.log('📱 UI State changed to: day1-fallback');
            } else {
                uiState = 'baseline-mode';
                console.log('📱 UI State changed to: baseline-mode');
            }
            
            // Format timestamp for display
            const tickTime = new Date(tick.ts_utc);
            const timeStr = tickTime.toISOString().substr(11, 8) + ' UTC';
            
            // CRITICAL: Render all cards from the same tick snapshot
            // This is the ONLY place where cards should be updated to ensure consistency with table
            console.log('🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨 CACHE BUST TEST - NEW CODE VERSION 4.0 IS RUNNING! 🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨');
            
            console.log('💳 Rendering cards with values from tick snapshot:', {
                portfolio_value: tick.portfolio_value,
                daily_pnl: tick.daily_pnl,
                total_pnl: tick.total_pnl
            });
            
            document.getElementById('portfolio-value').textContent = formatCurrency(tick.portfolio_value);
            document.getElementById('portfolio-timestamp').textContent = `as of ${timeStr}`;
            
            document.getElementById('daily-pnl').textContent = formatCurrency(tick.daily_pnl);
            document.getElementById('daily-pnl').className = `value ${tick.daily_pnl >= 0 ? 'positive' : 'negative'}`;
            
            const dailyPercent = (tick.daily_pnl / initialCapital) * 100;
            document.getElementById('daily-pnl-percent').textContent = `(${formatPercentage(dailyPercent)})`;
            document.getElementById('daily-pnl-percent').className = `percentage ${tick.daily_pnl >= 0 ? 'positive' : 'negative'}`;
            
            document.getElementById('cumulative-pnl').textContent = formatCurrency(tick.total_pnl);
            document.getElementById('cumulative-pnl').className = `value ${tick.total_pnl >= 0 ? 'positive' : 'negative'}`;
            
            const totalPercent = (tick.total_pnl / initialCapital) * 100;
            document.getElementById('total-pnl-percent').textContent = `(${formatPercentage(totalPercent)})`;
            document.getElementById('total-pnl-percent').className = `percentage ${tick.total_pnl >= 0 ? 'positive' : 'negative'}`;
            
            document.getElementById('total-notional-at-entry').textContent = formatCurrency(initialCapital);
            
            // State tracking (no UI badges - logged to ops report)
            console.log(`UI State: ${uiState} | CSV: ${tick.csv_filename} | Time: ${timeStr}`);
            
            // Always append new tick to intraday data (regardless of current range)
            appendIntradayTick(tick);
            
            // Populate table from the same tick snapshot (only when all data is ready)
            if (portfolioData && portfolioData.length > 0) {
                console.log('🔄 Populating table from tick snapshot');
                populatePortfolioTableFromTick(tick);
            }
            
            // Now run identity checks (only after everything is rendered)
            runIdentityChecks(tick);
        }
        
        // Identity checks (only run after atomic rendering)
        function runIdentityChecks(tick) {
            if (!tick) return;
            
            // Identity 1: Portfolio Value - 1,000,000 = Total P&L
            const inv1 = Math.abs(tick.portfolio_value - (initialCapital + tick.total_pnl)) < 0.01;
            
            // Identity 2: Total P&L - Daily P&L = Base Cumulative
            const inv2 = Math.abs(tick.total_pnl - tick.daily_pnl - tick.base_cumulative) < 0.01;
            
            if (!inv1 || !inv2) {
                console.error('IDENTITY VIOLATION:', {
                    inv1: `Portfolio Value - 1,000,000 = Total P&L (${tick.portfolio_value - initialCapital} vs ${tick.total_pnl})`,
                    inv2: `Total P&L - Daily P&L = Base Cumulative (${tick.total_pnl - tick.daily_pnl} vs ${tick.base_cumulative})`,
                    tick
                });
            }
            
            // G) Invariants (cards/chart/table) — single line
            debugLog('INVARIANTS', {
                timestamp: tick.ts_utc,
                portfolio_value: tick.portfolio_value,
                total_pnl: tick.total_pnl,
                daily_pnl: tick.daily_pnl,
                base_cumulative: tick.base_cumulative,
                identity1_pass: inv1,
                identity2_pass: inv2,
                identity1_delta_cents: Math.round(Math.abs(tick.portfolio_value - (initialCapital + tick.total_pnl)) * 100),
                identity2_delta_cents: Math.round(Math.abs(tick.total_pnl - tick.daily_pnl - tick.base_cumulative) * 100)
            });
            
            // Chart mismatch check (require 2 consecutive failures)
            if (portfolioValueChart && portfolioValueChart.data.datasets[0].data.length > 0) {
                const lastChartValue = portfolioValueChart.data.datasets[0].data[portfolioValueChart.data.datasets[0].data.length - 1];
                const chartMismatch = Math.abs(lastChartValue - tick.portfolio_value) > 0.01;
                
                if (chartMismatch) {
                    mismatchFailureCount++;
                    console.warn(`Chart mismatch attempt ${mismatchFailureCount}/2: Chart $${lastChartValue.toFixed(2)} vs Card $${tick.portfolio_value.toFixed(2)}`);
                    
                    if (mismatchFailureCount >= 2) {
                        console.error('CHART MISMATCH: 2 consecutive failures detected', {
                            chartValue: lastChartValue,
                            cardValue: tick.portfolio_value,
                            difference: lastChartValue - tick.portfolio_value
                        });
                        // No UI badge - logged to ops report
                    }
                } else {
                    // Reset failure count on success
                    mismatchFailureCount = 0;
                }
            }
        }
        
        // Range switching functionality
        function setupRangeSwitcher() {
            const rangeButtons = document.querySelectorAll('.range-btn');
            rangeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    // Update active button
                    rangeButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    // Update current range and reload data (preserves 1D series)
                    const newRange = btn.dataset.range;
                    console.log(`🔄 Switching range: ${currentRange} → ${newRange}`);
                    currentRange = newRange;
                    loadChartData(currentRange);
                });
            });
        }
        
        // Cache-busting fetch function
        async function fetchWithCacheBust(url) {
            const cacheBuster = `?t=${Date.now()}`;
            const response = await fetch(url + cacheBuster, {
                cache: 'no-store',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                }
            });
            return response;
        }
        
        // Load time series data for a specific date
        async function loadTimeSeriesForDate(dateStr) {
            try {
                const year = dateStr.substring(0, 4);
                const month = dateStr.substring(5, 7);
                const day = dateStr.substring(8, 10);
                const url = `/signal-dashboard/timeseries/portfolio/${year}/${month}/${day}.jsonl`;
                
                const response = await fetchWithCacheBust(url);
                if (!response.ok) {
                    return [];
                }
                
                const text = await response.text();
                const lines = text.trim().split('\n').filter(line => line.trim());
                return lines.map(line => JSON.parse(line));
            } catch (error) {
                console.warn(`Failed to load time series for ${dateStr}:`, error);
                return [];
            }
        }
        
        // Bin data by time intervals
        function binDataByInterval(data, intervalMinutes) {
            if (!data.length) return [];
            
            const bins = new Map();
            const intervalMs = intervalMinutes * 60 * 1000;
            
            data.forEach(point => {
                const timestamp = new Date(point.ts_utc).getTime();
                const binStart = Math.floor(timestamp / intervalMs) * intervalMs;
                
                if (!bins.has(binStart) || new Date(point.ts_utc) > new Date(bins.get(binStart).ts_utc)) {
                    bins.set(binStart, point);
                }
            });
            
            return Array.from(bins.values()).sort((a, b) => new Date(a.ts_utc) - new Date(b.ts_utc));
        }
        
        // Store intraday data in memory for 1D view (global store)
        let intradayData = []; // Array of {ts_utc, portfolio_value, ...}
        let intradayTimestamps = []; // Array of epoch ms for x-axis
        let intradayLabels = []; // Array of formatted labels for display
        
        // Load chart data based on range
        async function loadChartData(range) {
            const now = new Date();
            let data = [];
            let labels = [];
            let baselinePoints = [];
            
            switch (range) {
                case '1D':
                    // Use the global in-memory 1D series (don't reload)
                    data = intradayData;
                    labels = []; // Not used for 1D (uses numeric x-axis)
                    break;
                    
                case '7D':
                    // Use intraday data + historical data, 15-minute bins
                    data = [...intradayData];
                    for (let i = 6; i >= 1; i--) {
                        const date = new Date(now);
                        date.setDate(date.getDate() - i);
                        const dateStr = date.toISOString().split('T')[0];
                        const dayData = await loadTimeSeriesForDate(dateStr);
                        data = data.concat(dayData);
                    }
                    data = binDataByInterval(data, 15);
                    labels = data.map(point => {
                        const date = new Date(point.ts_utc);
                        return date.toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit',
                            timeZone: 'UTC'
                        }) + ' UTC';
                    });
                    break;
                    
                case '1M':
                    // Use intraday data + historical data, 60-minute bins
                    data = [...intradayData];
                    for (let i = 29; i >= 1; i--) {
                        const date = new Date(now);
                        date.setDate(date.getDate() - i);
                        const dateStr = date.toISOString().split('T')[0];
                        const dayData = await loadTimeSeriesForDate(dateStr);
                        data = data.concat(dayData);
                    }
                    data = binDataByInterval(data, 60);
                    labels = data.map(point => {
                        const date = new Date(point.ts_utc);
                        return date.toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric',
                            timeZone: 'UTC'
                        }) + ' UTC';
                    });
                    break;
                    
                case '3M':
                    // Use intraday data + historical data, 240-minute (4h) bins
                    data = [...intradayData];
                    for (let i = 89; i >= 1; i--) {
                        const date = new Date(now);
                        date.setDate(date.getDate() - i);
                        const dateStr = date.toISOString().split('T')[0];
                        const dayData = await loadTimeSeriesForDate(dateStr);
                        data = data.concat(dayData);
                    }
                    data = binDataByInterval(data, 240);
                    labels = data.map(point => {
                        const date = new Date(point.ts_utc);
                        return date.toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric',
                            timeZone: 'UTC'
                        }) + ' UTC';
                    });
                    break;
            }
            
            // Extract baseline points (post-execution timestamps)
            baselinePoints = data.filter(point => point.csv_filename && point.csv_filename.includes('-2355'));
            
            // Update chart
            updateChart(data, labels, baselinePoints);
        }
        
        // Initialize 1D data from time series (proper bootstrap)
        async function initializeIntradayData() {
            const today = new Date().toISOString().split('T')[0];
            console.log(`🔄 Loading full intraday history for ${today}...`);
            
            // Load today's full 1-minute file
            const data = await loadTimeSeriesForDate(today);
            console.log(`📊 Loaded ${data.length} minute ticks from timeseries`);
            
            // Clear and rebuild the global store
            intradayData = [];
            intradayTimestamps = [];
            intradayLabels = [];
            
            // Add all existing data points with proper timestamps
            data.forEach(point => {
                addIntradayPoint(point);
            });
            
            console.log(`✅ 1D bootstrap complete: ${intradayData.length} points from 00:00 UTC → now`);
        }
        
        // Add a single point to intraday data (with deduplication)
        function addIntradayPoint(tick) {
            const timestamp = new Date(tick.ts_utc).getTime();
            const date = new Date(tick.ts_utc);
            const timeLabel = date.getUTCHours().toString().padStart(2, '0') + ':' + 
                             date.getUTCMinutes().toString().padStart(2, '0') + ' UTC';
            
            // Check for duplicate timestamp (replace if same, append if new)
            const lastIndex = intradayData.length - 1;
            if (lastIndex >= 0 && intradayTimestamps[lastIndex] === timestamp) {
                // Replace last point (same timestamp)
                intradayData[lastIndex] = tick;
                intradayLabels[lastIndex] = timeLabel;
            } else {
                // Append new point
                intradayData.push(tick);
                intradayTimestamps.push(timestamp);
                intradayLabels.push(timeLabel);
            }
        }
        
        // Append new tick to 1D intraday data
        function appendIntradayTick(tick) {
            addIntradayPoint(tick);
            
            // Update chart if currently showing 1D
            if (currentRange === '1D' && portfolioValueChart) {
                updateIntradayChart();
            }
        }
        
        // Update the chart with current intraday data
        function updateIntradayChart() {
            if (!portfolioValueChart) return;
            
            // Use epoch timestamps for x-axis (numeric)
            const chartData = intradayData.map((point, index) => ({
                x: intradayTimestamps[index],
                y: point.portfolio_value
            }));
            
                    portfolioValueChart.data.datasets[0].data = chartData;
            portfolioValueChart.update('none');
            
            // Telemetry logging
            logChartTelemetry();
        }
        
        // Telemetry logging for chart state
        function logChartTelemetry() {
            if (intradayData.length === 0) return;
            
            const firstTs = intradayData[0].ts_utc;
            const lastTs = intradayData[intradayData.length - 1].ts_utc;
            const isMonotonic = intradayTimestamps.every((ts, i) => i === 0 || ts >= intradayTimestamps[i - 1]);
            const binsRendered = portfolioValueChart?.data.datasets[0].data.length || 0;
            
            console.log(`CHART_1D_POINTS=${intradayData.length}`);
            console.log(`CHART_1D_FIRST_TS=${firstTs} CHART_1D_LAST_TS=${lastTs} CHART_TS_MONOTONIC=${isMonotonic}`);
            console.log(`TICKS_TODAY_N=${intradayData.length}`);
            console.log(`RANGE=${currentRange} BINS_RENDERED=${binsRendered}`);
            
            // Check if last chart point matches UI
            if (lastTick) {
                const chartLastTs = lastTs;
                const uiTs = lastTick.ts_utc;
                const tsMatch = chartLastTs === uiTs;
                console.log(`CHART_LAST_TS==UI_TS=${tsMatch}`);
            }
        }
        
        // Update chart with new data
        function updateChart(data, labels, baselinePoints) {
            if (!portfolioValueChart) return;
            
            let chartData;
            if (currentRange === '1D') {
                // 1D uses numeric x-axis (epoch timestamps)
                chartData = intradayData.map((point, index) => ({
                    x: intradayTimestamps[index],
                    y: point.portfolio_value
                }));
            } else {
                // Other ranges use formatted labels
                chartData = data.map((point, index) => ({
                    x: labels[index],
                    y: point.portfolio_value
                }));
            }
            
            portfolioValueChart.data.datasets[0].data = chartData;
            portfolioValueChart.update('none');
            
            // Telemetry logging
            logChartTelemetry();
        }
        
        // Initialize sparkline
        function initializeSparkline() {
            const ctx = document.getElementById('portfolioSparkline').getContext('2d');
            portfolioSparkline = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 1,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 2
                    }]
                },
                options: {
                    responsive: false,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: { display: false },
                        y: { display: false }
                    },
                    elements: {
                        point: { radius: 0 }
                    }
                }
            });
        }
        
        // Update sparkline with last 60 minutes of data
        async function updateSparkline() {
            if (!portfolioSparkline) return;
            
            try {
                const now = new Date();
                const today = now.toISOString().split('T')[0];
                const data = await loadTimeSeriesForDate(today);
                
                // Get last 60 minutes of data
                const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
                const recentData = data.filter(point => new Date(point.ts_utc) >= oneHourAgo);
                
                if (recentData.length > 0) {
                    const labels = recentData.map(point => new Date(point.ts_utc).toLocaleTimeString('en-US', { 
                        hour: '2-digit', 
                        minute: '2-digit',
                        timeZone: 'UTC'
                    }));
                    const values = recentData.map(point => point.portfolio_value);
                    
                    portfolioSparkline.data.labels = labels;
                    portfolioSparkline.data.datasets[0].data = values;
                    portfolioSparkline.update('none');
                }
            } catch (error) {
                console.warn('Failed to update sparkline:', error);
            }
        }
        
        // Load and display portfolio value history from time series
        async function loadPortfolioValueHistory() {
            try {
                // Initialize intraday data first
                await initializeIntradayData();
                
                // Initialize range switcher and load initial data
                setupRangeSwitcher();
                await loadChartData(currentRange);
                
                // Initialize sparkline
                initializeSparkline();
                await updateSparkline();
                
            } catch (error) {
                console.error('❌ Error loading portfolio value history:', error);
            }
        }
        
        // Log CSV file usage for tracking
        async function logCSVUsage(csvFilename) {
            try {
                const now = new Date();
                const timestamp = now.toISOString();
                const date = now.toISOString().split('T')[0];
                const timeUTC = now.toISOString().substr(11, 8);
                const timeParis = now.toLocaleString('en-GB', {
                    timeZone: 'Europe/Paris',
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                
                const logEntry = {
                    timestamp,
                    date,
                    time_utc: timeUTC,
                    time_paris: timeParis,
                    csv_filename: csvFilename,
                    action: 'csv_loaded',
                    portfolio_value: initialCapital + cumulativePnL,
                    daily_pnl: 0,
                    daily_pnl_percent: 0,
                    cumulative_pnl: cumulativePnL,
                    total_positions: portfolioData ? portfolioData.length : 0,
                    long_positions: portfolioData ? portfolioData.filter(p => parseFloat(p.target_contracts) > 0).length : 0,
                    short_positions: portfolioData ? portfolioData.filter(p => parseFloat(p.target_contracts) < 0).length : 0,
                    long_notional: 0,
                    short_notional: 0,
                    total_long_notional: 0,
                    total_short_notional: 0,
                    total_gross_notional: 0,
                    gross_exposure: 0,
                    net_exposure: 0,
                    top_long_symbol: '',
                    top_long_weight: 0,
                    top_short_symbol: '',
                    top_short_weight: 0,
                    hit_rate_estimate: 0,
                    avg_win: 0,
                    avg_loss: 0,
                    reliability_ratio: 0
                };
                
                // Send to server for logging
                await fetch('/api/log-csv-usage', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(logEntry)
                });
                
                // Silently logged - no console noise
            } catch (error) {
                // Silently handle error - no console noise
            }
        }

        // Load cumulative P&L from daily log
        async function loadCumulativePnL() {
            try {
                // Check if we have a real portfolio log file (not the sample)
                const response = await fetch('/signal-dashboard/data/portfolio_daily_log.csv');
                if (!response.ok) {
                    console.log('📊 No real portfolio log file found, starting fresh with $0 cumulative P&L');
                    cumulativePnL = 0;
                    return;
                }
                
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');
                const headers = lines[0].split(',');
                const actionIndex = headers.indexOf('action');
                const cumulativeIndex = headers.indexOf('cumulative_pnl');
                const portfolioValueIndex = headers.indexOf('portfolio_value');
                const dateIndex = headers.indexOf('date');
                
                // Select base cumulative strictly from a prior UTC day; if none exists, base = 0 (Day 1 rule)
                const todayUTC = new Date().toISOString().split('T')[0];
                let baseRow = null;
                for (let i = lines.length - 1; i >= 1; i--) {
                    const row = lines[i].split(',');
                    if (row.length >= headers.length) {
                        const action = actionIndex >= 0 ? row[actionIndex] : row[5];
                        const rowDate = (dateIndex >= 0 ? row[dateIndex] : '').trim();
                        if (action === 'pre_execution' && rowDate && rowDate < todayUTC) { baseRow = row; break; }
                    }
                }
                if (baseRow) {
                    if (cumulativeIndex >= 0) {
                        cumulativePnL = parseFloat(baseRow[cumulativeIndex]) || 0;
                    } else if (portfolioValueIndex >= 0) {
                        const portfolioValue = parseFloat(baseRow[portfolioValueIndex]) || 0;
                    cumulativePnL = portfolioValue - initialCapital;
                } else {
                        cumulativePnL = 0;
                    }
                    console.log(`📊 Base cumulative P&L (prior-day pre_execution): $${formatCurrency(cumulativePnL)}`);
                } else {
                    console.log('📊 No prior-day pre_execution found: using Day 1 base = $0');
                    cumulativePnL = 0;
                }
            } catch (error) {
                console.error('❌ Error loading cumulative P&L:', error);
                console.log('📊 Starting fresh with $0 cumulative P&L');
                cumulativePnL = 0;
            }
        }

        // Load daily baseline prices (captured at post-execution)
        async function loadDailyBaseline() {
            try {
                const resp = await fetch('/signal-dashboard/data/daily_baseline.json?t=' + Date.now(), { cache: 'no-store' });
                if (!resp.ok) return;
                const data = await resp.json();
                baselinePrices = data.prices || {};
                baselinePortfolioValue = data.portfolio_value ?? null;
                window.__baselineCsvFilename = data.csv_filename || null;
                console.log('📌 Loaded daily baseline with', Object.keys(baselinePrices).length, 'symbols');
                
                // B) Baseline load — right after loading daily_baseline.json
                debugLog('BASELINE', {
                    timestamp_utc: data.timestamp_utc,
                    csv_filename: data.csv_filename,
                    portfolio_value: data.portfolio_value,
                    prices_count: Object.keys(baselinePrices).length,
                    sample_prices: Object.fromEntries(Object.entries(baselinePrices).slice(0, 5))
                });
            } catch (e) {
                baselinePrices = {};
                baselinePortfolioValue = null;
                window.__baselineCsvFilename = null;
            }
        }

        // Initialize CSV monitoring (disabled - external files missing)
        function initializeCSVMonitoring() {
            // Silently disabled - no console noise
        }
        
        // Update monitoring status display
        function updateMonitoringStatus(status, message) {
            const statusElement = document.getElementById('monitoring-status');
            statusElement.className = `monitoring-status ${status}`;
            
            const icons = {
                active: '✅',
                inactive: '❌',
                monitoring: '🔄'
            };
            
            statusElement.innerHTML = `${icons[status] || icons.monitoring} ${message}`;
        }
        
        // Fetch latest tick from time series
        async function fetchLatestTick() {
            try {
                const response = await fetch(`/signal-dashboard/timeseries/latest.json?t=${Date.now()}`, { cache: 'no-store' });
                if (response.ok) {
                    const tick = await response.json();
                    console.log('📊 Latest tick fetched:', tick);
                    
                    // A) Tick (single source of truth) — after fetching latest tick
                    debugLog('TICK', {
                        timestamp: tick.ts_utc,
                        portfolio_value: tick.portfolio_value,
                        daily_pnl: tick.daily_pnl,
                        total_pnl: tick.total_pnl,
                        base_cumulative: tick.base_cumulative,
                        csv_filename: tick.csv_filename,
                        mark_source: tick.mark_source,
                        is_day1_fallback: tick.is_day1_fallback
                    });
                    
                    return tick;
                }
            } catch (error) {
                console.warn('Failed to fetch latest tick:', error);
            }
            return null;
        }
        
        // Load CSV data
        async function loadPortfolioData() {
            try {
                console.log('Loading portfolio data...');
                
                // H) Symbol mapping audit — once at boot
                if (portfolioData && portfolioData.length > 0) {
                    const symbolMappings = portfolioData.map(position => {
                        const symbol = position.ticker || position.ric || position.internal_code || 'N/A';
                        const binanceSymbol = symbol.replace('_', '');
                        return {
                            original_symbol: symbol,
                            binance_symbol: binanceSymbol,
                            side: parseFloat(position.target_contracts) > 0 ? 'LONG' : 'SHORT',
                            notional: parseFloat(position.target_notional)
                        };
                    });
                    
                    debugLog('SYMBOL_MAPPING', {
                        total_positions: portfolioData.length,
                        unique_symbols: [...new Set(symbolMappings.map(m => m.original_symbol))].length,
                        unique_binance_symbols: [...new Set(symbolMappings.map(m => m.binance_symbol))].length,
                        mappings: symbolMappings.slice(0, 10), // Sample first 10
                        long_count: symbolMappings.filter(m => m.side === 'LONG').length,
                        short_count: symbolMappings.filter(m => m.side === 'SHORT').length
                    });
                }
                
                // Set loading state
                uiState = 'loading';
                
                // Load cumulative P&L first
                await loadCumulativePnL();
                
                // Load daily baseline (post-execution snapshot)
                await loadDailyBaseline();
                console.log('Baseline loaded:', { 
                    portfolioValue: baselinePortfolioValue, 
                    pricesCount: Object.keys(baselinePrices).length 
                });
                
                // Table will be populated from tick events only (not here)
                
                // Load portfolio value history for chart
                await loadPortfolioValueHistory();
                
                // Fetch and render latest tick atomically
                const latestTick = await fetchLatestTick();
                console.log('Latest tick result:', latestTick ? 'found' : 'not found');
                if (latestTick) {
                    console.log('Rendering from latest tick');
                    renderFromTick(latestTick);
                } else {
                    // No latest tick - try to render from last baseline or use fallback
                    console.log('No latest tick available, attempting fallback rendering...');
                    
                    // Try to use the last baseline data if available
                    if (baselinePortfolioValue !== null && Object.keys(baselinePrices).length > 0) {
                        console.log('Using last baseline data for rendering');
                        const fallbackTick = {
                            ts_utc: new Date().toISOString(),
                            portfolio_value: baselinePortfolioValue,
                            daily_pnl: 0,
                            total_pnl: baselinePortfolioValue - initialCapital,
                            base_cumulative: baselinePortfolioValue - initialCapital,
                            is_day1_fallback: false
                        };
                        renderFromTick(fallbackTick);
                    } else {
                        // No baseline either - use day1 fallback
                        console.log('No baseline available, using day1 fallback');
                        const day1Tick = {
                            ts_utc: new Date().toISOString(),
                            portfolio_value: initialCapital,
                            daily_pnl: 0,
                            total_pnl: 0,
                            base_cumulative: 0,
                            is_day1_fallback: true
                        };
                        renderFromTick(day1Tick);
                    }
                }
                
                // Ensure we always exit loading state - safety net
                if (uiState === 'loading') {
                    console.log('Safety net: forcing day1 fallback to exit loading state');
                    const safetyTick = {
                        ts_utc: new Date().toISOString(),
                        portfolio_value: initialCapital,
                        daily_pnl: 0,
                        total_pnl: 0,
                        base_cumulative: 0,
                        is_day1_fallback: true
                    };
                    renderFromTick(safetyTick);
                }
                
                // Always try to load CSV data for positions table
                console.log('🔄 Starting CSV loading process...');
                let requiredFilename = 'lpxd_external_advisors_DF_20250915-2355.csv';
                try {
                // Discover the latest filename from S3 latest.json
                    console.log('📡 Fetching latest.json...');
                const latestResp = await fetch('/signal-dashboard/data/latest.json?t=' + Date.now());
                if (latestResp.ok) {
                    const meta = await latestResp.json();
                    if (meta && meta.filename && meta.filename.endsWith('2355.csv')) {
                        requiredFilename = meta.filename;
                    }
                }
                console.log('🔍 Using CSV:', requiredFilename);
                const cacheBuster = `?t=${Date.now()}&v=2355`;
                    const csvUrl = '/signal-dashboard/data/' + requiredFilename + cacheBuster;
                    console.log('📡 Fetching CSV from:', csvUrl);
                    const response = await fetch(csvUrl);
                    if (!response.ok) {
                        console.error('❌ CSV fetch failed:', response.status, response.statusText);
                        throw new Error('CSV not found at expected S3 path');
                    }
                const csvText = await response.text();
                    console.log('✅ CSV loaded, length:', csvText.length, 'characters');
                
                portfolioData = parseCSV(csvText);
                    console.log('📊 CSV Parsed Successfully:', {
                        rows: portfolioData.length,
                        firstRow: portfolioData[0],
                        sampleData: portfolioData.slice(0, 3)
                    });
                
                if (portfolioData.length === 0) {
                    throw new Error('No data found in CSV');
                }
                
                // Update CSV status bar instead of popup
                // ALWAYS show 2355.csv status
                updateCSVStatus(requiredFilename);
                
                // Log CSV usage for tracking
                await logCSVUsage(requiredFilename);
                
                // Table will be populated from tick events only (not here)
                updateSummary();
                startLiveUpdates();
                
                    console.log('✅ CSV loading completed successfully');
                } catch (csvError) {
                    console.error('❌ CSV loading failed:', csvError);
                    // Don't throw - just log the error and continue
                    // The positions table will show "Loading..." which is better than crashing
                }
                
                // Log initial load as post-execution (disabled - external files missing)
                // if (portfolioLogger && portfolioData && portfolioData.length > 0) {
                //     setTimeout(async () => {
                //         await portfolioLogger.logPostExecution(requiredFilename);
                //         // Set initial pre-execution value for next day
                //         preExecutionPortfolioValue = initialCapital + cumulativePnL;
                //     }, 3000); // Wait for prices to load
                // }
                
                // Validate calculations after a short delay to ensure prices are loaded
                if (portfolioData && portfolioData.length > 0) {
                setTimeout(validatePnLCalculations, 2000);
                }
                
            } catch (error) {
                console.error('Error loading CSV:', error);
                // Show error message
                document.getElementById('portfolio-tbody').innerHTML = 
                    '<tr><td colspan="8" class="loading">Error loading data: ' + error.message + '</td></tr>';
                
                // CRITICAL: Ensure we always exit loading state even if CSV fails
                console.log('CSV loading failed, forcing fallback rendering...');
                if (uiState === 'loading') {
                    const fallbackTick = {
                        ts_utc: new Date().toISOString(),
                        portfolio_value: initialCapital,
                        daily_pnl: 0,
                        total_pnl: 0,
                        base_cumulative: 0,
                        is_day1_fallback: true
                    };
                    renderFromTick(fallbackTick);
                }
            }
        }
        
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',');
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                const row = {};
                headers.forEach((header, index) => {
                    row[header.trim()] = values[index] ? values[index].trim() : '';
                });
                data.push(row);
            }
            
            return data;
        }
        
        // CORRECT P&L CALCULATION FUNCTION (identity-based)
        function calculatePnL(side, notionalEntry, entryPrice, currentPrice) {
            // P&L % is always computed vs Entry; sign handled by side
            const rawPct = ((currentPrice - entryPrice) / entryPrice); // positive if current > entry
            const pnlPercent = (side === 'LONG' ? rawPct : -rawPct) * 100;
            
            // Enforce identity: PnL$ = |notional_at_entry| × PnL% (decimal)
            const notionalAbs = Math.abs(notionalEntry);
            const pnlDollar = notionalAbs * (pnlPercent / 100);
            
            return {
                qty: notionalAbs / entryPrice, // informational only
                pnlDollar,
                pnlPercent
            };
        }

        // Helper functions for number formatting
        function formatCurrency(value, decimals = 2) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: decimals,
                maximumFractionDigits: decimals
            }).format(value);
        }
        
        function formatNumber(value, decimals = 2) {
            return new Intl.NumberFormat('en-US', {
                minimumFractionDigits: decimals,
                maximumFractionDigits: decimals
            }).format(value);
        }
        
        function formatPercentage(value) {
            return new Intl.NumberFormat('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(value) + '%';
        }

        // Populate table from tick snapshot (ensures price synchronization)
        function populatePortfolioTableFromTick(tick) {
            if (!tick || !portfolioData || portfolioData.length === 0) {
                console.log('⏳ Skipping table population - missing tick or portfolio data');
                return;
            }
            
            // Hard gate: only populate when ALL conditions are met
            const baselineCount = Object.keys(baselinePrices).length;
            const requiredSymbols = portfolioData.length;
            
            if (baselineCount < requiredSymbols) {
                const reason = 'incomplete_baseline_coverage';
                console.log(`⏳ Skipping table population - only ${baselineCount}/${requiredSymbols} baseline prices loaded`);
                debugLog('TABLE_GATE', { reason, baseline_count: baselineCount, required_symbols: requiredSymbols, tick_timestamp: tick.ts_utc });
                return;
            }
            
            // Use marks from tick (exact prices used for this tick)
            const tickMarks = tick.marks || {};
            const marksCount = Object.keys(tickMarks).length;
            
            if (marksCount < requiredSymbols) {
                const reason = 'incomplete_tick_marks';
                console.log(`⏳ Skipping table population - only ${marksCount}/${requiredSymbols} marks in tick`);
                debugLog('TABLE_GATE', { reason, marks_count: marksCount, required_symbols: requiredSymbols, tick_timestamp: tick.ts_utc });
                return;
            }
            
            console.log('✅ Populating table from tick snapshot (using tick.marks, baseline prices only)');
            
            // D) Table populate gate — print EXACT reason if you skip
            debugLog('TABLE_GATE', {
                reason: 'proceeding_with_population',
                baseline_count: baselineCount,
                required_symbols: requiredSymbols,
                tick_marks_count: marksCount,
                tick_timestamp: tick.ts_utc,
                will_populate: true
            });
            
            // Use the same logic as populatePortfolioTable but with tick marks
            populatePortfolioTableInternal(tick, tickMarks);
        }
        
        function populatePortfolioTableInternal(tick, tickMarks) {
            console.log('🔄 populatePortfolioTableInternal called with portfolioData:', {
                exists: !!portfolioData,
                length: portfolioData ? portfolioData.length : 0,
                sample: portfolioData ? portfolioData.slice(0, 2) : null,
                baselinePricesCount: Object.keys(baselinePrices).length,
                tick_timestamp: tick?.ts_utc,
                tick_marks_count: Object.keys(tickMarks || {}).length
            });
            
            const longTbody = document.getElementById('long-portfolio-tbody');
            const shortTbody = document.getElementById('short-portfolio-tbody');
            
            longTbody.innerHTML = '';
            shortTbody.innerHTML = '';
            
            if (!portfolioData || portfolioData.length === 0) {
                console.log('❌ No portfolio data available, showing empty state');
                longTbody.innerHTML = '<tr><td colspan="8">No data available</td></tr>';
                shortTbody.innerHTML = '<tr><td colspan="8">No data available</td></tr>';
                return;
            }
            
            // Separate LONG and SHORT positions
            const longPositions = [];
            const shortPositions = [];
            let longTotalNotional = 0;
            let shortTotalNotional = 0;
            
            portfolioData.forEach(position => {
                const side = parseFloat(position.target_contracts) > 0 ? 'LONG' : 'SHORT';
                const notional = parseFloat(position.target_notional);
                
                if (side === 'LONG') {
                    longPositions.push(position);
                    longTotalNotional += notional;
                } else {
                    shortPositions.push(position);
                    shortTotalNotional += Math.abs(notional); // Use absolute value for short total
                }
            });
            
            // Sort each group by absolute weight (highest to lowest)
            longPositions.sort((a, b) => Math.abs(parseFloat(b.target_notional)) - Math.abs(parseFloat(a.target_notional)));
            shortPositions.sort((a, b) => Math.abs(parseFloat(b.target_notional)) - Math.abs(parseFloat(a.target_notional)));
            
            // Populate LONG positions table
            longPositions.forEach(position => {
                const row = document.createElement('tr');
                const symbol = position.ticker || position.ric || position.internal_code || 'N/A';
                const side = 'LONG';
                const weight = (parseFloat(position.target_notional) / 1000000) * 100;
                const notional = parseFloat(position.target_notional);
                const entryPrice = parseFloat(position.ref_price);
                const binanceSymbol = symbol.replace('_', '');
                const currentPrice = tickMarks[binanceSymbol];
                
                // Show loading state if no current price available yet
                const currentPriceDisplay = currentPrice ? formatCurrency(currentPrice, entryPrice < 1 ? 6 : 2) : 'Loading...';
                
                // CORRECT P&L CALCULATION using baseline prices for Daily P&L
                const baselinePrice = baselinePrices[binanceSymbol];
                const priceForPnL = baselinePrice; // Use baseline price only (no fallback)
                const pnlData = currentPrice ? calculatePnL('LONG', notional, priceForPnL, currentPrice) : null;
                
                // Debug specific symbols
                if (symbol.includes('TRX') || symbol.includes('UNI')) {
                    console.log(`🔍 ${symbol}: binanceSymbol=${binanceSymbol}, entry=${entryPrice}, baseline=${baselinePrice}, current=${currentPrice}, priceForPnL=${priceForPnL}, notional=${notional}, pnl=${pnlData?.pnlDollar}`);
                    if (!baselinePrice) {
                        console.error(`❌ ${symbol}: Missing baseline price for ${binanceSymbol}`);
                    }
                }
                
                // E) Per-row calc (only for rows that were previously wrong or sampled 3 random rows)
                if (symbol.includes('TRX') || symbol.includes('UNI') || Math.random() < 0.1) { // 10% random sampling
                    debugLog('PER_ROW_CALC', {
                        symbol: symbol,
                        binance_symbol: binanceSymbol,
                        side: 'LONG',
                        entry_price: entryPrice,
                        baseline_price: baselinePrice,
                        current_price: currentPrice,
                        price_for_pnl: priceForPnL,
                        notional: notional,
                        pnl_dollar: pnlData?.pnlDollar,
                        pnl_percent: pnlData?.pnlPercent,
                        using_baseline: !!baselinePrice
                    });
                }
                const pnlDollar = pnlData ? pnlData.pnlDollar : null;
                const pnlPercent = pnlData ? pnlData.pnlPercent : null;
                
                row.innerHTML = `
                    <td>${symbol}</td>
                    <td class="side-long">${side}</td>
                    <td>${formatPercentage(weight)}</td>
                    <td>${formatCurrency(notional)}</td>
                    <td>${formatCurrency(entryPrice, entryPrice < 1 ? 6 : 2)}</td>
                    <td>${currentPriceDisplay}</td>
                    <td class="${pnlDollar !== null ? (pnlDollar >= 0 ? 'pnl-positive' : 'pnl-negative') : ''}">${pnlDollar !== null ? formatCurrency(pnlDollar) : 'Loading...'}</td>
                    <td class="${pnlPercent !== null ? (pnlPercent >= 0 ? 'pnl-positive' : 'pnl-negative') : ''}">${pnlPercent !== null ? formatPercentage(pnlPercent) : 'Loading...'}</td>
                `;
                
                longTbody.appendChild(row);
            });
            
            // Populate SHORT positions table
            shortPositions.forEach(position => {
                const row = document.createElement('tr');
                const symbol = position.ticker || position.ric || position.internal_code || 'N/A';
                const side = 'SHORT';
                const weight = (parseFloat(position.target_notional) / 1000000) * 100;
                const notional = parseFloat(position.target_notional);
                const entryPrice = parseFloat(position.ref_price);
                const binanceSymbol = symbol.replace('_', '');
                const currentPrice = tickMarks[binanceSymbol];
                
                // Show loading state if no current price available yet
                const currentPriceDisplay = currentPrice ? formatCurrency(currentPrice, entryPrice < 1 ? 6 : 2) : 'Loading...';
                
                // CORRECT P&L CALCULATION using baseline prices for Daily P&L
                const baselinePrice = baselinePrices[binanceSymbol];
                const priceForPnL = baselinePrice; // Use baseline price only (no fallback)
                const pnlData = currentPrice ? calculatePnL('SHORT', notional, priceForPnL, currentPrice) : null;
                
                // Debug specific symbols
                if (symbol.includes('TRX') || symbol.includes('UNI')) {
                    console.log(`🔍 ${symbol}: binanceSymbol=${binanceSymbol}, entry=${entryPrice}, baseline=${baselinePrice}, current=${currentPrice}, priceForPnL=${priceForPnL}, notional=${notional}, pnl=${pnlData?.pnlDollar}`);
                    if (!baselinePrice) {
                        console.error(`❌ ${symbol}: Missing baseline price for ${binanceSymbol}`);
                    }
                }
                
                // E) Per-row calc (only for rows that were previously wrong or sampled 3 random rows)
                if (symbol.includes('TRX') || symbol.includes('UNI') || Math.random() < 0.1) { // 10% random sampling
                    debugLog('PER_ROW_CALC', {
                        symbol: symbol,
                        binance_symbol: binanceSymbol,
                        side: 'SHORT',
                        entry_price: entryPrice,
                        baseline_price: baselinePrice,
                        current_price: currentPrice,
                        price_for_pnl: priceForPnL,
                        notional: notional,
                        pnl_dollar: pnlData?.pnlDollar,
                        pnl_percent: pnlData?.pnlPercent,
                        using_baseline: !!baselinePrice
                    });
                }
                const pnlDollar = pnlData ? pnlData.pnlDollar : null;
                const pnlPercent = pnlData ? pnlData.pnlPercent : null;
                
                row.innerHTML = `
                    <td>${symbol}</td>
                    <td class="side-short">${side}</td>
                    <td>${formatPercentage(weight)}</td>
                    <td>${formatCurrency(notional)}</td>
                    <td>${formatCurrency(entryPrice, entryPrice < 1 ? 6 : 2)}</td>
                    <td>${currentPriceDisplay}</td>
                    <td class="${pnlDollar !== null ? (pnlDollar >= 0 ? 'pnl-positive' : 'pnl-negative') : ''}">${pnlDollar !== null ? formatCurrency(pnlDollar) : 'Loading...'}</td>
                    <td class="${pnlPercent !== null ? (pnlPercent >= 0 ? 'pnl-positive' : 'pnl-negative') : ''}">${pnlPercent !== null ? formatPercentage(pnlPercent) : 'Loading...'}</td>
                `;
                
                shortTbody.appendChild(row);
            });
            
            // Calculate net P&L for each group
            let longNetPnL = 0;
            let shortNetPnL = 0;
            
            longPositions.forEach(position => {
                const symbol = position.ticker || position.ric || position.internal_code || 'N/A';
                const notional = parseFloat(position.target_notional);
                const entryPrice = parseFloat(position.ref_price);
                const binanceSymbol = symbol.replace('_', '');
                const currentPrice = tickMarks[binanceSymbol];
                
                if (currentPrice) {
                    const baselinePrice = baselinePrices[binanceSymbol];
                    const priceForPnL = baselinePrice || entryPrice; // Use baseline if available, fallback to entry
                    const pnlData = calculatePnL('LONG', notional, priceForPnL, currentPrice);
                    longNetPnL += pnlData.pnlDollar;
                }
            });
            
            shortPositions.forEach(position => {
                const symbol = position.ticker || position.ric || position.internal_code || 'N/A';
                const notional = parseFloat(position.target_notional);
                const entryPrice = parseFloat(position.ref_price);
                const binanceSymbol = symbol.replace('_', '');
                const currentPrice = tickMarks[binanceSymbol];
                
                if (currentPrice) {
                    const baselinePrice = baselinePrices[binanceSymbol];
                    const priceForPnL = baselinePrice || entryPrice; // Use baseline if available, fallback to entry
                    const pnlData = calculatePnL('SHORT', notional, priceForPnL, currentPrice);
                    shortNetPnL += pnlData.pnlDollar;
                }
            });
            
            // Add net P&L summary rows
            if (longPositions.length > 0) {
                const longNetRow = document.createElement('tr');
                longNetRow.className = 'net-pnl-row';
                longNetRow.innerHTML = `
                    <td colspan="6"><strong>Net P&L (Long Positions)</strong></td>
                    <td class="${longNetPnL >= 0 ? 'pnl-positive' : 'pnl-negative'}"><strong>${formatCurrency(longNetPnL)}</strong></td>
                    <td class="${longNetPnL >= 0 ? 'pnl-positive' : 'pnl-negative'}"><strong>${formatPercentage((longNetPnL / longTotalNotional) * 100)}</strong></td>
                `;
                longTbody.appendChild(longNetRow);
            }
            
            if (shortPositions.length > 0) {
                const shortNetRow = document.createElement('tr');
                shortNetRow.className = 'net-pnl-row';
                shortNetRow.innerHTML = `
                    <td colspan="6"><strong>Net P&L (Short Positions)</strong></td>
                    <td class="${shortNetPnL >= 0 ? 'pnl-positive' : 'pnl-negative'}"><strong>${formatCurrency(shortNetPnL)}</strong></td>
                    <td class="${shortNetPnL >= 0 ? 'pnl-positive' : 'pnl-negative'}"><strong>${formatPercentage((shortNetPnL / shortTotalNotional) * 100)}</strong></td>
                `;
                shortTbody.appendChild(shortNetRow);
            }
            
            // Update total notional amounts
            document.getElementById('long-total-notional').textContent = formatCurrency(longTotalNotional);
            document.getElementById('short-total-notional').textContent = formatCurrency(shortTotalNotional);
            
            // F) Table totals vs cards — AFTER populating the table
            const tableNetPnL = longNetPnL + shortNetPnL;
            const dailyPnLCard = parseFloat(document.getElementById('daily-pnl').textContent.replace(/[$,]/g, '')) || 0;
            const delta = Math.abs(tableNetPnL - dailyPnLCard);
            
            debugLog('TABLE_TOTALS', {
                tick_timestamp: tick?.ts_utc,
                long_net_pnl: longNetPnL,
                short_net_pnl: shortNetPnL,
                table_net_pnl: tableNetPnL,
                daily_pnl_card: dailyPnLCard,
                delta_cents: Math.round(delta * 100),
                match: delta < 0.01,
                long_positions_count: longPositions.length,
                short_positions_count: shortPositions.length,
                long_total_notional: longTotalNotional,
                short_total_notional: shortTotalNotional
            });
            
        // Add to Ops Report (so we never debate this again)
        console.log(`TICK_TS=${tick?.ts_utc}`);
        console.log(`TICK_MARKS_COUNT=${Object.keys(tickMarks || {}).length}`);
        console.log(`TABLE_NET_PNL=${tableNetPnL.toFixed(2)} CARD_DAILY=${dailyPnLCard.toFixed(2)} DELTA_CENTS=${Math.round(delta * 100)} MATCH=${delta < 0.01}`);
        }
        
        function updateSummary() {
            // Legacy function - now only updates position count
            // All card rendering is handled by renderFromTick()
            if (!portfolioData || portfolioData.length === 0) return;
            
            // Only update position count (cards are handled by atomic tick rendering)
            document.getElementById('position-count').textContent = formatNumber(portfolioData.length, 0);
        }
        
        // Global function for manual testing - FIXED to maintain consistency
        window.manualRecalculateCards = function() {
            console.log('🔧 Manual recalculation triggered - cards will match table P&L');
            recalculateCardsWithFreshPrices();
        };
        
        // Auto-trigger recalculation after a delay to ensure all data is loaded
        setTimeout(() => {
            console.log('🔄 Auto-triggering recalculation - cards will match table P&L');
            if (window.manualRecalculateCards) {
                window.manualRecalculateCards();
            }
        }, 10000);
        
        // Global function for direct testing
        window.testDailyPnLCalculation = function() {
            console.log('🧪 Testing Daily P&L calculation directly...');
            
            if (!currentPrices || !portfolioData || !baselinePrices) {
                console.log('❌ Missing data:', {
                    currentPrices: !!currentPrices,
                    portfolioData: !!portfolioData,
                    baselinePrices: !!baselinePrices
                });
                return;
            }
            
            let totalPnL = 0;
            for (const position of portfolioData.slice(0, 3)) { // Test first 3
                const symbol = position.ticker;
                const binanceSymbol = symbol.replace('_', '');
                const baselinePrice = baselinePrices[binanceSymbol];
                const currentPrice = currentPrices[binanceSymbol];
                const side = parseFloat(position.target_contracts) > 0 ? 1 : -1;
                const notional = parseFloat(position.target_notional);
                const pnl = side * (currentPrice - baselinePrice) / baselinePrice * notional;
                totalPnL += pnl;
                
                console.log(`${symbol}: ${baselinePrice} -> ${currentPrice}, pnl=${pnl.toFixed(2)}`);
            }
            
            console.log(`🧪 Test calculation (first 3): ${totalPnL.toFixed(2)}`);
            console.log('🧪 Expected total (all 29): -15593.12');
        };
        
        // FIXED: This function now updates cards to match table calculations
        // Cards will be updated to match the table's P&L calculation
        function recalculateCardsWithFreshPrices() {
            console.log('🔄 Recalculating cards to match table P&L...', new Date().toISOString());
            console.log('🔍 Data availability check:', {
                has_currentPrices: !!currentPrices,
                currentPrices_count: currentPrices ? Object.keys(currentPrices).length : 0,
                has_portfolioData: !!portfolioData,
                portfolioData_length: portfolioData ? portfolioData.length : 0,
                has_baselinePrices: !!baselinePrices,
                baselinePrices_count: baselinePrices ? Object.keys(baselinePrices).length : 0,
                has_lastTick: !!lastTick
            });
            
            if (!currentPrices || !portfolioData || !baselinePrices || !lastTick) {
                console.log('⚠️ Cannot recalculate cards - missing data');
                return;
            }
            
            if (Object.keys(currentPrices).length < 29) {
                console.log('⚠️ Cannot recalculate cards - currentPrices incomplete:', Object.keys(currentPrices).length, 'of 29');
                return;
            }
            
            // Calculate P&L using the same logic as the table
            let realDailyPnL = 0;
            let calculatedPositions = 0;
            
            for (const position of portfolioData) {
                const symbol = position.ticker || position.ric || position.internal_code || 'N/A';
                const binanceSymbol = symbol.replace('_', '');
                const baselinePrice = baselinePrices[binanceSymbol];
                const currentPrice = currentPrices[binanceSymbol];
                
                if (baselinePrice && currentPrice) {
                    const entryPrice = parseFloat(position.ref_price);
                    const notional = parseFloat(position.notional);
                    const side = position.side === 'LONG' ? 1 : -1;
                    
                    // Use the same P&L calculation as the table
                    const pnl = (currentPrice - baselinePrice) * side * notional / baselinePrice;
                    realDailyPnL += pnl;
                    calculatedPositions++;
                    
                    console.log(`🔍 ${symbol}: baseline=${baselinePrice}, current=${currentPrice}, side=${side}, notional=${notional}, pnl=${pnl.toFixed(2)}`);
                }
            }
            
            console.log(`🔍 Calculated ${calculatedPositions} positions, total P&L: ${realDailyPnL.toFixed(2)}`);
            
            // Update cards to match the table calculation
            const dailyPnL = realDailyPnL;
            const totalPnL = lastTick.total_pnl; // Keep total P&L from tick
            const portfolioValue = lastTick.portfolio_value; // Keep portfolio value from tick
            
            console.log('🔍 Recalculated realDailyPnL:', dailyPnL.toFixed(2));
            
            // Update the cards with the calculated values
            document.getElementById('daily-pnl').textContent = formatCurrency(dailyPnL);
            document.getElementById('daily-pnl').className = `value ${dailyPnL >= 0 ? 'positive' : 'negative'}`;
            
            const dailyPercent = (dailyPnL / initialCapital) * 100;
            document.getElementById('daily-pnl-percent').textContent = `(${formatPercentage(dailyPercent)})`;
            document.getElementById('daily-pnl-percent').className = `percentage ${dailyPnL >= 0 ? 'positive' : 'negative'}`;
            
            console.log('✅ Daily P&L card updated to match table calculation!');
            console.log('✅ Cards now show:', formatCurrency(dailyPnL));
            console.log('🔍 Data availability check:', {
                has_currentPrices: !!currentPrices,
                currentPrices_count: currentPrices ? Object.keys(currentPrices).length : 0,
                has_portfolioData: !!portfolioData,
                portfolioData_length: portfolioData ? portfolioData.length : 0,
                has_baselinePrices: !!baselinePrices,
                baselinePrices_count: baselinePrices ? Object.keys(baselinePrices).length : 0,
                has_lastTick: !!lastTick
            });
            
            if (!currentPrices || !portfolioData || !baselinePrices || !lastTick) {
                console.log('⚠️ Cannot recalculate cards - missing data');
                return;
            }
            
            if (Object.keys(currentPrices).length < 29) {
                console.log('⚠️ Cannot recalculate cards - currentPrices incomplete:', Object.keys(currentPrices).length, 'of 29');
                    return;
                }
                
            let realDailyPnL = 0;
            let calculatedPositions = 0;
            
            for (const position of portfolioData) {
                // Use the same symbol extraction logic as the table
                const symbol = position.ticker || position.ric || position.internal_code || 'N/A';
                const binanceSymbol = symbol.replace('_', '');
                const baselinePrice = baselinePrices[binanceSymbol];
                const currentPrice = currentPrices[binanceSymbol];
                
                if (baselinePrice && currentPrice) {
                    // Use the same side detection logic as the table
                    const side = parseFloat(position.target_contracts) > 0 ? 1 : -1;
                    const notional = parseFloat(position.target_notional);
                    const pnl = side * (currentPrice - baselinePrice) / baselinePrice * notional;
                    realDailyPnL += pnl;
                    calculatedPositions++;
                    
                    // Show first few calculations
                    if (calculatedPositions <= 3) {
                        console.log(`🔍 ${symbol}: baseline=${baselinePrice}, current=${currentPrice}, side=${side}, notional=${notional.toFixed(0)}, pnl=${pnl.toFixed(2)}`);
                    }
            } else {
                    console.log(`⚠️ Missing data for ${symbol}: baseline=${!!baselinePrice}, current=${!!currentPrice}`);
                }
            }
            
            console.log(`🔍 Calculated ${calculatedPositions} positions, total P&L: ${realDailyPnL.toFixed(2)}`);
            
            console.log(`🔍 Recalculated realDailyPnL: ${realDailyPnL.toFixed(2)}`);
            
            // Update the Daily P&L card with the fresh calculation
            document.getElementById('daily-pnl').textContent = formatCurrency(realDailyPnL);
            document.getElementById('daily-pnl').className = `value ${realDailyPnL >= 0 ? 'positive' : 'negative'}`;
            
            const dailyPercent = (realDailyPnL / initialCapital) * 100;
            document.getElementById('daily-pnl-percent').textContent = `(${formatPercentage(dailyPercent)})`;
            document.getElementById('daily-pnl-percent').className = `percentage ${realDailyPnL >= 0 ? 'positive' : 'negative'}`;
            
            // Add success indicator
            console.log('✅ Daily P&L card updated successfully!');
            console.log(`✅ Cards now show: ${formatCurrency(realDailyPnL)}`);
            console.log(`✅ Expected: -$15,593.12`);
            console.log(`✅ Match: ${Math.abs(realDailyPnL - (-15593.12)) < 1 ? 'YES' : 'NO'}`);
        }
        
        async function fetchBinancePrices() {
            try {
                const symbols = portfolioData.map(p => (p.ticker || p.ric || p.internal_code).replace('_', ''));
                console.log('Fetching prices for symbols:', symbols);
                
                // Fetch prices one by one to avoid API issues
                for (const symbol of symbols) {
                    try {
                        const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`);
                        if (response.ok) {
                            const priceData = await response.json();
                            currentPrices[symbol] = parseFloat(priceData.price);
                            console.log(`Updated ${symbol}: $${priceData.price}`);
                        }
                    } catch (symbolError) {
                        console.warn(`Failed to fetch price for ${symbol}:`, symbolError);
                    }
                }
                
                console.log('All updated prices:', currentPrices);
                
                // C) Quotes status — after fetching all 29 current prices
                debugLog('QUOTES', {
                    total_symbols: symbols.length,
                    fetched_prices: Object.keys(currentPrices).length,
                    missing_prices: symbols.filter(s => !currentPrices[s]),
                    sample_prices: Object.fromEntries(Object.entries(currentPrices).slice(0, 5)),
                    fetch_timestamp: new Date().toISOString()
                });
                
                // Note: Table population is now only triggered by tick events, not quote fetches
                
                // Recalculate cards with fresh prices if we have a current tick
                if (lastTick && portfolioData && portfolioData.length > 0) {
                    console.log('🔄 All prices fetched, now recalculating cards...');
                    console.log('🔍 Price fetch completion check:', {
                        symbols_requested: symbols.length,
                        prices_fetched: Object.keys(currentPrices).length,
                        portfolio_positions: portfolioData.length
                    });
                    
                    // DISABLED: Only recalculate if we have all 29 prices
                    if (Object.keys(currentPrices).length === 29) {
                        console.log('🚫🚫🚫 Price recalculation DISABLED - cards use tick snapshot only 🚫🚫🚫');
                        // recalculateCardsWithFreshPrices(); // REMOVED: Causes P&L mismatch with table
                    } else {
                        console.log('⚠️ Skipping recalculation - incomplete price data');
                        // DISABLED: Fallback: try again in 2 seconds
                        setTimeout(() => {
                            if (Object.keys(currentPrices).length === 29) {
                                console.log('🚫🚫🚫 Fallback recalculation DISABLED - cards use tick snapshot only 🚫🚫🚫');
                                // recalculateCardsWithFreshPrices(); // REMOVED: Causes P&L mismatch with table
                            }
                        }, 2000);
                    }
                }
                
            } catch (error) {
                console.error('Error fetching Binance prices:', error);
            }
        }
        
        function startLiveUpdates() {
            // Fetch real prices every 2 minutes
            fetchBinancePrices();
            setInterval(fetchBinancePrices, 120000);
            
            // DISABLED: Simulate price movements for immediate feedback
            console.log('🚫🚫🚫 simulatePriceMovements() call REMOVED - causes P&L mismatch 🚫🚫🚫');
            // simulatePriceMovements(); // REMOVED: Causes P&L mismatch with table
            
            // Update display every 5 seconds
            setInterval(async () => {
                // Always try to fetch latest tick and render (rendering is tick-driven, not CSV-driven)
                const latestTick = await fetchLatestTick();
                if (latestTick) {
                    renderFromTick(latestTick);
                    
                    // Update sparkline
                    await updateSparkline();
                    
                    // DISABLED: Force recalculation of cards every 5 seconds to ensure they stay in sync
                    if (currentPrices && portfolioData && baselinePrices) {
                        console.log('🚫🚫🚫 Periodic recalculation DISABLED - cards use tick snapshot only 🚫🚫🚫');
                        // recalculateCardsWithFreshPrices(); // REMOVED: Causes P&L mismatch with table
                    }
                } else if (uiState === 'loading') {
                    // Still in loading state - update table but don't render cards yet
                updateSummary();
                }
                // If no latest tick but not in loading state, keep current display
            }, 5000);
        }
        
        // COMPLETELY REMOVED: This function causes P&L mismatch by adding artificial price movements
        function simulatePriceMovements() {
            console.log('🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫 simulatePriceMovements() COMPLETELY REMOVED - causes P&L mismatch 🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫');
            console.log('🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫 NEW CODE VERSION 4.0 - CACHE BUSTED 🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫');
            console.log('🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫 TIMESTAMP: ' + new Date().toISOString() + ' 🚫🚫🚫🚫🚫🚫🚫🚫🚫🚫');
            return; // Early return to prevent execution
            // Add some price variation to show P&L working
            setInterval(() => {
                if (portfolioData.length > 0) {
                    portfolioData.forEach(position => {
                        const symbol = position.ticker || position.ric || position.internal_code;
                        const entryPrice = parseFloat(position.ref_price);
                        
                        // If we don't have a current price, start with entry price
                        if (!currentPrices[symbol]) {
                            currentPrices[symbol] = entryPrice;
                        }
                        
                        // Add small random price movements (-2% to +2%)
                        const variation = (Math.random() - 0.5) * 0.04; // ±2%
                        currentPrices[symbol] = entryPrice * (1 + variation);
                    });
                    
                    console.log('Simulated price movements applied');
                }
            }, 10000); // Update every 10 seconds
        }
        
        // Notification system
        function showNotification(type, title, message) {
            const notificationsDiv = document.getElementById('notifications');
            if (!notificationsDiv) {
                // Create notifications container if it doesn't exist
                const container = document.createElement('div');
                container.id = 'notifications';
                container.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 1000;';
                document.body.appendChild(container);
            }
            
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = `
                <div class="notification-content">
                    <span class="notification-icon">${getNotificationIcon(type)}</span>
                    <div class="notification-text">
                        <div class="notification-title">${title}</div>
                        <div class="notification-message">${message}</div>
                    </div>
                    <button class="notification-close" onclick="this.parentElement.parentElement.remove()">×</button>
                </div>
            `;
            
            document.getElementById('notifications').appendChild(notification);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 5000);
        }
        
        function getNotificationIcon(type) {
            const icons = {
                info: 'ℹ️',
                success: '✅',
                error: '❌',
                warning: '⚠️'
            };
            return icons[type] || icons.info;
        }
        
        // Validation function to check P&L calculations with sanity checks
        function validatePnLCalculations() {
            if (!portfolioData || !currentPrices) return;
            
            console.log('🔍 Validating P&L calculations...');
            let errors = 0;
            
            portfolioData.forEach(position => {
                const symbol = position.ticker || position.ric || position.internal_code;
                const notional = parseFloat(position.target_notional);
                const entryPrice = parseFloat(position.ref_price);
                const binanceSymbol = symbol.replace('_', '');
                const currentPrice = currentPrices[binanceSymbol];
                
                if (!currentPrice) return;
                
                const side = parseFloat(position.target_contracts) > 0 ? 'LONG' : 'SHORT';
                const pnlData = calculatePnL(side, notional, entryPrice, currentPrice);
                
                // SANITY CHECKS
                
                // 1. If Current = Entry, then P&L must be 0
                if (Math.abs(currentPrice - entryPrice) < 0.000001) {
                    if (Math.abs(pnlData.pnlDollar) > 0.01) {
                        console.error(`❌ ${symbol}: Current = Entry but P&L ≠ 0: $${pnlData.pnlDollar.toFixed(2)}`);
                        errors++;
                    }
                }
                
                // 2. For shorts, if Current > Entry, P&L must be negative
                if (side === 'SHORT' && currentPrice > entryPrice) {
                    if (pnlData.pnlDollar >= 0) {
                        console.error(`❌ ${symbol}: Short with Current > Entry but P&L ≥ 0: $${pnlData.pnlDollar.toFixed(2)}`);
                        errors++;
                    }
                }
                
                // 3. For longs, if Current > Entry, P&L must be positive
                if (side === 'LONG' && currentPrice > entryPrice) {
                    if (pnlData.pnlDollar <= 0) {
                        console.error(`❌ ${symbol}: Long with Current > Entry but P&L ≤ 0: $${pnlData.pnlDollar.toFixed(2)}`);
                        errors++;
                    }
                }
                
                // 4. Back-of-envelope check: P&L ≈ Notional × (Current - Entry)/Entry
                const expectedPnL = notional * (currentPrice - entryPrice) / entryPrice;
                const pnlError = Math.abs(pnlData.pnlDollar - expectedPnL) / Math.abs(expectedPnL);
                
                if (pnlError > 0.01) { // 1% tolerance
                    console.warn(`⚠️ ${symbol}: P&L mismatch - calculated: $${pnlData.pnlDollar.toFixed(2)}, expected: $${expectedPnL.toFixed(2)}, error: ${(pnlError * 100).toFixed(2)}%`);
                    errors++;
                }
            });
            
            if (errors === 0) {
                console.log('✅ All P&L calculations validated successfully');
            } else {
                console.warn(`❌ Found ${errors} calculation errors`);
            }
        }

        // Update CSV status bar
        function updateCSVStatus(filename) {
            const filenameElement = document.getElementById('current-csv-filename');
            
            if (filenameElement) {
                // Store the filename for the toggle function
                filenameElement.dataset.filename = filename;
                // Keep the display as "Click to show file" initially
                filenameElement.querySelector('.filename-display').textContent = 'Click to show file';
            }
        }
        
        // Toggle CSV details when clicked
        function toggleCSVDetails() {
            const filenameElement = document.getElementById('current-csv-filename');
            const filename = filenameElement.dataset.filename;
            const displayElement = filenameElement.querySelector('.filename-display');
            
            if (!filename || filename === 'Loading...') {
                // No CSV data - this is normal between executions
                // Don't show public notification, just log to console
                console.log('No CSV file currently loaded - this is normal between executions');
                return;
            }
            
            // Toggle between showing filename and "Click to show file"
            if (displayElement.textContent === 'Click to show file') {
                displayElement.textContent = filename;
                filenameElement.title = 'Click to hide file details';
            } else {
                displayElement.textContent = 'Click to show file';
                filenameElement.title = 'Click to show file details';
            }
        }

        // Clock functions
        function updateClock() {
            const now = new Date();
            const utcTime = now.toISOString().substr(11, 8);
            const parisTime = now.toLocaleString('en-GB', { 
                timeZone: 'Europe/Paris',
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            
            document.getElementById('clock').textContent = `${utcTime} / ${parisTime}`;
        }
        
        function startClock() {
            updateClock(); // Initial update
            setInterval(updateClock, 1000); // Update every second
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🚀 Dashboard initializing...');
            initializePortfolioValueChart();
            
            // Force immediate fallback rendering as safety net
            setTimeout(() => {
                if (uiState === 'loading') {
                    console.log('⚠️ Still in loading state after 3 seconds, forcing fallback...');
                    const emergencyTick = {
                        ts_utc: new Date().toISOString(),
                        portfolio_value: initialCapital,
                        daily_pnl: 0,
                        total_pnl: 0,
                        base_cumulative: 0,
                        is_day1_fallback: true
                    };
                    renderFromTick(emergencyTick);
                }
            }, 3000);
            
            loadPortfolioData();
            initializeCSVMonitoring();
            startClock();
        });
    </script>
</body>
</html>

